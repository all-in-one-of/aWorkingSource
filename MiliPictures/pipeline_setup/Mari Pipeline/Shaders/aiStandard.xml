<Node>
/* ?2014 Antonio Lisboa M. Neto, Based on Arnold Renderer - Ai Standard, this is a Custom Standalone Shader replica for MARI written in OpenGL Shading Language with support of Solid Angle. */
<!-- Arnold is Copyright of Solid Angle Ltd. The following code is an adaptation for MARI in GLSL of the original code from the shader aiStandard and a personal attempt to create a shader that visually resemble like it, as well internal controls over the sliders and their attributes. -->

  <DefaultName>aiStandard</DefaultName>
  <Inputs>	
    <Input Name="DiffuseColor" 	    	PrettyName="Diffuse Color"						></Input>
	<Input Name="DiffuseRoughness"  	PrettyName="Diffuse Roughness"					></Input>
	<Input Name="SpecularColor"     	PrettyName="Specular Color"						></Input>
    <Input Name="SpecularRoughness" 	PrettyName="Specular Roughness"					></Input>
	<Input Name="Anisotropy" 			PrettyName="Anisotropy"							></Input>
	<Input Name="Rotation" 				PrettyName="Rotation"							></Input>
	<Input Name="Reflectance"			PrettyName="Reflectance at Normal (Specular)"	></Input>				
	<Input Name="ReflectionColor"     	PrettyName="Reflection Color"					></Input>
	<Input Name="Reflectance_Ref"		PrettyName="Reflectance at Normal (Reflection)"	></Input>
	<Input Name="RefractionColor"		PrettyName="Refraction Color"					></Input>
    <Input Name="RefractionRoughness"	PrettyName="Refraction Roughness" 				></Input>
	<Input Name="Transmittance" 	    PrettyName="Transmittance"						></Input>	
	<Input Name="Opacity" 	    		PrettyName="Opacity"							></Input>
	<Input Name="SSSColor"     			PrettyName="Sub-Surface Scattering Color"		></Input>
	<Input Name="SSSRadius"     		PrettyName="Sub-Surface Scattering Radius"		></Input>
	<Input Name="EmissionColor" 		PrettyName="Emission Color"						></Input>
	<Input Name="Bump"					PrettyName="Bump Map"							></Input>
    <Input Name="Normal"				PrettyName="Normal Map"							></Input>
	<Input Name="Displacement"			PrettyName="Displacement Map"					></Input>
	<Input Name="Vector" 				PrettyName="Vector Map"							></Input>
	<Input Name="ThicknessMap" 			PrettyName="Thickness Map"						></Input>
	<Input Name="View_Current_Channel" 	PreferredInput='1'></Input>
  </Inputs>
  <Attributes>
	<Attribute Name="shadingNode" 					PrettyName="Type"								Group="" 						Type="stringlist" 	Description="(c)2014 Antonio Lisboa M. Neto, Based on Arnold Renderer - Ai Standard.\nThis is a Custom Standalone Shader replica for MARI written in OpenGL Shading Language with support of Solid Angle.">Ai Standard,Ai Standard</Attribute>
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name="DiffuseColor"					PrettyName="Diffuse Color"						Group="Diffuse"					Type="color" 		Description="">(1,1,1,1)</Attribute>
	<Attribute Name="DiffuseWeight" 				PrettyName="Diffuse Weight"						Group="Diffuse"					Type="double"		Description="The diffuse weight is multiplied by the Diffuse map"	Min="0" Max="1">0.7</Attribute>
	<Attribute Name="DiffuseRoughness" 				PrettyName="Diffuse Roughness"					Group="Diffuse"					Type="double"		Description="The diffuse component follows an Oren-Nayar reflection model with surface roughness.\nA value of 0.0 is comparable to a Lambert reflection.\nHigher values will result in a rougher surface look more suitable for materials like concrete, plaster or sand." Min="0" Max="1">0.0</Attribute>
	<Attribute Name="Backlight" 					PrettyName="Backlight"							Group="Diffuse"					Type="double"		Description="Backlight provides the effect of a translucent object being lit from behind\n(the shading point is 'lit' by the specified fraction of the light hitting the reverse of the object at that point)."	Min="0" Max="1">0.0</Attribute>
	<Attribute Name="DiffuseFresnel"   				PrettyName="Fresnel affects Diffuse"			Group="Diffuse"					Type="bool"			Description="Specify whether Fresnel affects the diffuse component.\nIf checked the Diffuse get darker edges accordingly to the inverse of the fresnel that is toned by the specular and light intensity.">true</Attribute>
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name="SpecularColor"					PrettyName="Specular Color"						Group="Specular"				Type="color" 		Description="">(1,1,1,1)</Attribute>
	<Attribute Name="SpecularWeight"				PrettyName="Specular Weight"					Group="Specular"				Type="double"		Description="The Specular weight is multiplied by the Specular map"	Min="0" Max="1">0.0</Attribute>
	<Attribute Name="SpecularRoughness" 			PrettyName="Specular Roughness"					Group="Specular"				Type="double" 		Description="Controls the glossiness of the specular reflections.\nThe lower the value, the sharper the reflection.\nIn the limit, a value of 0 will give you a perfectly sharp mirror reflection,\nwhilst 1.0 will create reflections that are close to a diffuse reflection." Min="0" Max="1">0.467</Attribute>
	<Attribute Name="Anisotropy" 					PrettyName="Anisotropy"							Group="Specular"				Type="double"  		Description="Available when the Specular BRDF is set to Ward duer.\nThe default value for Anisotropy is 0.5, which means 'isotropic'.\nAs you move this control towards 0.0, the surface is made more anisotropic in the U axis,\nand as you move the control towards 1.0 the surface is made more anisotropic in the the V axis." Min="0" Max="1">0.5</Attribute>
	<Attribute Name="Rotation" 						PrettyName="Rotation"							Group="Specular"				Type="double"  		Description="The rotation value changes the orientation of the anisotropic reflectance in UV space.\nAt 0.0, there is no rotation, while at 1.0 the effect is rotated by 180 degrees.\nFor a surface of brushed metal, this controls the angle at which the material was brushed." Min="0" Max="1">0.0</Attribute>
	<Attribute Name="Fresnel_On"					PrettyName="Fresnel" 							Group="Specular"				Type="bool"			Description="When checked, the reflection level will be dependent on the viewing angle of the surface following the Fresnel equations using the Reflectance at Normal slider.">false</Attribute>
	<Attribute Name="Reflectance" 					PrettyName="Reflectance at Normal"				Group="Specular"				Type="double" 		Description="The Fresnel effect is more noticeable when using lower values. Increasing this value gives the material a more metallic-like specular reflection.\nMetals have a more uniform reflectance across all angles compared to plastics or dielectrics, which have very little normal reflectance." Min="0" Max="1">0.0</Attribute>
    <!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name="ReflectionColor"				PrettyName="Reflection Color"					Group="Reflection"				Type="color" 		Description="">(1,1,1,1)</Attribute>
	<Attribute Name="ReflectionWeight"				PrettyName="Reflection Weight"					Group="Reflection"				Type="double"		Description="The contribution from reflection rays (the amount of light that the surface reflects).\nReflectivity does not sample light sources (direct light)." Min="0" Max="1">0.0</Attribute>
	<Attribute Name="Fresnel_On_Ref"				PrettyName="Fresnel" 							Group="Reflection"				Type="bool"			Description="Enables or disables the Fresnel effect.">false</Attribute>
	<Attribute Name="Reflectance_Ref"				PrettyName="Reflectance at Normal"				Group="Reflection"				Type="double" 		Description="The Fresnel effect is more noticeable when using lower values.\nIncreasing this value gives the material a more metallic-like specular reflection.\nMetals have a more uniform reflectance across all angles compared to plastics or dielectrics, which have very little normal reflectance." Min="0" Max="1">0.0</Attribute>
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name="RefractionColor"				PrettyName="Refraction Color"					Group="Refraction"				Type="color" 		Description="">(1,1,1,1)</Attribute>
	<Attribute Name="RefractionWeight"				PrettyName="Refraction Weight"					Group="Refraction"				Type="double" 		Description="The Refraction weight is multiplied by the Refraction map.\n*Note, Refraction is not displayed correctly in the OrthoView, and it's not fully supported in Mari."	Min="0" Max="1">0.0</Attribute>
	<Attribute Name="IOR"							PrettyName="Index of Refraction"				Group="Refraction"				Type="double" 		Description="The index of refraction used.\nThe default value of 1.0 is the refractive index of a vacuum, i.e.,\nan object with IOR of 1.0 in empty space will not refract any rays.\nIn simple terms, 1.0 means 'no refraction'."	Min="1.0" Max="3.0">1.0</Attribute>
	<Attribute Name="RefractionRoughness"		 	PrettyName="Refraction Roughness"				Group="Refraction"				Type="double" 		Description="Controls the blurriness of a refraction.\nThe range goes from 0 clean(no roughness),\nto a very frosty material at value 1."	Min="0" Max="1">0.0</Attribute>
	<Attribute Name="Fresnel_useIOR"				PrettyName="Fresnel use IOR" 					Group="Refraction"				Type="bool"	 		Description="Calculates Fresnel reflectance based on the IOR parameter, ignoring the Reflectance at Normal slider.">false</Attribute>
	<Attribute Name="Transmittance"					PrettyName="Transmittance"						Group="Refraction"				Type="color" 		Description="">(1,1,1,1)</Attribute>
	<Attribute Name="Opacity"						PrettyName="Opacity"							Group="Refraction"				Type="color" 		Description="">(1,1,1,1)</Attribute>
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name="SSSColor"     					PrettyName="Sub-Surface Scattering Color"		Group="Sub-Surface Scattering"	Type="color" 		Description="">(1,1,1,1)</Attribute>
	<Attribute Name="SSSWeight" 					PrettyName="Sub-Surface Scattering Weight"		Group="Sub-Surface Scattering"	Type="double"		Description="The amount of sub-surface scattering. Multiplies SSS Color.\nSub-surface scattering is useful for rendering materials like wax, skin and milk."	Min="0" Max="1">0.0</Attribute>
	<Attribute Name="SSSRadius"     				PrettyName="Sub-Surface Scattering Radius"		Group="Sub-Surface Scattering"	Type="color" 		Description="">(0.1,0.1,0.1,1)</Attribute>
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name="EmissionColor"					PrettyName="Emission Color"						Group="Emission"				Type="color" 		Description="">(1,1,1,1)</Attribute>
	<Attribute Name="Emission"						PrettyName="Emission Scale"						Group="Emission" 				Type="double"		Description="Gives the appearance that the material is emitting incandescent light accordingly to your emission map." Min="0" Max="1">0.0</Attribute>
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name=""								PrettyName="" 									Group="Bump" 					Type="" 			Description="This is used just for hold the Bump Group in a more  appropriate place in the attributes list. This feature not allow you to update Mari Shader on fly in case of you change something here. If you wants to update reload the files from Shader Console and assign a new shader for you geometry to see the updates made on this Shader."></Attribute>
	<Attribute Name=""								PrettyName="" 									Group="Displacement" 			Type="" 			Description="This is used just for hold the Displacement Group in a more appropriate place in the attributes list. This feature not allow you to update Mari Shader on fly in case of you change something here. If you wants to update reload the files from Shader Console and assign a new shader for you geometry to see the updates made on this Shader"></Attribute>
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name="Light_Falloff"					PrettyName="Light Falloff"						Group="'Display Features'" 		Type="stringlist"	Description="Add falloff to Mari's Point Lights. In Arnold Lights 'Constant' means no decay,\n'Quadratic' is proportional to the square of the distance from the light. This is the normal behavior of light in real world.">Constant,Constant,Quadratic</Attribute>		
	<Attribute Name="Decay_Rate" 					PrettyName="Decay Rate"							Group="'Display Features'"		Type="double"		Description="Control the rate of the Light Falloff."	Min="0.01" Max="1.0">1.0</Attribute>
	<Attribute Name="AmbientOcclusion"				PrettyName="Ambient Occlusion Amount"			Group="'Display Features'"		Type="double"		Description="Control the amount of Ambient Occlusion.\n*Note that you still have to calculate the Ambient Occlusion feature under menu Objects -> Ambient Occlusion."	Min="0.0" Max="1.0">1.0</Attribute>
	<Attribute Name="Render_Passes"					PrettyName="AOVs"								Group="'Display Features'" 		Type="stringlist"	Description="Shows the contribution of each element separately, Diffuse, Specular, Reflection, Refraction, Sub-Surface Scattering, Emission,\nor a preview for an average result of the Object Thickness, from dark to light values for thin objects.\nIn Flat Lighting Mode the Render Pass will only display the texture related to the selected pass.\nIn Basic lighting mode it will display texture multiplied by the attribute slider.\nIn Full Shaded lighting mode it will display the end result of all the calculations behind that pass.">Beauty,Beauty,Diffuse,Specular,Reflection,Refraction,SSS,Emission,Thickness Map Preview</Attribute>
	<Attribute Name="Solid"							PrettyName="Thick Glass effect emulation" 		Group="'Display Features'" 		Type="bool"			Description="This is a try to emulate the look in Mari of a Thick/Solid Glass.\nIf not checked it consider the object as a simple slice of glass.\nMari Refraction display some glitches in the Ortho viewport.">false</Attribute>		
  </Attributes>
  <Groups>	
	<Group Name="Refraction"				Expanded="false"></Group>
	<Group Name="Sub-Surface Scattering"	Expanded="false"></Group>	
	<Group Name="Emission"					Expanded="false"></Group>  
	<Group Name="Bump"						Expanded="false"></Group>
	<Group Name="Displacement"				Expanded="false"></Group>
    <Group Name="'Display Features'"		Expanded="false"></Group>
  </Groups>
  <Tags>
    <Tag>_notcacheable</Tag>
	<Tag>_standalone</Tag>
  </Tags>
    <Contexts>
		<Context Type="NodeGraphView">
            <Inputs>
				<Input Name="View_Current_Channel" Tags='_hidden'><Pos>0,0</Pos></Input>                
				<Input Name="DiffuseColor"><Pos>-430,0</Pos></Input>
				<Input Name="DiffuseRoughness"><Pos>-400,-30</Pos></Input>				
				<Input Name="SpecularColor"><Pos>-370,-60</Pos></Input>
				<Input Name="SpecularRoughness"><Pos>-340,-90</Pos></Input>				
				<Input Name="Anisotropy"><Pos>-310,-120</Pos></Input>
				<Input Name="Rotation"><Pos>-280,-150</Pos></Input>
				<Input Name="Reflectance"><Pos>-200,-180</Pos></Input>	
				<Input Name="ReflectionColor"><Pos>-150,-210</Pos></Input>
				<Input Name="Reflectance_Ref"><Pos>-90,-240</Pos></Input>		
				<Input Name="RefractionColor"><Pos>-30,-270</Pos></Input>
				<Input Name="RefractionRoughness"><Pos>75,-270</Pos></Input>
				<Input Name="Transmittance"><Pos>120,-240</Pos></Input>				
				<Input Name="Opacity"><Pos>150,-210</Pos></Input>				
				<Input Name="SSSColor"><Pos>210,-180</Pos></Input>
				<Input Name="SSSRadius"><Pos>240,-150</Pos></Input>				
				<Input Name="EmissionColor"><Pos>270,-120</Pos></Input>				
				<Input Name="Bump"><Pos>300,-90</Pos></Input>
				<Input Name="Normal"><Pos>300,-60</Pos></Input>
				<Input Name="Displacement"><Pos>300,-30</Pos></Input>				
				<Input Name="Vector"><Pos>300,0</Pos></Input>
				<Input Name="ThicknessMap"><Pos>0,-100</Pos></Input>	
            </Inputs>
        </Context>
        <Context Type="GLSL">
            <Shader ShaderType='Fragment'>
                <Inputs>
                    <Input Name="DiffuseColor"><Default>vec4($DiffuseColor.rgb,-1)</Default></Input>
                    <Input Name="DiffuseRoughness"><Default>vec4($DiffuseRoughness)</Default></Input>
					<Input Name="SpecularColor"><Default>vec4($SpecularColor.rgb,-1)</Default></Input>
                    <Input Name="SpecularRoughness"><Default>vec4($SpecularRoughness)</Default></Input>
					<Input Name="Anisotropy"><Default>vec4($Anisotropy)</Default></Input>
					<Input Name="Rotation"><Default>vec4($Rotation)</Default></Input>
					<Input Name="Reflectance"><Default>vec4($Reflectance)</Default></Input>
					<Input Name="ReflectionColor"><Default>vec4($ReflectionColor.rgb,-1)</Default></Input>
					<Input Name="Reflectance_Ref"><Default>vec4($Reflectance_Ref)</Default></Input>					
					<Input Name="RefractionColor"><Default>vec4($RefractionColor.rgb,-1)</Default></Input>
                    <Input Name="RefractionRoughness"><Default>vec4($RefractionRoughness)</Default></Input>
					<Input Name="Transmittance"><Default>vec4($Transmittance.rgb,-1)</Default></Input>	
					<Input Name="Opacity"><Default>vec4($Opacity.rgb,0)</Default></Input>
					<Input Name="SSSColor"><Default>vec4($SSSColor.rgb,-1)</Default></Input>
					<Input Name="SSSRadius"><Default>vec4($SSSRadius.rgb,-1)</Default></Input>
					<Input Name="EmissionColor"><Default>vec4($EmissionColor.rgb,-1)</Default></Input>
					<Input Name="Bump"><Default>vec4(0.5,0.5,0.5,1)</Default></Input>
                    <Input Name="Normal"><Default>vec4(0,0,1,1)</Default></Input>
					<Input Name="Displacement"><Default>vec4(0.5,0.5,0.5,1)</Default></Input>					
					<Input Name="Vector"><Default>vec4(State.TangentInEyeSpaceFromProjectionCamera.xyz,1)</Default></Input>
					<Input Name="ThicknessMap"><Default>vec4(0.5,0.5,0.5,0.0)</Default></Input>
				</Inputs>
				<Body><![CDATA[
	$shadingNode; // Used for continually Mark what shader you are using in case you have renamed the name of the shader inside Mari. This var is also used for the exporter to identify what shader he is picking.
	
	$DiffuseColor;
	$DiffuseRoughness;
	$SpecularColor;
	$SpecularRoughness;
	$Anisotropy;
	$Rotation;
	$Reflectance;
	$ReflectionColor;
	$Reflectance_Ref;
	$RefractionColor;
	$RefractionRoughness;
	$Transmittance;
	$Opacity;
	$SSSColor;
	$SSSRadius;
	$EmissionColor;	
	
	// These control/input pairs are alpha blended together.
	// If the Channel has an input connected the input is used.	
	// Else the attribute slider is used instead.
	// VAR Name   			 'mix' based on existence of an alpha in the channels	
	vec3 difCol	   			= mix( vec3(0),		#DiffuseColor.rgb,		#DiffuseColor.a 		== 0 ? 0 : 1);
	vec3 specCol  			= mix( vec3(0),		#SpecularColor.rgb,		#SpecularColor.a 		== 0 ? 0 : 1);
	vec3 reflCol  			= mix( vec3(0),		#ReflectionColor.rgb,	#ReflectionColor.a 		== 0 ? 0 : 1);
	vec3 refrCol  			= mix( vec3(0),		#RefractionColor.rgb,	#RefractionColor.a 		== 0 ? 0 : 1);
	vec3 transCol 			= mix( vec3(0),		#Transmittance.rgb,		#Transmittance.a 		== 0 ? 0 : 1);
	vec3 sssCol	   			= mix( vec3(0),		#SSSColor.rgb, 			#SSSColor.a				== 0 ? 0 : 1);
	vec3 sssRadius 			= mix( vec3(0), 	#SSSRadius.rgb, 		#SSSRadius.a 			== 0 ? 0 : 1);
	vec3 emisCol   			= mix( vec3(0),		#EmissionColor.rgb,	 	#EmissionColor.a		== 0 ? 0 : 1);
		
	float difrough 	 		= mix( float(0),	#DiffuseRoughness.r,	#DiffuseRoughness.a 	== 0 ? 0 : 1);
	float specrough 		= mix( float(0),	#SpecularRoughness.r,	#SpecularRoughness.a 	== 0 ? 0 : 1);
	float ani				= mix( float(0),	#Anisotropy.r,			#Anisotropy.a 			== 0 ? 0 : 1);
	float rot 		 		= mix( float(0),	#Rotation.r,			#Rotation.a 			== 0 ? 0 : 1);
	float specReflectance   = mix( float(0),	#Reflectance.r,			#Reflectance.a 			== 0 ? 0 : 1);
	float refReflectance	= mix( float(0),	#Reflectance_Ref.r,		#Reflectance_Ref.a 		== 0 ? 0 : 1);
	float refrarough		= mix( float(0),	#RefractionRoughness.r,	#RefractionRoughness.a 	== 0 ? 0 : 1);
		
	vec3 Current_Channel_Selected = #View_Current_Channel.rgb;
		
	// Check if there's Color painted at the rgb of the Opacity Channels	
	vec3 opacityCol	 = vec3(0,0,0);
	if (color_toValue(#Opacity.rgb) == 0)
	{
		opacityCol = vec3(1.0) - $Opacity.rgb;
	}
	else
	{
		opacityCol = vec3(1.0) - #Opacity.rgb;	
	}	
	
	// The UV Viewport will display what is the Current Channel Selected, unless you don't have any channel. Then it will display the Mari`s alpha checkerboard pattern.	
	if(u_MriViewType==2 || u_MriLightingMode==0)
	{
		// This is the cheapest way to use this "viewbuffer" feature, skipping most of the shader calculation.
		
		Output = #View_Current_Channel;		
		
		if($Render_Passes == 1)
		{
			Output.rgb = difCol.rgb;
		}
		if($Render_Passes == 2)
		{
			Output.rgb = specCol.rgb;
		}
		if($Render_Passes == 3)
		{
			Output.rgb = reflCol.rgb;
		}
		if($Render_Passes == 4)
		{
			Output.rgb = refrCol.rgb;
		}
		if($Render_Passes == 5)
		{
			Output.rgb = sssCol.rgb;
		}
		if($Render_Passes == 6)
		{
			Output.rgb = emisCol.rgb;
		}
		if($Render_Passes == 7)
		{
			Output = #ThicknessMap;
		}
		
		//Display the Thickness imported image in the UV Viewport
		if(u_MriViewType==2 && $Render_Passes == 7) 
		{
			Output = #ThicknessMap;			
		}		
	}
	else
	{
		// ------------  All the shader math ------------
		
		const float PI = 3.14159265358979323846264;
		const float TwoPI = 2.0 * PI;
			
		// View Direction
		vec3 V = normalize(-State.ViewVectorInEyeSpaceFromViewCamera);
		// Normal Direction
		vec3 N = normalize(#Normal.xyz);
			
		float NdotV = dot(N,V);
		// On the wrong side of the face
		if( NdotV <= 0.0)
		{
			N = -N;
			NdotV = 1.0 - NdotV;
		}
				
			
		// Calculates the Space diagonal of the volume inside a cube
		vec3 viewPos = vec3(1.0);
		viewPos.x = mix(1, 2*abs(State.Position.x), abs(State.NormalInEyeSpaceFromViewCamera.x) );
		viewPos.y = mix(1, 2*abs(State.Position.y), abs(State.NormalInEyeSpaceFromViewCamera.y) );
		viewPos.z = mix(1, 2*abs(State.Position.z), abs(State.NormalInEyeSpaceFromViewCamera.z) );
		float base_diagonal = sqrt(viewPos.x*viewPos.x+viewPos.z*viewPos.z);
		float space_diagonal = sqrt(base_diagonal*base_diagonal + viewPos.y*viewPos.y);
			
		// Check if there is a texture assigned to the #ThicknessMap attribute, if does, then use it instead of the 1.5 value. 
		float Thickness = 1.5;	
		if(#ThicknessMap.a > 0)	
		{
			Thickness = 1.0 + #ThicknessMap.r;		
		}
		
		//Use the Baked texture to mix with the multiplication factors of the "Voxelized calculation method" based on depth of the scene
		if(u_MriViewType == 0) //gl buffer does not work well in perspective mode
		{
			//thickness based on position calculation mixed with obj radius
			vec3 P = State.Position*u_MriObjectRadius;
			float d = -dot(State.Position,P);
			float D = abs(d)/length(P);
			D /=u_MriObjectRadius;             
			
			Thickness *= mix( mix(2, 1, 1-NdotV)*u_MriObjectRadius, space_diagonal, (1-NdotV)*length(D));	
		}
		else
		{
			//thickness based on depth and obj radius
			float mult_factor = mix(2*u_MriObjectRadius, u_MriObjectRadius/2, gl_FragDepth);
			//thickness adjusment for the depth based on the Space diagonal of a cube created for each pixel on face.
			float mult_factor2 = mix( mix(space_diagonal, 1, (gl_FragDepth*(1-NdotV))), mix(u_MriObjectRadius, 1, (2*abs(gl_FragDepth - 0.5))*(1-NdotV)), 2*abs(gl_FragDepth - 0.5) )*PI; // this PI is just a adjusment to the color values between the two viewports
			
			Thickness *= mix(mult_factor, mult_factor2, gl_FragDepth);
		}	
		
				
		// Roughness attributes squared
		float difrough2 = difrough*difrough;		
		float specrough2 = specrough*specrough*specrough*specrough; // Arnold use a quadratic specrough for cook-torrance only(their wish was to use cubic, but that's expensive they say).	
		float refrarough2 = refrarough*refrarough*refrarough*refrarough;
		
		float _glossiness = 1.0;
		float _Refra_glossiness = 1.0;
		float _ani = 2*(0.5-ani); // internal variable to be used as anisotropy for the maths, this changes the anisotropy value to the range -1 and 1 that is used by V-ray and is correct for obtain the correct result from the BRDF Formula.
		
		
		// IBL Glossiness adaptation to match the BRDF blur or 'spec lobe' for Environment Lighting
		_glossiness = mix(pow( 1-sqrt(specrough2), 2), pow( 1-(specrough), 3), 1-specrough);
		_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
		
		if(_ani == 0.0 || specrough2 == 0.0) // There is no Anisotropy if the Specular Roughness = 0
		{
			_glossiness = pow( mix( 1-specrough2, 1-sqrt(specrough2), 1-specrough), mix(2, 3, 1-specrough) );
			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
		}
		else
		{				  
			_glossiness = pow( mix( (abs(_ani)/PI+1-sqrt(specrough2))/2, (abs(_ani)+1-sqrt(specrough2))/2, 1-specrough), mix(1, (abs(_ani)+1-sqrt(specrough2))*1.5, 1-specrough) );
			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
		}
		
		// Fresnel var initialization	
		float F = 1.0;
		if($Fresnel_On)
		{
			F = 0.0;
		}	
		
		// Anisotropic coords
		vec3 epsilon = vec3(0, 1, 0.15);
		vec3 X = vec3(1,0,0);
		vec3 Y = vec3(0,1,0);
		if(#Vector.a != 1.0)
		{
			X.x = #Vector.r;
			Y.y = #Vector.g;
		}
		if(ani != 0.5)
		{		
			epsilon = rot < 0.5 ? mix(Y, X, 2*rot) : mix(X, -Y, 2*(rot-0.5) );		
		}
				
		Y = normalize(cross(N, epsilon));
		X = normalize(cross(N, Y));
		

		// Energy variables initialization for each phase of the light calculation
		vec3 EnergyDiffuse = vec3(0.0);
		vec3 EnergyDiffuse_env = vec3(0.0); //avoid diffuse light bounces from lights to the obj
		vec3 EnergyBacklight = vec3(0.0);
		vec3 EnergyBacklight_env = vec3(0.0);
		vec3 EnergySpecular = vec3(0.0); //also separete the energy from highlights and reflection(point lights and environment light) also avoids lights bouncees from shader to the direct light sourcers the point lights.
		vec3 EnergySpecular_env = vec3(0.0); // keeps specular reflection/highlights from environment and from lights separately from calculation
		vec3 EnergyReflection_env = vec3(0.0);
		vec3 EnergyRefraction_env = vec3(0.0);
		vec3 EnergyTransmittance = vec3(1.0);
		vec3 EnergySSS = vec3(0.0);
		vec3 EnergySSS_env = vec3(0.0); //avoid SSS light bounces from lights to the obj
		vec3 EnergyOpacity_env = vec3(0.0);
		
		vec3 LightColour = vec3(0.0);
		float diffterm = 0.0;
		float specterm = 0.0;
		float refraterm = 0.0;
		vec3 _Absorbance = vec3 (1.0);
		
		
		
		for(int i=0;i<4;i++)
		{
			if( vec3( 0) == u_MriLightSources[i].DiffuseColor.rgb && vec3( 0) == u_MriLightSources[i].SpecularColor.rgb)
			{
				continue;
			}

			float lightVisibility = mriLightVisibility( i, State.Position);		
			
			// Light Direction			
			vec3 L = normalize(u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera);
			vec3 LdistP = u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera;	
			
			// Half Vector
			vec3 H = normalize(L+V);		
			
			float LdotN = dot(L,N);		
			{			
				// ----------DIFFUSE TERM-----------
				// Oren-Nayar Diffuse Result from the Light Sources
				diffterm = 1.25*mriBRDF_Oren_Nayar(N, V, L, difrough2);
				EnergyDiffuse  += (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * (diffterm) * att(LdistP, $Light_Falloff, $Decay_Rate);
				
				// Check-box Calculate Fresnel to Diffuse
				if($DiffuseFresnel == true)
				{			
					// Calculate fresnel attenuation for the Diffuse, using the specReflectance at normal or the $IOR attributes.		
					if($Fresnel_On)
					{
						if($Fresnel_useIOR == true)
						{
							F = mriBRDF_Fresnel(L, H, $IOR);
							// *FIX Light Occlusion/Shadow Issue*
							float F0 = (1 - $IOR)/(1 + $IOR);	
							F0 = F0*F0;
							F = mix(F*(1-NdotV), F, F0);
						}
						else
						{						
							F = mriBRDF_Fresnel_Schlicks(L, H, specReflectance);
							// *FIX Light Occlusion/Shadow Issue*
							F = mix(F*(1-NdotV), F, specReflectance);
						}
						// Energy Conservation from Specular (Lights Sources)	
						EnergyDiffuse *= 1.0 - F * color_toValue(specCol.rgb)*$SpecularWeight;						
					}
				}	
				
				// ----------Sub-Surface Scattering TERM-----------            
				float LdotN = dot(L,N);
				float LdotH = dot(L,H);
				
				float FL = mriBRDF_SchlickFresnel(LdotN);
				float FV = mriBRDF_SchlickFresnel(NdotV);			
							
				LightColour = (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * att(LdistP, $Light_Falloff, $Decay_Rate);
					
				// creates a bit of a fake impression of difusion
				vec3 mixSSSdifusion = vec3(0.0);
				for (int j=0;j<3;j++)
				{			
					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), 1-sssRadius.rgb[j] );
				}
				vec3 Back_Scat_Color = 1.25*mixSSSdifusion*mixSSSdifusion;
				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;
				
				EnergySSS += Back_Scat_Color;
							
				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
				if($DiffuseFresnel == true)
				{
					// The same fresnel attenuation that affects the diffuse above.
					if($Fresnel_On)
					{
						// Energy Conservation from Specular (Lights Sources)
						EnergySSS *= 1.0 - F * color_toValue(specCol.rgb)*$SpecularWeight;														
					}
				}			
				
				// ----------BACKLIGHT TERM-----------
				if( LdotN <= 0.0)
				{
					if($Backlight > 0.0)
					{					
						diffterm = mriBRDF_Oren_Nayar(N, V, -L, difrough2);
						EnergyBacklight += ( u_MriLightSources[i].DiffuseColor.rgb) * diffterm * $Backlight *att(LdistP, $Light_Falloff, $Decay_Rate)/PI;
						
						// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
						if($DiffuseFresnel == true)
						{
							if($Fresnel_On)
							{
								if($Fresnel_useIOR == true)
								{
									F = mriBRDF_Fresnel(-L, -H, $IOR);	
									// *FIX Light Occlusion/Shadow Issue*
									float F0 = (1 - $IOR)/(1 + $IOR);	
									F0 = F0*F0;
									F = mix(F*(1-NdotV), F, F0);						
								}
								else
								{
									F = mriBRDF_Fresnel_Schlicks(-L, -H, specReflectance);
									// *FIX Light Occlusion/Shadow Issue*
									F = mix(F*(1-NdotV), F, specReflectance);				
								}
								// Energy Conservation from Specular (Lights Sources)
								// ----------BACKLIGHT TERM-----------
								EnergyBacklight *= 1.0 - min(PI * F * max(0.0, dot(-L,N)) * color_toValue(specCol.rgb)*$SpecularWeight, 1.0);						
							}
						}	
					}
					else
					{
						continue;
					}	
				}			
				
				// ----------SPECULAR TERM-----------
				// Moved to here so would Avoid shadow issues in the Diffuse and SSS Calculation and will prevent future issues in the Specular Calculation.
				if( LdotN > 0.0)
				{				
					// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR
					if($Fresnel_On)
					{
						if($Fresnel_useIOR == true)
						{
							F = mriBRDF_Fresnel(L, H, $IOR);
						}
						else
						{
							F = mriBRDF_Fresnel_Schlicks(L, H, specReflectance);
						}						
					}	
										
					//BRDF Model Cook-Torrance
					// Cook-Torrance Specular Result
					specterm = mriBRDF_Beckman(N, H, max(specrough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(specrough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
					
					
					// In the last versions of Arnold The BRDF models get unified into a single one!
					//BRDF Model WARD or Cook-Torrance with Anisotropy	
					if(abs(_ani) != 0.0) 
					{							
						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
						if(specrough2 == 0.0)
						{
							specterm = mriBRDF_Ward(N, V, L, H, X, Y, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
						}
						else
						{						
							// Isotropy specular assumes that ani = 0
							specterm = mriBRDF_Ward(N, V, L, H, X, Y, _ani, 0.99-specrough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
						}					
					}						
					EnergySpecular += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm) * att(LdistP, $Light_Falloff, $Decay_Rate);			
				}
			}		
		}
		
		
		if( true == mriEnvironmentLightOn())
		{
			{
				// ----------DIFFUSE TERM-----------
				// Env Light, Light Direction
				vec3 L = N;
				LightColour = mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 0.0);
				// This mix(PI, 2.5, difrough2) would preserve albedo.	
				EnergyDiffuse_env = mix(PI, 2.5, difrough2)*mriBRDF_Oren_Nayar(N, V, L, difrough2) * LightColour;            		
				
				// Check-box Calculate Fresnel to Diffuse 
				if($DiffuseFresnel == true)
				{
					// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
					if($Fresnel_On)
					{
						// Reassigning light direction for calculate the fresnel accordingly to specular maths.
						L = normalize( -reflect( V, N));
						// Half Vector
						vec3 H = normalize(L+V);					
						if($Fresnel_useIOR == true)
						{
							F = mriBRDF_Fresnel(L, H, $IOR);						
						}
						else
						{						
							F = mriBRDF_Fresnel_Schlicks(L, H, specReflectance);						
						}
						// Energy Conservation from Specular (Environment)					
						EnergyDiffuse_env *= 1.0 - F * color_toValue(specCol.rgb)*$SpecularWeight;					
						
						if($Fresnel_On_Ref)
						{
							if($Fresnel_useIOR == true)
							{
								F = F; // picks from the math above, since this would be a value that comes from a global attribute for the entire fresnels math.
							}
							else
							{
								F = mriBRDF_Fresnel_Schlicks(L, H, refReflectance);							
							}					
						}
						// Energy Conservation from Reflection (Environment)	
						EnergyDiffuse_env *= 1.0 - F * color_toValue(reflCol.rgb)*$ReflectionWeight;					
					}
				}			
			}
			
			{
				// ----------BACKLIGHT TERM-----------
				// Env Light, Light Direction
				// Backlight	
				vec3 L = normalize( -refract(V, -N*State.FragmentPositionInEyeSpaceFromViewCamera, 1.0) );				
				
				float lightVisibility = 1.0;			
				
				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);	
				
				EnergyBacklight_env += mix(vec3(0), LightColour, $Backlight)*mriBRDF_Oren_Nayar(N, V, N, difrough2);
				EnergyBacklight_env /= 1+difrough2/PI;
				
				if($DiffuseFresnel == true)
				{
					// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
					if($Fresnel_On)
					{
						// Reassigning light direction for calculate the fresnel accordingly to specular maths.
						L = normalize( -reflect( V, N));
						// Half Vector
						vec3 H = normalize(L+V);					
						if($Fresnel_useIOR == true)
						{
							F = mriBRDF_Fresnel(L, H, $IOR);						
						}
						else
						{						
							F = mriBRDF_Fresnel_Schlicks(L, H, specReflectance);						
						}
						// Energy Conservation from Specular (Environment)					
						EnergyBacklight_env *= 1.0 - F * color_toValue(specCol.rgb)*$SpecularWeight;					
							
						if($Fresnel_On_Ref)
						{
							if($Fresnel_useIOR == true)
							{
								F = F; // picks from the math above, since this would be a value that comes from a global attribute for the entire fresnels math.
							}
							else
							{
								F = mriBRDF_Fresnel_Schlicks(L, H, refReflectance);							
							}					
						}
						// Energy Conservation from Reflection (Environment)	
						EnergyBacklight_env *= 1.0 - F * color_toValue(reflCol.rgb)*$ReflectionWeight;					
					}
				}	
			}	

			{
				// ----------SPECULAR TERM-----------
				// Env Specular Reflection, Light Direction			
				vec3 L = normalize( -reflect( V, N));
				// Half Vector
				vec3 H = normalize(L+V);          			
				
				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR
				if($Fresnel_On)
				{
					if($Fresnel_useIOR == true)
					{
						F = mriBRDF_Fresnel(L, H, $IOR);
					}
					else
					{
						F = mriBRDF_Fresnel_Schlicks(L, H, specReflectance);
					}					
				}				
				
				float LdotN = dot(L,N);
				if( 0.0 < LdotN)
				{
					float lightVisibility = 1.0;
					LightColour = vec3(0.0);				

					//BRDF Model Cook-Torrance
					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
					// Cook-Torrance Specular Result from Environment
					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-specrough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
					
					// In the last versions of Arnold The BRDF models get unified into a single one!
					//BRDF Model WARD or Cook-Torrance with Anisotropy	
					if(abs(_ani) != 0) 
					{									
						// Isotropy reflection
						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
							
						// Anisotropy reflection	
						if(_ani != 0.0 && specrough2 != 0)
						{
							// Caculate how much isotropy is the material based on roughness and anisotropy values.
							float _isotropy = abs(_ani)*(1.1-specrough2);	
							
							LightColour = vec3(0.0);
							float i = 0;
							for (;i < _isotropy;)
							{
							
							// Define the direction of the anisotropy
							vec3 L1 = normalize( reflect( V, _ani < 0? X:Y ));
								
							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L1, L, 1-i), clamp(_glossiness + abs(_ani*_ani)*(1.0-specrough2)/9, .1, .9) );							
							i += 0.1;
							}
							LightColour /= i*10;												
						}		
						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-specrough), 0.0, 1.0 );					
					}
					EnergySpecular_env += specterm * (LightColour);		
				
			
					// ----------REFLECTION TERM-----------
					// Reset the fresnel value, and keep the L direction from the specular above.
					F = 1.0;
					if($Fresnel_On_Ref)
					{
						if($Fresnel_useIOR == true)
						{
							F = mriBRDF_Fresnel(L, H, $IOR);
						}
						else
						{
							F = mriBRDF_Fresnel_Schlicks(L, H, refReflectance);
						}					
					}
					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
					EnergyReflection_env += F * (LightColour);
				}	
			}		
				
			{
				// ----------REFRACTION TERM-----------
				// Env Refraction, Light Direction			
				// Refraction incoming direction
				vec3 Li = vec3(0.0);
				if($Solid)
				{
					Li = normalize( -refract(V, -N, (1.0/$IOR)) );
				}
				else
				{
					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, (1.0/$IOR)) );
				}
				
				float lightVisibility = 1.0;
				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, _Refra_glossiness);		
				
				EnergyRefraction_env += (LightColour);		
							
				_Absorbance = transCol.rgb;
				if (_Absorbance != vec3(1.0) )
				{			
					_Absorbance = pow_RGB(transCol.rgb, Thickness/10);
					EnergyTransmittance = _Absorbance;
				}
				
				// *TWEAK* This will preserve some energy from the reflection that is actually passing through the surface and not been reflected by the fresnel.
				if($Fresnel_On)
				{
					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
					vec3 L = normalize( -reflect( V, N));
					float LdotN = dot(L,N);
					// Half Vector
					vec3 H = normalize(L+V);					
					if($Fresnel_useIOR == true)
					{
						F = mriBRDF_Fresnel(L, H, $IOR);					
					}
					else
					{						
						F = mriBRDF_Fresnel_Schlicks(L, H, specReflectance);					
					}						
					EnergyRefraction_env *=  1.0 - F * color_toValue(specCol.rgb)*$SpecularWeight;			
					
					if($Fresnel_On_Ref)
					{
						if($Fresnel_useIOR == true)
						{
							F = F; // picks from the math above, since this would be a value that comes from a global attribute for the entire fresnels math.
						}
						else
						{
							F = mriBRDF_Fresnel_Schlicks(L, H, refReflectance);					
						}					
					}
					EnergyRefraction_env *= 1.0 - F * color_toValue(reflCol.rgb)*$ReflectionWeight;				
				}		
			}	

			{
				// ----------Sub-Surface Scattering TERM-----------
				// Env Light, Light Direction
				// Sub-Surface Scattering	
				vec3 L = N;				
				// Half Vector
				vec3 H = normalize(L+V);			
				
				float LdotN = dot(L,N);
				float LdotH = dot(L,H);
				
				float FL = mriBRDF_SchlickFresnel(LdotN);
				float FV = mriBRDF_SchlickFresnel(NdotV);			
					
				float lightVisibility = 1.0;
				
				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);
				
				// creates a bit of a fake impression of difusion
				vec3 mixSSSdifusion = vec3(0.0);
				for (int j=0;j<3;j++)
				{			
					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), sssRadius.rgb[j] );
				}
				vec3 Back_Scat_Color = 1.25*mixSSSdifusion;
				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;						
				
				EnergySSS_env += Back_Scat_Color;
				
				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
				if($DiffuseFresnel == true)
				{
					// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
					if($Fresnel_On)
					{
						// Reassigning light direction for calculate the fresnel accordingly to specular maths.
						L = normalize( -reflect( V, N));
						// Half Vector
						vec3 H = normalize(L+V);					
						if($Fresnel_useIOR == true)
						{
							F = mriBRDF_Fresnel(L, H, $IOR);						
						}
						else
						{						
							F = mriBRDF_Fresnel_Schlicks(L, H, specReflectance);						
						}						
						EnergySSS_env *= 1.0 - F * color_toValue(specCol.rgb)*$SpecularWeight;					
						
						if($Fresnel_On_Ref)
						{
							if($Fresnel_useIOR == true)
							{
								F = F; // picks from the math above, since this would be a value that comes from a global attribute for the entire fresnels math.
							}
							else
							{
								F = mriBRDF_Fresnel_Schlicks(L, H, refReflectance);							
							}					
						}
						EnergySSS_env *= 1.0 - F * color_toValue(reflCol.rgb)*$ReflectionWeight;					
					}
				}				
			}
			
			{
				// ----------OPACITY TERM-----------
				// Env Opacity, Light Direction			
				// Opacity incoming direction
				// It should look like a Ghost with inverted colors!
				vec3 Li = vec3(0.0);
				if($Solid)
				{
					Li = normalize( -refract(V, -N, 1.0) );
				}
				else
				{
					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, 1.0) );
				}
				float lightVisibility = 1.0;
				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, 1.0);		
				EnergyOpacity_env += LightColour;				
			}
		}	
		
		// AO option
		float _AO = 1.0 - $AmbientOcclusion * State.AmbientOcclusion;
		
		// Keep in mind that Arnold does not restrict the artists with a builtin Energy Conservation! So you have some artists freedom to break the rules as you wish.
		vec3 Kd = (EnergyDiffuse+EnergyBacklight + EnergyDiffuse_env+EnergyBacklight_env) * difCol.rgb * $DiffuseWeight * _AO;
		vec3 Ks = (EnergySpecular + EnergySpecular_env) * specCol.rgb * $SpecularWeight * _AO;	
		vec3 Kr = EnergyReflection_env * reflCol.rgb * $ReflectionWeight * _AO;
		vec3 Kt = EnergyRefraction_env * EnergyTransmittance * refrCol.rgb * $RefractionWeight * _AO;
		vec3 Ksss = (EnergySSS + EnergySSS_env) * $SSSWeight * sssCol.rgb * _AO;	
		vec3 Opa = EnergyOpacity_env * opacityCol.rgb;
		
		// New Mari Lighting Mode workflow.
		// Lighting Mode => 0 - "Flat" - only display the Current Channel that is selected.
		// Lighting Mode =>	1 - Basic - Display Diffuse + Sub-surface Scattering
		// Lighting Mode => 2 - Full - Adds the specular/reflection + refraction + self-illumination on top of what the Basic mode displays
		Output.rgb = u_MriLightingMode==0 ? Current_Channel_Selected.rgb : Kd+Ksss;
		Output.rgb += u_MriLightingMode!=2 ? vec3(0.0) : Ks+Kr+Kt;
			
		// Emission
		Output.rgb += u_MriLightingMode==2 ? $Emission * emisCol.rgb : vec3(0.0);

		// Opacity
		Output.rgb = u_MriLightingMode==2 ? mix(Opa.rgb, Output.rgb, 1.0-color_toValue(opacityCol.rgb)) : Output.rgb;
				
		// If displaying "flat" lighting mode 0 use the Current Channel alpha.
		Output.a = u_MriLightingMode==0 ? #View_Current_Channel.a : 1.0;		
		
		
		// Render Passes Mode, the beauty pass = 0 doesn't need an if statement, it has coded above and displayed by default
		// Lighting Mode == 1 ? #Channel * $Weight : #Channel * $ChannelWeight * Lighting Contribution
		if($Render_Passes == 1)
		{
			Output.rgb = (u_MriLightingMode==1 ? difCol.rgb * $DiffuseWeight : Kd);
		}
		if($Render_Passes == 2)
		{
			Output.rgb = (u_MriLightingMode==1 ? specCol.rgb * $SpecularWeight : Ks);
		}
		if($Render_Passes == 3)
		{
			Output.rgb = (u_MriLightingMode==1 ? reflCol.rgb * $ReflectionWeight : Kr);
		}
		if($Render_Passes == 4)
		{
			Output.rgb = (u_MriLightingMode==1 ? refrCol.rgb * $RefractionWeight : Kt);
		}
		if($Render_Passes == 5)
		{
			Output.rgb = (u_MriLightingMode==1 ? sssCol.rgb * $SSSWeight : Ksss);
		}
		if($Render_Passes == 6)
		{
			Output.rgb = emisCol.rgb * $Emission;
		}
		if($Render_Passes == 7)
		{
			Output.rgb = vec3(1.0/Thickness);			
		}	
	}
		
	            ]]></Body>
            </Shader>
        </Context>
    </Contexts>
</Node>