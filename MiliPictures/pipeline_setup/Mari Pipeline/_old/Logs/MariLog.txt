Debug : [                 mriapplog.cpp:386 ] : Writing log to: C:\Users\kai.xu\Documents/Mari/Logs/MariLog.txt
Debug : [                 mriapplog.cpp:388 ] : Started up at 13:51:49 on ???? ??? 28 2016
Debug : [            mriapplication.cpp:1361] : Mari was started with no extra arguments
Debug : [            mriapplication.cpp:221 ] : Mari working directory is: C:/Users/kai.xu/Documents/Mari/Logs
Debug : [            mriapplication.cpp:229 ] : Mari build information
Debug : [            mriapplication.cpp:230 ] : 	Build date        : '2015-11-06T15:47:36'
Debug : [            mriapplication.cpp:231 ] : 	Revision hash     : 'b07c242a57e1317d0de7cd8c3c709a23d8e1556e' (from '2015-11-06 12:17:18 +0000')
Debug : [            mriapplication.cpp:232 ] : 	Build version     : '3.0v1'
Debug : [            mriapplication.cpp:233 ] : 	Product stage     : ''
Debug : [            mriapplication.cpp:466 ] : System information:
Debug : [            mriapplication.cpp:766 ] : 	'Microsoft Windows 7 Ultimate Edition Service Pack 1 (build 7601) 64-bit'
Debug : [            mriapplication.cpp:426 ] : 	CPU Vendor Name   : 'GenuineIntel'
Debug : [            mriapplication.cpp:427 ] : 	Stepping Id       : 7
Debug : [            mriapplication.cpp:428 ] : 	Model             : 13
Debug : [            mriapplication.cpp:429 ] : 	Family            : 6
Debug : [            mriapplication.cpp:433 ] : 	CPU Model Name    : '       Intel(R) Xeon(R) CPU E5-2620 0 @ 2.00GHz'
Debug : [            mriapplication.cpp:439 ] : 	Cache Line Size   : 64
Debug : [            mriapplication.cpp:440 ] : 	L2 Associativity  : 6
Debug : [            mriapplication.cpp:441 ] : 	Cache Size        : 256K
Debug : [            mriapplication.cpp:1686] : Loading Preferences, Thread Count is 12
Debug : [      mriglobaleventfilter.cpp:40  ] : [ FOUND ] Windows 'USER Object' limit : 10000
Debug : [          mripluginmanager.cpp:332 ] : [ Found Plugin Path ] C:/Program Files/Mari3.0v1/Bundle/plugins
Warning : Cannot Load Plugin [ C:/Program Files/Mari3.0v1/Bundle/plugins/MriOpenCL.dll ] (Cannot load library C:/Program Files/Mari3.0v1/Bundle/plugins/MriOpenCL.dll: ???????????????)
Debug : [mrisnglslcodegeneratormanager.cpp:107 ] : Register GLSL Code Generator 'MriSnGlslCodeGenerator_Style1'
Debug : [mrisnglslcodegeneratormanager.cpp:107 ] : Register GLSL Code Generator 'MriSnGlslCodeGenerator_Style2'
Debug : [mrisnglslcodegeneratormanager.cpp:107 ] : Register GLSL Code Generator 'MriSnGlslCodeGenerator_Style3'
Debug : [             mricacheroots.cpp:506 ] : Checking conflicts on project locations specified in user settings
Debug : [             mricacheroots.cpp:554 ] : Using the following project locations specified by user settings: D:/Mari
Debug : [             mricacheroots.cpp:721 ] : D:/Mari Seems to be readable
Debug : [             mricacheroots.cpp:738 ] : This check is only performed on Linux systems
Debug : [             mricacheroots.cpp:784 ] : [ OK ] Filesystem is of a recommended type
Debug : [DDI] Max data cache size    = 6428975104 bytes (6131 MB)
Debug : [DDI] Max write pending size = 1607243776 bytes (1532 MB)
Debug : [DDI] Target Free Memory = 536870912 bytes (512 MB)
Debug : Created Hash Manager in thread 0x22821c0
Debug : [            mriapplication.cpp:1016] : Enabling Request Promotion
Debug : MriDDi Setting Request Promotion Enabled to TRUE 1
Debug : [                mrimainapp.cpp:602 ] : [ OK ] Initialized Ddi
Debug : [                              :   0] : License Obtained
Debug : [                mrimainapp.cpp:683 ] : Licensed as Full Version
Debug : [        mrifilehashchecker.cpp:189 ] : File hash checker stats: 620 files checked, 0 missing files -> checksum is valid
Debug : [             mrimainwindow.cpp:617 ] : Starting Main Window
Debug : [             mrimainwindow.cpp:600 ] : Registered .pdf shell open command is '"C:\Program Files (x86)\Adobe\Reader 11.0\Reader\AcroRd32.exe" "%1"'
Debug : [    mriactionsourcemanager.cpp:98  ] : [ OK ] Registered source for type Mari/MriAction
Debug : [DDI] Max data cache size    = 6428976128 bytes (6131 MB)
Debug : [DDI] Max write pending size = 1607244032 bytes (1532 MB)
Debug : [DDI] Target Free Memory = 536870912 bytes (512 MB)
Debug : [         mriprojectmanager.cpp:1104] : Creating Collection Patches
Debug : [            mrimenumanager.cpp:947 ] : Cannot Find Sub Menu MainWindow/&View/&Palettes
Debug : [         mriprojectmanager.cpp:1104] : Creating Collection Objects
Debug : [         mriprojectmanager.cpp:1104] : Creating Collection Lights
Debug : [         mriprojectmanager.cpp:1104] : Creating Collection Projectors
Debug : [         mriprojectmanager.cpp:1104] : Creating Collection Selection Groups
Debug : [    mriactionsourcemanager.cpp:98  ] : [ OK ] Registered source for type Mari/MriTool
Debug : [              mrihistogram.cpp:50  ] : [ OK ] Made Histogram
Debug : [    mriactionsourcemanager.cpp:98  ] : [ OK ] Registered source for type Mari/MriColor
Debug : [    mriactionsourcemanager.cpp:98  ] : [ OK ] Registered source for type Mari/MriImagePath
Warning : Object::connect: No such slot MriImageManagerView::currentTabChanged(int)
Debug : [                    mrigpu.cpp:1851] : ==============================================================
Debug : [                    mrigpu.cpp:1852] : Made Gpu
Debug : [                    mrigpu.cpp:1853] : ==============================================================
Debug : [                    mrigpu.cpp:1863] : [ OK ] Resource Tracking Disabled
Debug : [                    mrigpu.cpp:1481] : [ OK ] GL_NV_texture_barrier
Debug : [                    mrigpu.cpp:1487] : [ OK ] GL_ARB_texture_cube_map_array
Debug : [                    mrigpu.cpp:1497] : [ OK ] GL_ARB_seamless_cube_map
Debug : [                    mrigpu.cpp:1503] : [ OK ] GL_AMD_seamless_cubemap_per_texture
Debug : [                    mrigpu.cpp:1515] : [ OK ] GL_EXT_texture_filter_anisotropic 16.000000
Debug : [                    mrigpu.cpp:1581] : Unnamed Uniforms  v4096(233472) g2048(231424) f2048(231424)
Debug : [                    mrigpu.cpp:1597] : Named Uniform Blocks: 64KB 84@(v14 g14 f14)
Debug : [                    mrigpu.cpp:1615] : Line Width 1 (1-1)@0
Debug : [                    mrigpu.cpp:1657] : Max Memory Size: 2048 MB
Debug : [                    mrigpu.cpp:1699] : Max SubRoutines 1024 Locations 1024
Debug : [                    mrigpu.cpp:1771] : Compressed Formats 23
Debug : [                    mrigpu.cpp:4035] : Checking nvoglv32.dll for GPU driver version.
Debug : [                    mrigpu.cpp:4076] : LoadLibrary error code: 126
Debug : [                    mrigpu.cpp:4035] : Checking nvoglv64.dll for GPU driver version.
Debug : [                    mrigpu.cpp:4053] : NVIDIA OpenGL DLL 'C:\Windows\system32\nvoglv64.DLL', version 9.18.13.3788
Debug : [                    mrigpu.cpp:4369] : =========================================
Debug : [                    mrigpu.cpp:4370] : OpenGL Vendor            : 'NVIDIA Corporation'
Debug : [                    mrigpu.cpp:4371] : OpenGL Renderer          : 'GeForce GTX 660/PCIe/SSE2'
Debug : [                    mrigpu.cpp:4372] : OpenGL Version           : '3.2.0 DRIVER 9.18.13.3788'
Debug : [                    mrigpu.cpp:4373] : OpenGL Shading Language  : '1.50 NVIDIA via Cg compiler'
Debug : [                    mrigpu.cpp:4374] : =========================================
Debug : [                    mrigpu.cpp:4473] : Showing GPU Untested Dialog
Debug : [                    mrigpu.cpp:4619] : [ OK ] Occlusion Query 32 bits
Debug : [                    mrigpu.cpp:310 ] : [ OK ] Glew initialized
Debug : [                    mrigpu.cpp:1984] : [ OK ] Initialized Default GPU Font
Debug : [             mrisvtmanager.cpp:1055] : Atlas Found QSize
Debug : [             mrisvtmanager.cpp:1072] : Atlas Paint Bake Found QSize
Debug : [            mrisvtatlasmap.cpp:297 ] : SVT Enable Orphan Cleanup Disabled
Debug : [            mrisvtatlasmap.cpp:458 ] : SVT Atlas is now 8192x8192 (RGBA)
Debug : [            mrisvtatlasmap.cpp:321 ] : Created Atlas Texture : 129
Debug : [                mrialembic.cpp:18  ] : [ Plugin ] Alembic Loader/Saver
Debug : [                mribrushes.cpp:65  ] : [ Plugin ] Brushes
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [    mriactionsourcemanager.cpp:98  ] : [ OK ] Registered source for type Mari/MriBrush
Debug : [    mricamerapluginhandler.cpp:20  ] : [ Plugin ] MriCameraPluginHandler
Debug : [         mrichannelactions.cpp:315 ] : [ Plugin ] Channel Actions
Debug : [mrichanneloperationmanager.cpp:52  ] : Registered channel action class 'MriAddMultipleChannelsOperation'
Debug : [mrichanneloperationmanager.cpp:52  ] : Registered channel action class 'MriImportOperation'
Debug : [mrichanneloperationmanager.cpp:52  ] : Registered channel action class 'MriExportOperation'
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Color
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Constant
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Base Color Catalogue
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Channel/Channel Height
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Channel/Channel Color
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Add
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Subtract
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Multiply
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Divide
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Abs
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Position
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Surface Normal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Tangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Bitangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UV
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UDIM Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UV Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Ambient Occlusion
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Selection Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Displacement
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Displacement Simple
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Tessellation Clip To Screen
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Tessellation To Pixels
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Perturb Point
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Perturb Surface
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/Bottom Transparency
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/Merge
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/MergeNoAlpha
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Brightness
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Brightness Lookup
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Balance
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Contrast
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Flow
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Invert
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Log To Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Linear To Log
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Luminosity
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Clamp
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Lookup
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Switch
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Copy Channel
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color To Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Set Value
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Gamma
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/HSL
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/HSV
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Hue Shift
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Saturation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Levels
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Grade
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/sRGB2Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Premultiply Alpha
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Scale
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Shuffle
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Height As Normal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Tangent To Screen
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Tangent To World
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/World To Tangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Falloff Curve
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Cook Torrance
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Beckman
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Phong
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Blinn
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Flat
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/BRDF
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Standard Lighting
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/AiStandard
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/VRayMtl
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/RedshiftArchitectural
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Unreal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Layered/Layered
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Diffuse/Lambertian
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Diffuse/Minnaert
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Tangent Space To Eye Space
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Normal Modulation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Lighting Result Modulation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Color To Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Cube Map
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Sphere Map
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Cube Map Projector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Sphere Map Projector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Tri Planar Projection
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Environment Light
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Tiled
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/UV Grid
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Sphere
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Cube
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Object Space Linear Gradient
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/UV Linear Gradient
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Perlin
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Cellular
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Squiggle
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Fractal/Cloud
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Fractal/Turbulence
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Plant/Wood
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Misc/Oil
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Animation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Output
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Viewer
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Cross Bar 2
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Channel Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Channel Bake
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Current Layer
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Shuffle Copy
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Custom
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Empty
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Set Unlit
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Set Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/EmptyWithSkip
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Current Paint Target
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Shader Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Face Test
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Group
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Backdrop
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/StickyNote
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Dot
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/IBL
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Shader
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export &Everything 0
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export Current Object 0
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export &All Channels 0
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export Current &Channel 0
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export All Masks 0
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export Selected Masks 0
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export Current Mask 0
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export Everything &Flattened 0
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export Current Object Flattened 0
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export &All Channels Flattened 0
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export Current &Channel Flattened 0
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export &All Layers Flattened 0
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export &Selected Layers Flattened 0
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export Current Mask Flattened 0
Debug : [   mricollectionviewplugin.cpp:25  ] : [ Plugin ] Collection Views
Debug : [     mricolorpickersplugin.cpp:37  ] : [ Plugin ] MriColorPickersPlugin
Debug : [            mriopencolorio.cpp:358 ] : Found OCIO configs: {aces, iif, nuke-default, spi-anim, spi-vfx}
[OpenColorIO Info]: Color management disabled. (Specify the $OCIO environment variable to enable.)
Debug : [                    mridds.cpp:23  ] : [ Plugin ] DDS
Debug : [          mridisplayplugin.cpp:21  ] : [ Plugin ] DisplayPluginHandler
Debug : [          mrientityactions.cpp:24  ] : [ Plugin ] Entity Actions 
Debug : [                    mrifbx.cpp:21  ] : [ Plugin ] Fbx Loader
Debug : [           mrifileprotocol.cpp:34  ] : [ Plugin ] File Protocol
Debug : [          mrifiltersplugin.cpp:85  ] : [ Plugin ] MriFiltersPlugin
Debug : [mrigeometryoperationplugin.cpp:20  ] : [ Plugin ] GeometryOperationPluginHandler
Debug : [              mrigeomtools.cpp:726 ] : [ Plugin ] Geometry Tools
Debug : [mrigeometryselectionactionfamily.cpp:60  ] : [ Plugin ] Geometry Selection Group Actions
Debug : [     mricanvasactionfamily.cpp:63  ] : [ Plugin ] Canvas Actions
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [            mrianimcontrol.cpp:385 ] : Playing No
Debug : [       mrigeopluginhandler.cpp:25  ] : [ Plugin ] MriGeoPluginHandler
Debug : [     mriglcontroletsplugin.cpp:23  ] : [ Plugin ] GL Controlets
Debug : [       mriguiactionsplugin.cpp:29  ] : [ Plugin ] GUI Actions
Debug : [   mriimageoperationplugin.cpp:20  ] : [ Plugin ] ImageOperationPluginHandler
Debug : [     mriimagepluginhandler.cpp:25  ] : [ Plugin ] MriImagePluginHandler
Debug : [             mriimageutils.cpp:33  ] : [ Plugin ] Initialising Image Tools
Debug : [        mrilightingactions.cpp:26  ] : [ Plugin ] Lighting Actions
Debug : [                   mrimisc.cpp:713 ] : [ Plugin ] Misc. Actions
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 7 more times
Debug : [              mriobjloader.cpp:22  ] : [ Plugin ] Obj Loader
Debug : [                   mrioiio.cpp:21  ] : [ Plugin ] OpenImageIO
Debug : [                mriopenexr.cpp:24  ] : [ Plugin ] OpenExr
Debug : [       mriopensubdivplugin.cpp:23  ] : [ Plugin ] OpenSubdiv
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 1 more time
Debug : [        mripaintingactions.cpp:34  ] : [ Plugin ] Painting Actions
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 2 more times
Debug : [                 mripartio.cpp:409 ] : [ Plugin ] Partio
Debug : [          mriscriptmanager.cpp:85  ] : [ OK ] Script manager initialised
Debug : [           mriscriptserver.cpp:46  ] : [ OK ] Created script server port 6100 (disabled)
Debug : [           mripatchactions.cpp:77  ] : [ Plugin ] Patch Actions
Debug : [   mriprojectactionsplugin.cpp:54  ] : [ Plugin ] Project Actions
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [      mriprojectionactions.cpp:25  ] : [ Plugin ] Projection Actions
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 11 more times
Debug : [        mriprojectionmasks.cpp:27  ] : [ Plugin ] Projection Masks
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 2 more times
Debug : [       mriprojectoractions.cpp:46  ] : [ Plugin ] Projector Actions
Debug : [                    mripsd.cpp:21  ] : [ Plugin ] Psd Support
Debug : [  mripyscriptmanagerplugin.cpp:33  ] : [ Plugin ] MriPyScriptManager
Debug : [        mripyscriptmanager.cpp:108 ] : [ Python ] Initialising Python 2.7.3 script manager
Debug : [        mripyscriptmanager.cpp:713 ] : [ Python ] Libraries are in C:/Program Files/Mari3.0v1/Bundle/bin/lib
Debug : [          mriscriptconsole.cpp:222 ] : [ -- ] Initialising console font to (family:'Courier New', style:'Normal')
Debug : [        mripyscriptmanager.cpp:124 ] : [ Python ] Script manager basic init completed successfully
Debug : [                 mriqimage.cpp:21  ] : [ Plugin ] QImage
Debug : [          mrishaderactions.cpp:34  ] : [ Plugin ] Shader Actions
Debug : [mrishadernetworkglslcontextplugin.cpp:18  ] : [ Plugin ] Shader Network - GLSL Context
Debug : [mrishadernetworklayerviewcontextplugin.cpp:22  ] : [ Plugin ] Shader Network - Layer View Context
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 55 more times
Debug : [          mriactionhelpers.cpp:171 ] : Could Not find!!!MainWindow &Layers Add Procedural Layer Basic
Debug : [          mriactionhelpers.cpp:171 ] : Could Not find!!!MainWindow &Layers Add Procedural Layer Environment
Debug : [          mriactionhelpers.cpp:171 ] : Could Not find!!!MainWindow &Layers Add Procedural Layer Geometry
Debug : [          mriactionhelpers.cpp:171 ] : Could Not find!!!MainWindow &Layers Add Procedural Layer Procedural
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 1
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 2
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [              mrilayerview.cpp:567 ] : pLayerStack is NULL
Debug : [              mrilayerview.cpp:567 ] : pLayerStack is NULL
Warning : QWidget::insertAction: Attempt to insert null action
Debug : [mrishadernetworknodegraphviewcontextplugin.cpp:18  ] : [ Plugin ] Shader Network - Node Graph View Context
Debug : [mrisnnodegraphviewcontextmanager.cpp:55  ] : [ On ] Node Graph (Advanced : 'Off')
Debug : [       mritexttexgenplugin.cpp:26  ] : [ Plugin ] MriTextTexGen
Debug : [          mritexgenmanager.cpp:61  ] : [ OK ] Registered Generator Text
Debug : [   mritexturepluginhandler.cpp:21  ] : [ Plugin ] MriTexturePluginHandler
Debug : [                  mritools.cpp:60  ] : [ Plugin ] Initialising Tools
Debug : [        mrishortcutmanager.cpp:163 ] : Failed to load shortcut '' for action 'Mari/Channels/Next Channel' due to '0'
Debug : [        mrishortcutmanager.cpp:163 ] : Failed to load shortcut '' for action 'Mari/Channels/Previous Channel' due to '0'
Debug : [  mrigeonavigationcontrols.cpp:69  ] : [ Plugin ] Geometry Navigation Controls
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 3 more times
Debug : [            mrigesturetool.cpp:106 ] : [ OK] Register Toggle Brush Gesture
Debug : [            mrigesturetool.cpp:187 ] : [ OK ] Added Toggle Action
Debug : [                   mriptex.cpp:57  ] : [ Plugin ] Ptex Support
Debug : [mrichanneloperationmanager.cpp:52  ] : Registered channel action class 'MriExportPtexLayerOperation'
Debug : [mrichanneloperationmanager.cpp:52  ] : Registered channel action class 'MriCreatePtexImageSetOperation'
Debug : [      mriuserpluginmanager.cpp:284 ] : [ -- ] Mari CAPI Plugin : Found 2 official Mari capi plugins in 'C:/Program Files/Mari3.0v1/Bundle/capiplugins'
Debug : [      mriuserpluginmanager.cpp:160 ] : [ User Plugin ] Checking library 'C:/Program Files/Mari3.0v1/Bundle/capiplugins/MriExampleModoPreviewPlugin.dll'
Debug : [      mriuserpluginmanager.cpp:203 ] : [ User Plugin ] Found 'Example Modo Preview : Display Render Plugin' v1.0: supports 'MriDisplayRender' v1000
Debug : [              MriDisplayRender:1000] : Connected to host 'Mari' version '3.0v1' (30001300)
Debug : [        mrihostsuiteprovider.h:87  ] : [ User Plugin ] Registering MriDisplayRender v1000 plugin
Debug : [      mriuserpluginmanager.cpp:331 ] : [ -- ] Loaded plugin 'C:/Program Files/Mari3.0v1/Bundle/capiplugins/MriExampleModoPreviewPlugin.dll'
Debug : [      mriuserpluginmanager.cpp:160 ] : [ User Plugin ] Checking library 'C:/Program Files/Mari3.0v1/Bundle/capiplugins/MriExampleObjExporterPlugin.dll'
Debug : [      mriuserpluginmanager.cpp:203 ] : [ User Plugin ] Found 'Example Obj Exporter : Geometry Operation Plugin' v1.0: supports 'MriUserGeometryOperationPlugin' v1001
Debug : [MriUserGeometryOperationPlugin:1001] : Connected to host 'Mari' version '3.0v1' (30001300)
Debug : [        mrihostsuiteprovider.h:87  ] : [ User Plugin ] Registering MriUserGeometryOperationPlugin v1001 plugin
Debug : [    mrifilehostsuiteprovider.h:75  ] : [ User Plugin ] Plugin supports extension '.obj' (Export geometry mesh info to an Obj file)
Debug : [      mriuserpluginmanager.cpp:203 ] : [ User Plugin ] Found 'Example Obj Exporter : Geometry Access Plugin' v1.0: supports 'MriGeometryAccessPlugin' v1001
Debug : [       MriGeometryAccessPlugin:1001] : Connected to host 'Mari' version '3.0v1' (30001300)
Debug : [        mrihostsuiteprovider.h:87  ] : [ User Plugin ] Registering MriGeometryAccessPlugin v1001 plugin
Debug : [      mriuserpluginmanager.cpp:331 ] : [ -- ] Loaded plugin 'C:/Program Files/Mari3.0v1/Bundle/capiplugins/MriExampleObjExporterPlugin.dll'
Debug : [      mriuserpluginmanager.cpp:296 ] : [ -- ] User Plugin Paths (rearranged Back to Front) are : 'C:\Users\kai.xu\Documents/Mari/Plugins'
Debug : [                    mrigpu.cpp:4911] : [ OK ] Set Default Buffer to 16 Bit RGBA
Debug : [           mribrushmanager.cpp:289 ] : [ OK ] Loaded Brush Blur.mbr
Debug : [           mribrushmanager.cpp:289 ] : [ OK ] Loaded Brush CloneStamp.mbr
Debug : [           mribrushmanager.cpp:289 ] : [ OK ] Loaded Brush Eraser.mbr
Debug : [           mribrushmanager.cpp:289 ] : [ OK ] Loaded Brush Gradient.mbr
Debug : [           mribrushmanager.cpp:289 ] : [ OK ] Loaded Brush Paint.mbr
Debug : [           mribrushmanager.cpp:289 ] : [ OK ] Loaded Brush PaintThrough.mbr
Debug : [           mribrushmanager.cpp:289 ] : [ OK ] Loaded Brush VectorPaint.mbr
Debug : [                mripainter.cpp:651 ] : [ OK ] Painter Initialized
Debug : [            mrimenumanager.cpp:674 ] : MriMenuManager::makeMenuBar() -- Set is MainWindow
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 3
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 4
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 5
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 6
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 7
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 8
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 9
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 10
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 11
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 12
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 13
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 14
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 15
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 16
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 17
Debug : [             mrimainwindow.cpp:1464] : Bar Locked
Debug : [             mrimainwindow.cpp:882 ] : ===============
Debug : [             mrimainwindow.cpp:883 ] : Welcome To Mari
Debug : [             mrimainwindow.cpp:884 ] : ===============
Debug : [       mristaticinfogather.cpp:350 ] : Error posting info -1 'Could not establish connection to server. Please check Internet connection settings or contact support@thefoundry.co.uk.' 'CURL error: (7) Couldn't connect to server
'
Debug : [              mri1dfilelut.cpp:166 ] : [ OK ] Loaded Lut File ExampleLut.lut
Debug : [       mrifiltercollection.cpp:262 ] : Cannot create object of type MriGLSLFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......Displacement
Debug : [       mrifiltercollection.cpp:265 ] : ......Gaussian Blur
Debug : [       mrifiltercollection.cpp:265 ] : ......Height
Debug : [       mrifiltercollection.cpp:265 ] : ......Mri1dFileLut
Debug : [       mrifiltercollection.cpp:265 ] : ......Mri1dSplineLut
Debug : [       mrifiltercollection.cpp:265 ] : ......MriActionCollection
Debug : [       mrifiltercollection.cpp:265 ] : ......MriBasicImporter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriBlurBrush
Debug : [       mrifiltercollection.cpp:265 ] : ......MriBlurFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriBrightnessLut
Debug : [       mrifiltercollection.cpp:265 ] : ......MriChannel
Debug : [       mrifiltercollection.cpp:265 ] : ......MriChannelLite
Debug : [       mrifiltercollection.cpp:265 ] : ......MriChannelPresetsWidget
Debug : [       mrifiltercollection.cpp:265 ] : ......MriChannelSnapshot
Debug : [       mrifiltercollection.cpp:265 ] : ......MriClampFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriCloneStamp
Debug : [       mrifiltercollection.cpp:265 ] : ......MriColorManagerStatus
Debug : [       mrifiltercollection.cpp:265 ] : ......MriContrastFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriCopyChannel
Debug : [       mrifiltercollection.cpp:265 ] : ......MriDilate
Debug : [       mrifiltercollection.cpp:265 ] : ......MriEdgeDetect
Debug : [       mrifiltercollection.cpp:265 ] : ......MriEmboss
Debug : [       mrifiltercollection.cpp:265 ] : ......MriEntity
Debug : [       mrifiltercollection.cpp:265 ] : ......MriEnvLight
Debug : [       mrifiltercollection.cpp:265 ] : ......MriFilterCollectionFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriFragmentModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriFragmentShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGammaFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGaussian
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGaussian1D
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeoCamera
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeoEntity
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeoLight
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeometryModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeometryShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGradientMatte
Debug : [       mrifiltercollection.cpp:265 ] : ......MriHighPassFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriHueShiftFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriImageLite
Debug : [       mrifiltercollection.cpp:265 ] : ......MriInvertFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLevels
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLinToLogFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLocatorEntity
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLogToLinFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLuminosityFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPaintThroughMatte
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPremultiplyAlphaFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPreviewableSnapshot
Debug : [       mrifiltercollection.cpp:265 ] : ......MriProjector
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPropertyProxy
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPtexContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriQObjectFreeOpImp
Debug : [       mrifiltercollection.cpp:265 ] : ......MriRenderMatte
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSRGB2Linear
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShaderModuleInstance
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShaderNetwork
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShaderNetworkSnapshot
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShaderNetworkSnapshotObject
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShadingContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSharpen
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnBaseGlslContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnBaseNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnChannelBakeNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnChannelInputNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnCustomNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGlslChannelBakeContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGlslChannelInputContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGlslIBLContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGroupGlslContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGroupNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGroupNodeGraphViewContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnIBLNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnNodeGraphViewContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnShaderInputNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnStandardContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnUINode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnUINodeGraphViewContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnapshot
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSoften
Debug : [       mrifiltercollection.cpp:265 ] : ......MriStandardBrushGeometry
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSurfaceShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSvtShadingContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSwitchLut
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTessellationControlModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTessellationControlShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTessellationEvaluationModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTessellationEvaluationShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTextureBrushMatte
Debug : [       mrifiltercollection.cpp:265 ] : ......MriThreadedChannelImporter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriToneMapping
Debug : [       mrifiltercollection.cpp:265 ] : ......MriUdimIndexCalculator
Debug : [       mrifiltercollection.cpp:265 ] : ......MriUvPatch
Debug : [       mrifiltercollection.cpp:265 ] : ......MriVertexModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriVertexShader
Debug : [       mrifiltercollection.cpp:262 ] : Cannot create object of type MriGLSLFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......Displacement
Debug : [       mrifiltercollection.cpp:265 ] : ......Gaussian Blur
Debug : [       mrifiltercollection.cpp:265 ] : ......Height
Debug : [       mrifiltercollection.cpp:265 ] : ......Mri1dFileLut
Debug : [       mrifiltercollection.cpp:265 ] : ......Mri1dSplineLut
Debug : [       mrifiltercollection.cpp:265 ] : ......MriActionCollection
Debug : [       mrifiltercollection.cpp:265 ] : ......MriBasicImporter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriBlurBrush
Debug : [       mrifiltercollection.cpp:265 ] : ......MriBlurFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriBrightnessLut
Debug : [       mrifiltercollection.cpp:265 ] : ......MriChannel
Debug : [       mrifiltercollection.cpp:265 ] : ......MriChannelLite
Debug : [       mrifiltercollection.cpp:265 ] : ......MriChannelPresetsWidget
Debug : [       mrifiltercollection.cpp:265 ] : ......MriChannelSnapshot
Debug : [       mrifiltercollection.cpp:265 ] : ......MriClampFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriCloneStamp
Debug : [       mrifiltercollection.cpp:265 ] : ......MriColorManagerStatus
Debug : [       mrifiltercollection.cpp:265 ] : ......MriContrastFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriCopyChannel
Debug : [       mrifiltercollection.cpp:265 ] : ......MriDilate
Debug : [       mrifiltercollection.cpp:265 ] : ......MriEdgeDetect
Debug : [       mrifiltercollection.cpp:265 ] : ......MriEmboss
Debug : [       mrifiltercollection.cpp:265 ] : ......MriEntity
Debug : [       mrifiltercollection.cpp:265 ] : ......MriEnvLight
Debug : [       mrifiltercollection.cpp:265 ] : ......MriFilterCollectionFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriFragmentModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriFragmentShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGammaFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGaussian
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGaussian1D
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeoCamera
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeoEntity
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeoLight
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeometryModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeometryShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGradientMatte
Debug : [       mrifiltercollection.cpp:265 ] : ......MriHighPassFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriHueShiftFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriImageLite
Debug : [       mrifiltercollection.cpp:265 ] : ......MriInvertFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLevels
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLinToLogFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLocatorEntity
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLogToLinFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLuminosityFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPaintThroughMatte
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPremultiplyAlphaFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPreviewableSnapshot
Debug : [       mrifiltercollection.cpp:265 ] : ......MriProjector
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPropertyProxy
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPtexContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriQObjectFreeOpImp
Debug : [       mrifiltercollection.cpp:265 ] : ......MriRenderMatte
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSRGB2Linear
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShaderModuleInstance
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShaderNetwork
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShaderNetworkSnapshot
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShaderNetworkSnapshotObject
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShadingContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSharpen
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnBaseGlslContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnBaseNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnChannelBakeNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnChannelInputNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnCustomNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGlslChannelBakeContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGlslChannelInputContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGlslIBLContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGroupGlslContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGroupNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGroupNodeGraphViewContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnIBLNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnNodeGraphViewContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnShaderInputNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnStandardContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnUINode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnUINodeGraphViewContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnapshot
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSoften
Debug : [       mrifiltercollection.cpp:265 ] : ......MriStandardBrushGeometry
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSurfaceShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSvtShadingContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSwitchLut
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTessellationControlModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTessellationControlShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTessellationEvaluationModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTessellationEvaluationShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTextureBrushMatte
Debug : [       mrifiltercollection.cpp:265 ] : ......MriThreadedChannelImporter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriToneMapping
Debug : [       mrifiltercollection.cpp:265 ] : ......MriUdimIndexCalculator
Debug : [       mrifiltercollection.cpp:265 ] : ......MriUvPatch
Debug : [       mrifiltercollection.cpp:265 ] : ......MriVertexModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriVertexShader
Debug : [       mrifiltercollection.cpp:262 ] : Cannot create object of type MriGLSLFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......Displacement
Debug : [       mrifiltercollection.cpp:265 ] : ......Gaussian Blur
Debug : [       mrifiltercollection.cpp:265 ] : ......Height
Debug : [       mrifiltercollection.cpp:265 ] : ......Mri1dFileLut
Debug : [       mrifiltercollection.cpp:265 ] : ......Mri1dSplineLut
Debug : [       mrifiltercollection.cpp:265 ] : ......MriActionCollection
Debug : [       mrifiltercollection.cpp:265 ] : ......MriBasicImporter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriBlurBrush
Debug : [       mrifiltercollection.cpp:265 ] : ......MriBlurFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriBrightnessLut
Debug : [       mrifiltercollection.cpp:265 ] : ......MriChannel
Debug : [       mrifiltercollection.cpp:265 ] : ......MriChannelLite
Debug : [       mrifiltercollection.cpp:265 ] : ......MriChannelPresetsWidget
Debug : [       mrifiltercollection.cpp:265 ] : ......MriChannelSnapshot
Debug : [       mrifiltercollection.cpp:265 ] : ......MriClampFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriCloneStamp
Debug : [       mrifiltercollection.cpp:265 ] : ......MriColorManagerStatus
Debug : [       mrifiltercollection.cpp:265 ] : ......MriContrastFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriCopyChannel
Debug : [       mrifiltercollection.cpp:265 ] : ......MriDilate
Debug : [       mrifiltercollection.cpp:265 ] : ......MriEdgeDetect
Debug : [       mrifiltercollection.cpp:265 ] : ......MriEmboss
Debug : [       mrifiltercollection.cpp:265 ] : ......MriEntity
Debug : [       mrifiltercollection.cpp:265 ] : ......MriEnvLight
Debug : [       mrifiltercollection.cpp:265 ] : ......MriFilterCollectionFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriFragmentModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriFragmentShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGammaFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGaussian
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGaussian1D
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeoCamera
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeoEntity
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeoLight
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeometryModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGeometryShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriGradientMatte
Debug : [       mrifiltercollection.cpp:265 ] : ......MriHighPassFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriHueShiftFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriImageLite
Debug : [       mrifiltercollection.cpp:265 ] : ......MriInvertFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLevels
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLinToLogFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLocatorEntity
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLogToLinFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriLuminosityFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPaintThroughMatte
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPremultiplyAlphaFilter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPreviewableSnapshot
Debug : [       mrifiltercollection.cpp:265 ] : ......MriProjector
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPropertyProxy
Debug : [       mrifiltercollection.cpp:265 ] : ......MriPtexContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriQObjectFreeOpImp
Debug : [       mrifiltercollection.cpp:265 ] : ......MriRenderMatte
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSRGB2Linear
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShaderModuleInstance
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShaderNetwork
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShaderNetworkSnapshot
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShaderNetworkSnapshotObject
Debug : [       mrifiltercollection.cpp:265 ] : ......MriShadingContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSharpen
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnBaseGlslContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnBaseNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnChannelBakeNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnChannelInputNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnCustomNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGlslChannelBakeContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGlslChannelInputContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGlslIBLContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGroupGlslContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGroupNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnGroupNodeGraphViewContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnIBLNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnNodeGraphViewContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnShaderInputNode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnStandardContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnUINode
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnUINodeGraphViewContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSnapshot
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSoften
Debug : [       mrifiltercollection.cpp:265 ] : ......MriStandardBrushGeometry
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSurfaceShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSvtShadingContext
Debug : [       mrifiltercollection.cpp:265 ] : ......MriSwitchLut
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTessellationControlModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTessellationControlShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTessellationEvaluationModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTessellationEvaluationShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriTextureBrushMatte
Debug : [       mrifiltercollection.cpp:265 ] : ......MriThreadedChannelImporter
Debug : [       mrifiltercollection.cpp:265 ] : ......MriToneMapping
Debug : [       mrifiltercollection.cpp:265 ] : ......MriUdimIndexCalculator
Debug : [       mrifiltercollection.cpp:265 ] : ......MriUvPatch
Debug : [       mrifiltercollection.cpp:265 ] : ......MriVertexModularShader
Debug : [       mrifiltercollection.cpp:265 ] : ......MriVertexShader
Debug : [              mri1dfilelut.cpp:166 ] : [ OK ] Loaded Lut File ExampleLut.lut
Debug : [                    mrigpu.cpp:6660] : Texture load: 'C:/Program Files/Mari3.0v1/Bundle/Media/Images/Checkerboard.jpg'
Debug : [                    mrigpu.cpp:6681] : Texture load: 149
Debug : [                mriapiinit.cpp:214 ] : [ OK ] Started registering API
Debug : [                mriapiinit.cpp:321 ] : [ OK ] API registered
Debug : [        mripyscriptmanager.cpp:557 ] : [ Python ] Looking for start-up scripts in: C:/Program Files/Mari3.0v1/Bundle/Media/Scripts
Debug : [        mripyscriptmanager.cpp:588 ] : [ Python ] Running: C:/Program Files/Mari3.0v1/Bundle/Media/Scripts/init.py
Debug : [               application.cpp:430 ] : [ OpenColorIO ] Loaded Python bindings 'C:\Program Files\Mari3.0v1\Bundle\bin\lib\site-packages\PyOpenColorIO.pyd' successfully
Debug : [               application.cpp:430 ] : [ OpenColorIO ] OCIO environment variable: ''
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 18
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 19
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 20
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 21
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 22
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 23
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 24
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 25
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 26
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 27
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 28
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 29
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 30
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 31
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 32
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 33
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 7 more times
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 34
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 35
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 36
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 37
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 38
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 39
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 40
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 41
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 42
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 43
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 44
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 45
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 46
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 47
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 48
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 49
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 50
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 20 more times
Warning : QFileSystemWatcher::removePaths: list is empty
Warning : QFileSystemWatcher::removePaths: list is empty
Debug : [                geomanager.cpp:184 ] : [ API ] General error: No project currently open
Warning : QFileSystemWatcher::removePaths: list is empty
Warning : QFileSystemWatcher::removePaths: list is empty
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 172 more times
Debug : [               application.cpp:430 ] : [ Session ] ==============================================================
Debug : [               application.cpp:430 ] : [ Session ] Loaded Preferences:
Debug : [               application.cpp:430 ] : [ Session ] ==============================================================
Debug : [               application.cpp:430 ] : [ Session ]           Objects Folder: objects
Debug : [               application.cpp:430 ] : [ Session ]            Images Folder: images
Debug : [               application.cpp:430 ] : [ Session ]          Textures Folder: textures
Debug : [               application.cpp:430 ] : [ Session ]        Projectors Folder: projectors
Debug : [               application.cpp:430 ] : [ Session ]   Export Float Image Type: exr
Debug : [               application.cpp:430 ] : [ Session ]   Export Half Image Type: exr
Debug : [               application.cpp:430 ] : [ Session ]   Export Byte Image Type: png
Debug : [               application.cpp:430 ] : [ Session ] ==============================================================
Debug : [               application.cpp:430 ] : [ Session ] ==============================================================
Debug : [               application.cpp:430 ] : [ Session ] Saved Preferences:
Debug : [               application.cpp:430 ] : [ Session ] ==============================================================
Debug : [               application.cpp:430 ] : [ Session ]           Objects Folder: objects
Debug : [               application.cpp:430 ] : [ Session ]            Images Folder: images
Debug : [               application.cpp:430 ] : [ Session ]          Textures Folder: textures
Debug : [               application.cpp:430 ] : [ Session ]        Projectors Folder: projectors
Debug : [               application.cpp:430 ] : [ Session ]   Export Float Image Type: exr
Debug : [               application.cpp:430 ] : [ Session ]   Export Half Image Type: exr
Debug : [               application.cpp:430 ] : [ Session ]   Export Byte Image Type: png
Debug : [               application.cpp:430 ] : [ Session ] ==============================================================
Debug : [             mriactiontree.cpp:248 ] : Action Tree Node Session already has an action called &Export Session
Debug : [             mriactiontree.cpp:1359] : Cannot add action
Debug : [             mriactiontree.cpp:248 ] : Action Tree Node Session already has an action called &Import Session
Debug : [             mriactiontree.cpp:1359] : Cannot add action
Debug : [             mriactiontree.cpp:248 ] : Action Tree Node Session already has an action called Import &Channels
Debug : [             mriactiontree.cpp:1359] : Cannot add action
Debug : [             mriactiontree.cpp:248 ] : Action Tree Node Session already has an action called Import &Shaders
Debug : [             mriactiontree.cpp:1359] : Cannot add action
Debug : [               application.cpp:430 ] : [ Session ] ==============================================================
Debug : [               application.cpp:430 ] : [ Session ] Loaded Preferences:
Debug : [               application.cpp:430 ] : [ Session ] ==============================================================
Debug : [               application.cpp:430 ] : [ Session ]           Objects Folder: objects
Debug : [               application.cpp:430 ] : [ Session ]            Images Folder: images
Debug : [               application.cpp:430 ] : [ Session ]          Textures Folder: textures
Debug : [               application.cpp:430 ] : [ Session ]        Projectors Folder: projectors
Debug : [               application.cpp:430 ] : [ Session ]   Export Float Image Type: exr
Debug : [               application.cpp:430 ] : [ Session ]   Export Half Image Type: exr
Debug : [               application.cpp:430 ] : [ Session ]   Export Byte Image Type: png
Debug : [               application.cpp:430 ] : [ Session ] ==============================================================
Debug : [               application.cpp:430 ] : [ Session ] ==============================================================
Debug : [               application.cpp:430 ] : [ Session ] Saved Preferences:
Debug : [               application.cpp:430 ] : [ Session ] ==============================================================
Debug : [               application.cpp:430 ] : [ Session ]           Objects Folder: objects
Debug : [               application.cpp:430 ] : [ Session ]            Images Folder: images
Debug : [               application.cpp:430 ] : [ Session ]          Textures Folder: textures
Debug : [               application.cpp:430 ] : [ Session ]        Projectors Folder: projectors
Debug : [               application.cpp:430 ] : [ Session ]   Export Float Image Type: exr
Debug : [               application.cpp:430 ] : [ Session ]   Export Half Image Type: exr
Debug : [               application.cpp:430 ] : [ Session ]   Export Byte Image Type: png
Debug : [               application.cpp:430 ] : [ Session ] ==============================================================
Debug : [        mripyscriptmanager.cpp:392 ] : [ Python ] Begin running user start-up scripts
Debug : [        mripyscriptmanager.cpp:557 ] : [ Python ] Looking for start-up scripts in: C:\Users\kai.xu\Documents/Mari/Scripts
Debug : [        mripyscriptmanager.cpp:588 ] : [ Python ] Running: C:\Users\kai.xu\Documents/Mari/Scripts/__init__.py
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 1 more time
Debug : [        mripyscriptmanager.cpp:588 ] : [ Python ] Running: C:\Users\kai.xu\Documents/Mari/Scripts/alSurfaceX_Export.py
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Debug : [             mriactiontree.cpp:307 ] : [ !! ] Found NULL tree node action
Repeat : Message repeating...
Repeat : Last message was repeated 1 more time
Debug : [             mriactiontree.cpp:248 ] : Action Tree Node Scripts already has an action called Mari alSurface for Maya
Debug : [             mriactiontree.cpp:1359] : Cannot add action
Debug : [        mripyscriptmanager.cpp:588 ] : [ Python ] Running: C:\Users\kai.xu\Documents/Mari/Scripts/register_custom_layers.py
Debug : [     mriserializableobject.cpp:1017] : Attribute 'ConvertToGlossiness' already exists!
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node '', input count: 21
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node '', input count: 7
Debug : [          mrishadermanager.cpp:805 ] : Registered custom header file path UUID=ALSURFACEX_GLSLH Path=C:/Users/kai.xu/Documents/Mari/include/alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:850 ] : Registered custom header file path UUID=ALSURFACEX_GLSLC Path=C:/Users/kai.xu/Documents/Mari/Modules/alSurfaceX.glslc
Debug : [        mripyscriptmanager.cpp:427 ] : [ Python ] Finished running start-up scripts
Debug : [         mriprojectmanager.cpp:2417] : [ OK ] Waiting for background shader compilation to complete
Debug : [         mriprojectmanager.cpp:2420] : [ OK ] Close project: flushing background jobs
Debug : [         mriprojectmanager.cpp:2423] : [ OK ] Close project: flushing write threads
Debug : [         mriprojectmanager.cpp:1646] : Begin loading project: 'D:/Mari/026011bb-437d-4dd3-ae5b-20bb7a1b2095/Project.mri'
Debug : [         mriprojectmanager.cpp:1657] : Project version history: 3.0v1b11, 3.0v1b12, 3.0v1b14, 3.0v1b16, 3.0v1
Debug : [            mriundomanager.cpp:96  ] : Setting Undo Limit to 0
Debug : [             mricollection.cpp:428 ] : Shortcuts 
Debug : [             mricollection.cpp:429 ] : Names 
Debug : [             mricollection.cpp:439 ] : Making Shortcut  for 
Debug : [             mricollection.cpp:460 ] : Making Shortcut  for 0
Debug : [         mriprojectmanager.cpp:5735] : Emitting
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 55 ms 48 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 52 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 63 ms 55 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 63 ms 56 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 60 ms 55 uu
Debug : [                 mrisvtmap.cpp:219 ] : Created Map Texture : 162
Debug : [           mrisvtmapofmaps.cpp:41  ] : Created Map of Maps : 163, NumChannels=1 NumPatches=1
Debug : [      mrisvtshadingcontext.cpp:123 ] : SVT shading context creation took 990 ms
Debug : [             mricollection.cpp:428 ] : Shortcuts 
Debug : [             mricollection.cpp:429 ] : Names 
Debug : [             mricollection.cpp:439 ] : Making Shortcut  for 
Debug : [             mricollection.cpp:460 ] : Making Shortcut  for 0
Debug : [           mrifileprotocol.cpp:353 ] : Accessing file across a network: //untitled
Debug : [           mrifileprotocol.cpp:353 ] : Accessing file across a network: //untitled
Repeat : Message repeating...
Repeat : Last message was repeated 14 more times
Debug : [           mrisvtmapofmaps.cpp:41  ] : Created Map of Maps : 163, NumChannels=6 NumPatches=0
Debug : [             mricollection.cpp:428 ] : Shortcuts 
Debug : [             mricollection.cpp:429 ] : Names 
Debug : [             mricollection.cpp:439 ] : Making Shortcut  for 
Debug : [             mricollection.cpp:460 ] : Making Shortcut  for 0
Debug : [             mricollection.cpp:428 ] : Shortcuts 
Debug : [             mricollection.cpp:429 ] : Names 
Debug : [             mricollection.cpp:439 ] : Making Shortcut  for 
Debug : [             mricollection.cpp:460 ] : Making Shortcut  for 0
Debug : [           mrisvtmapofmaps.cpp:41  ] : Created Map of Maps : 163, NumChannels=6 NumPatches=28
Debug : [             mrigeoversion.cpp:853 ] : Project is NULL
Debug : [             mrigeoversion.cpp:853 ] : Project is NULL
Repeat : Message repeating...
Repeat : Last message was repeated 7 more times
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'BRDF', input count: 7
Debug : [             mrigeoversion.cpp:853 ] : Project is NULL
Debug : [             mrigeoversion.cpp:853 ] : Project is NULL
Repeat : Message repeating...
Repeat : Last message was repeated 1 more time
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node '', input count: 21
Debug : [             mrigeoversion.cpp:853 ] : Project is NULL
Debug : [             mrigeoversion.cpp:853 ] : Project is NULL
Repeat : Message repeating...
Repeat : Last message was repeated 1 more time
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'BRDF', input count: 10
Debug : [             mrigeoversion.cpp:853 ] : Project is NULL
Debug : [     mriserializableobject.cpp:1105] : User attribute named TitleText does not exist
Debug : [     mriserializableobject.cpp:1105] : User attribute named TitleText does not exist
Repeat : Message repeating...
Repeat : Last message was repeated 2 more times
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'alSurfaceX', input count: 21
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'AiStandard', input count: 22
Debug : [         mriprojectmanager.cpp:5735] : Emitting
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 50 ms 48 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 60 ms 55 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 61 ms 56 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 57 ms 55 uu
Debug : [                 mrisvtmap.cpp:219 ] : Created Map Texture : 164
Debug : [           mrisvtmapofmaps.cpp:41  ] : Created Map of Maps : 165, NumChannels=1 NumPatches=1
Debug : [      mrisvtshadingcontext.cpp:123 ] : SVT shading context creation took 952 ms
Debug : [             mricollection.cpp:428 ] : Shortcuts 
Debug : [             mricollection.cpp:429 ] : Names 
Debug : [             mricollection.cpp:439 ] : Making Shortcut  for 
Debug : [             mricollection.cpp:460 ] : Making Shortcut  for 0
Debug : [           mrisvtmapofmaps.cpp:41  ] : Created Map of Maps : 165, NumChannels=2 NumPatches=0
Debug : [             mricollection.cpp:428 ] : Shortcuts 
Debug : [             mricollection.cpp:429 ] : Names 
Debug : [             mricollection.cpp:439 ] : Making Shortcut  for 
Debug : [             mricollection.cpp:460 ] : Making Shortcut  for 0
Debug : [             mricollection.cpp:428 ] : Shortcuts 
Debug : [             mricollection.cpp:429 ] : Names 
Debug : [             mricollection.cpp:439 ] : Making Shortcut  for 
Debug : [             mricollection.cpp:460 ] : Making Shortcut  for 0
Debug : [           mrisvtmapofmaps.cpp:41  ] : Created Map of Maps : 165, NumChannels=2 NumPatches=54
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'BRDF', input count: 7
Debug : [             mrigeoversion.cpp:853 ] : Project is NULL
Debug : [             mrigeoversion.cpp:853 ] : Project is NULL
Repeat : Message repeating...
Repeat : Last message was repeated 4 more times
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'BRDF', input count: 10
Debug : [             mrigeoversion.cpp:853 ] : Project is NULL
Debug : [             mrigeoversion.cpp:853 ] : Project is NULL
Debug : [     mriserializableobject.cpp:1105] : User attribute named TitleText does not exist
Debug : [                mriproject.cpp:1984] : Object selection changed
Debug : [                mriproject.cpp:1984] : Object selection changed
Repeat : Message repeating...
Repeat : Last message was repeated 2 more times
Debug : [                mriproject.cpp:247 ] : [ OK ] Cleared Geo
Debug : [                mriproject.cpp:259 ] : [ OK ] Loaded project 'D:/Mari/026011bb-437d-4dd3-ae5b-20bb7a1b2095/Project.mri'
Debug : [                mriproject.cpp:260 ] :        Mesh path: 'Example_Project_Head.obj'
Debug : [   mrisnglslcontextmanager.cpp:748 ] : Reloading Shader 'Shader Network1'
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 29 
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 59 ms 74 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 344 ms uu 74
Debug : [   mrisnglslcontextmanager.cpp:748 ] : Reloading Shader 'Shader Network1'
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 30 
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 1567 ms 110 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 1861 ms uu 110
Debug : [            mrianimcontrol.cpp:385 ] : Playing No
Debug : [     mricanvasactionfamily.cpp:451 ] : canvas is NULL
Debug : [          mriobjectmanager.cpp:244 ] : No property with name 'path'
Debug : [          mriobjectmanager.cpp:244 ] : No property with name 'fileName'
Debug : [          mriobjectmanager.cpp:244 ] : No property with name 'gradientColor'
Debug : [          mriobjectmanager.cpp:244 ] : No property with name 'backgroundColor'
Debug : [          mriobjectmanager.cpp:244 ] : No property with name 'backgroundImage'
Debug : [          mriobjectmanager.cpp:244 ] : No property with name 'background'
Debug : [mrigeometryselectionmanager.cpp:1591] : Refresh groups : FaceSelectionGroupList contains the following:
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export &Everything 1
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export Current Object 1
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export &All Channels 1
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export Current &Channel 1
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export All Masks 1
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export Selected Masks 1
Debug : [         mrichannelactions.cpp:702 ] : Setting enabled Export Current Mask 1
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export Everything &Flattened 1
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export Current Object Flattened 1
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export &All Channels Flattened 1
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export Current &Channel Flattened 1
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export &All Layers Flattened 1
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export &Selected Layers Flattened 1
Debug : [         mrichannelactions.cpp:712 ] : Setting enabled Export Current Mask Flattened 1
Debug : [     mrisnchannelinputnode.cpp:238 ] : [ -- ] Refreshing properties for paint node 'Paint'
Debug : [     mrisnchannelinputnode.cpp:238 ] : [ -- ] Refreshing properties for paint node 'Paint 3'
Debug : [     mrisnchannelinputnode.cpp:238 ] : [ -- ] Refreshing properties for paint node 'Paint 1'
Debug : [     mrisnchannelinputnode.cpp:238 ] : [ -- ] Refreshing properties for paint node 'Paint 2'
Debug : [     mrisnchannelinputnode.cpp:238 ] : [ -- ] Refreshing properties for paint node 'Paint 4'
Debug : [     mrisnchannelinputnode.cpp:238 ] : [ -- ] Refreshing properties for paint node 'Paint'
Debug : [     mrisnchannelinputnode.cpp:238 ] : [ -- ] Refreshing properties for paint node 'Paint 1'
Debug : [         mriprojectmanager.cpp:1092] : Setting Collection Objects
Debug : [  mricollectionviewmanager.cpp:69  ] : setting collection type MriGeoEntity
Debug : [        mricollectionpanel.cpp:733 ] : Finished assigning collection 'MriGeoEntity'; took 0.017 seconds
Debug : [         mriprojectmanager.cpp:1092] : Setting Collection Projectors
Debug : [  mricollectionviewmanager.cpp:69  ] : setting collection type MriProjector
Debug : [        mricollectionpanel.cpp:733 ] : Finished assigning collection 'MriProjector'; took 0.001 seconds
Debug : [         mriprojectmanager.cpp:1092] : Setting Collection Selection Groups
Debug : [  mricollectionviewmanager.cpp:69  ] : setting collection type MriGeometrySelectionGroup
Debug : [        mricollectionpanel.cpp:733 ] : Finished assigning collection 'MriGeometrySelectionGroup'; took 0.009 seconds
Debug : [         mriprojectmanager.cpp:1092] : Setting Collection Lights
Debug : [  mricollectionviewmanager.cpp:69  ] : setting collection type MriGeoLight
Debug : [        mricollectionpanel.cpp:733 ] : Finished assigning collection 'MriGeoLight'; took 0.014 seconds
Debug : [         mriprojectmanager.cpp:1092] : Setting Collection Patches
Debug : [  mricollectionviewmanager.cpp:69  ] : setting collection type MriUvPatch
Debug : [        mricollectionpanel.cpp:733 ] : Finished assigning collection 'Patches'; took 0.012 seconds
Debug : [              mrilayerview.cpp:567 ] : pLayerStack is NULL
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 119 ms
Debug : [    mrishadermaterialsview.cpp:251 ] : [ -- ] Added shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a890, 'alSurfaceX'
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 31 children nodes to this Shader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 140 ms
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001E9AAFC0> from <bound method SnapshotUI._updateShotListAdded of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001E9AAF78> from <bound method SnapshotUI._updateShotListRemoved of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001E9AAB88> from <bound method SnapshotUI._updateShotListAdded of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001E9AAC48> from <bound method SnapshotUI._updateShotListRemoved of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001E9AAC90> from <bound method SnapshotUI._updateShotListAdded of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001E9AACA8> from <bound method SnapshotUI._updateShotListRemoved of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001E9AAA38> from <bound method SnapshotUI._updateShotListAdded of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001E9AAAF8> from <bound method SnapshotUI._updateShotListRemoved of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001E9AAAE0> from <bound method SnapshotUI._updateShotListAdded of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001E9AAAC8> from <bound method SnapshotUI._updateShotListRemoved of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001E9AAF90> from <bound method SnapshotUI._updateShotListAdded of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001E9AAFA8> from <bound method SnapshotUI._updateShotListRemoved of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [             mricurveatlas.cpp:438 ] : CurveAtlas size before clear   :64
Debug : [             mricurveatlas.cpp:439 ] : CurveAtlas Max Number of Lines :0
Debug : [                mripainter.cpp:200 ] : This method is deprecated
Debug : [     mriserializableobject.cpp:1010] : name length 0
Debug : [     mriserializableobject.cpp:1010] : name length 0
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'BRDF 2', input count: 7
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 152 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 155 ms
Debug : [     mrishaderinputmanager.cpp:234 ] : [ !! ] Failed to find shader input 0x1f8c8fd0
Debug : [     mriserializableobject.cpp:1017] : Attribute 'ConvertToGlossiness' already exists!
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node '', input count: 21
Debug : [   mrishadernetworkmanager.cpp:1603] : [ Nodes ] To Convert Unversioned 25 Custom 0 Same 174 Different 1 New 0 Old 0 BottomTransparency 0
Debug : [   mrishadernetworkmanager.cpp:1698] : [ Nodes ] Showing Dialog to Ask which nodes to upgrade.
Debug : [   mrishadernetworkmanager.cpp:1751] : [ Nodes ] Convert 1 Change 0
Debug : [     mriserializableobject.cpp:1017] : Attribute 'ConvertToGlossiness' already exists!
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node '', input count: 21
Debug : [             mrisnbasenode.cpp:5261] : [ -- ] About to upgrade node 'alSurfaceX/'
Debug : [     mriserializableobject.cpp:1017] : Attribute 'ConvertToGlossiness' already exists!
Debug : [             mrisnbasenode.cpp:5031] : [ !! ] Node 'alSurfaceX/' Cannot create Attribute name 'Specular2/ConvertToGlossiness'
Debug : [             mrisnbasenode.cpp:5278] : [ !! ] Upgrade nodes failed : add attributes
Debug : [   mrishadernetworkmanager.cpp:1277] : Cannot upgrade nodes for UUID 'alSurfaceX'
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 59 ms 55 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 61 ms 56 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 51 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 52 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 31  uu 110
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 76 ms 110 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 57 ms 55 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 60 ms 56 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 31  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 55 ms 74 uu
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 204 ms
Debug : [              mrigeomtools.cpp:292 ] : Initialise Rendering System
Debug : [                    mrigpu.cpp:6660] : Texture load: 'C:/Program Files/Mari3.0v1/Bundle/Media/Images/Busy.png'
Debug : [                    mrigpu.cpp:6681] : Texture load: 166
Debug : [    mrideferredrenderchain.cpp:413 ] : Size of Render Ops is 8
Debug : [     mricanvasactionfamily.cpp:245 ] : Canvas is NULL
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 173 ms
Debug : [            mriundomanager.cpp:81  ] : Setting Undo Limit to 0
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 31  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 60 ms 74 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 61 ms uu 74
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 31  uu 110
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 87 ms 110 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 94 ms uu 110
Debug : [                mriproject.cpp:184 ] :   - Name Created | AttriType  | CreationDate  | isNull=1
Debug : [                mriproject.cpp:184 ] :   - Name Modified | AttriType  | CreationDate  | isNull=1
Debug : [                mriproject.cpp:184 ] :   - Name MultipleGeometriesMerged | AttriType  | CreationDate  | isNull=1
Debug : [                mriproject.cpp:184 ] :   - Name Owner | AttriType  | CreationDate  | isNull=1
Debug : [                mriproject.cpp:184 ] :   - Name Created | AttriType  | CreationDate  | isNull=1
Debug : [                mriproject.cpp:184 ] :   - Name Modified | AttriType  | CreationDate  | isNull=1
Debug : [                mriproject.cpp:184 ] :   - Name MultipleGeometriesMerged | AttriType  | CreationDate  | isNull=1
Debug : [                mriproject.cpp:184 ] :   - Name Owner | AttriType  | CreationDate  | isNull=1
Debug : [         mriprojectmanager.cpp:1797] : [ OK ] Opened Project 'D:/Mari/026011bb-437d-4dd3-ae5b-20bb7a1b2095/Project.mri' in 161.82 seconds
Debug : [         mriprojectmanager.cpp:1798] : Open Project Timing Breakdown...
Debug : [         mriprojectmanager.cpp:1799] : 	Create new project:              12 ms
Debug : [         mriprojectmanager.cpp:1800] : 	Set subcache:                    2 ms
Debug : [         mriprojectmanager.cpp:1801] : 	Project xml load and parse time: 7032 ms
Debug : [         mriprojectmanager.cpp:1802] : 	Load data time:                  173 ms
Debug : [         mriprojectmanager.cpp:1803] : 	Project events processing time:  38 ms
Debug : [         mriprojectmanager.cpp:1804] : 	Add Project Time:                0 ms
Debug : [         mriprojectmanager.cpp:1805] : 	Add To Recent Time:              9 ms
Debug : [         mriprojectmanager.cpp:1806] : 	Set current project time:        152189 ms
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 31  uu 110
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 75 ms 110 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 81 ms uu 110
Debug : [   mrisnglslcontextmanager.cpp:667 ] : Network is NULL
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 31  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 74 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 56 ms uu 74
Debug : [               mrirenderop.cpp:70  ] : Adding Render Chain Property RenderCameras
Debug : [               mrirenderop.cpp:70  ] : Adding Render Chain Property RenderLights
Debug : [               mrienvlight.cpp:1383] : createCubeTextures() Blur 57 ms NDotL 47 ms
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 14 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 32  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 27 ms 8 uu
Debug : [             mricurveatlas.cpp:537 ] : Creating Atlas Texture 1024x64 179 Floating point 32f 
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 32  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 46 ms 8 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 33  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 27 ms 17 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 33  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 46 ms 17 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 16 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 34  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 49 ms 13 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 34  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 30 ms 13 uu
Debug : [            mrirenderhudop.cpp:205 ] : Resizing HUD buffer to 394 x 211
Debug : [               application.cpp:430 ] : [ OpenColorIO ] ==============================================================
Debug : [               application.cpp:430 ] : [ OpenColorIO ] Configuration:
Debug : [               application.cpp:430 ] : [ OpenColorIO ] ==============================================================
Debug : [               application.cpp:430 ] : [ OpenColorIO ]      Enabled: True; Default: True
Debug : [               application.cpp:430 ] : [ OpenColorIO ]      Profile: Colorspace; Default: Colorspace
Debug : [               application.cpp:430 ] : [ OpenColorIO ]  Config Path: C:/Program Files/Mari3.0v1/Bundle/Media/Color/OpenColorIO/nuke-default/config.ocio; Default: C:/Program Files/Mari3.0v1/Bundle/Media/Color/OpenColorIO/nuke-default/config.ocio
Debug : [               application.cpp:430 ] : [ OpenColorIO ]   Colorspace: linear; Default: linear
Debug : [               application.cpp:430 ] : [ OpenColorIO ]     LUT Path: ; Default: 
Debug : [               application.cpp:430 ] : [ OpenColorIO ]  Extrapolate: True; Default: True
Debug : [               application.cpp:430 ] : [ OpenColorIO ]      Display: default; Default: default
Debug : [               application.cpp:430 ] : [ OpenColorIO ]         View: sRGB; Default: sRGB
Debug : [               application.cpp:430 ] : [ OpenColorIO ]      Swizzle: RGB; Default: RGB
Debug : [               application.cpp:430 ] : [ OpenColorIO ]       F-Stop: 8.000000; Default: 8.000000; Center: 8.000000
Debug : [               application.cpp:430 ] : [ OpenColorIO ]         Gain: 1.000000; Default: 1.000000
Debug : [               application.cpp:430 ] : [ OpenColorIO ]        Gamma: 1.000000; Default: 1.000000
Debug : [               application.cpp:430 ] : [ OpenColorIO ] ==============================================================
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Repeat : Message repeating...
Repeat : Last message was repeated 1 more time
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Fresnel Mode
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Fresnel Mode
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Fresnel Mode
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Repeat : Message repeating...
Repeat : Last message was repeated 1 more time
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Strength
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Strength
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'customShader' completed in 96 ms
Debug : [                mripainter.cpp:194 ] : This method is deprecated
Debug : [                mriproject.cpp:1558] : [ -- ] About to autosave project ...
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 7a600f36-a798-4a3f-a1c6-3b6641a58e0e 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 3d9ac0e7-9489-4115-9e46-20a7b889e2c4 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 4b438c38-5e2c-4533-b316-e9318e0b3bfe 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 51da21ab-ed90-4b64-8084-46cd7ce6f743 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of f58743b0-ff3e-421d-82a7-98f796bf976a 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of ecffadb3-f059-48b6-9e2c-0da6c4553212 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 78b723f8-ca72-4857-9965-f69722df0652 4
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 344920b6-ba9b-4aef-b100-39d52b45daa3 4
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 7a600f36-a798-4a3f-a1c6-3b6641a58e0e 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 3d9ac0e7-9489-4115-9e46-20a7b889e2c4 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 4b438c38-5e2c-4533-b316-e9318e0b3bfe 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 51da21ab-ed90-4b64-8084-46cd7ce6f743 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of f58743b0-ff3e-421d-82a7-98f796bf976a 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of ecffadb3-f059-48b6-9e2c-0da6c4553212 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 78b723f8-ca72-4857-9965-f69722df0652 4
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 344920b6-ba9b-4aef-b100-39d52b45daa3 4
Debug : [                mriproject.cpp:1683] : Copying C:/Users/kai.xu/AppData/Local/Temp/autosave.tmp to D:/Mari/026011bb-437d-4dd3-ae5b-20bb7a1b2095/autosave.mri
Debug : [    mrishadermaterialsview.cpp:245 ] : [ -- ] Removed old shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a890, 'alSurfaceX'
Debug : [    mrishadermaterialsview.cpp:251 ] : [ -- ] Added shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1819f160, 'customShader'
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 10 children nodes to this Shader
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 2 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 39  uu 110
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 351 ms 67 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 354 ms uu 67
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 51
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 40  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 25 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 40  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 25 ms 17 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 40  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 28 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #1 : Remove Layer Shader customShader
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #2 : Remove Node : customShader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'customShader' completed in 49 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'customShader' completed in 37 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'AiStandard' completed in 101 ms
Debug : [    mrishadermaterialsview.cpp:245 ] : [ -- ] Removed old shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1819f160, 'customShader'
Debug : [    mrishadermaterialsview.cpp:251 ] : [ -- ] Added shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1819f330, 'AiStandard'
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 32 children nodes to this Shader
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #2 : Remove Node : customShader
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #1 : Remove Layer Shader customShader
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 40  uu 67
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 1298 ms 105 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 1304 ms uu 105
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'AiStandard' completed in 107 ms
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'AiStandard' completed in 109 ms
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 52
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 41  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 42 ms 8 uu
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 53
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 41  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 42 ms 17 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 41  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 45 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #1 : Remove Layer Shader AiStandard
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #2 : Remove Node : AiStandard
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'AiStandard' completed in 127 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'AiStandard' completed in 103 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'AiStandard' completed in 106 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 117 ms
Debug : [    mrishadermaterialsview.cpp:245 ] : [ -- ] Removed old shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1819f330, 'AiStandard'
Debug : [    mrishadermaterialsview.cpp:251 ] : [ -- ] Added shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a890, 'alSurfaceX'
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #2 : Remove Node : AiStandard
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #1 : Remove Layer Shader AiStandard
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 20 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 41  uu 105
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 74 ms 110 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 80 ms uu 110
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 114 ms
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 117 ms
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 41  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 42 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 41  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 42 ms 17 uu
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'BRDF' completed in 108 ms
Debug : [    mrishadermaterialsview.cpp:245 ] : [ -- ] Removed old shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a890, 'alSurfaceX'
Debug : [    mrishadermaterialsview.cpp:251 ] : [ -- ] Added shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a6c0, 'BRDF'
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 18 children nodes to this Shader
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 4 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 41  uu 110
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 4 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 41  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 812 ms 13 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 842 ms 81 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 844 ms uu 81
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 54
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 5 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 42  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 29 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 4 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 42  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 28 ms 17 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #1 : Remove Layer Shader BRDF
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #2 : Remove Node : BRDF
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'BRDF' completed in 93 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'BRDF' completed in 75 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'BRDF' completed in 77 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'BRDF' completed in 84 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 119 ms
Debug : [    mrishadermaterialsview.cpp:245 ] : [ -- ] Removed old shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a6c0, 'BRDF'
Debug : [    mrishadermaterialsview.cpp:251 ] : [ -- ] Added shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a890, 'alSurfaceX'
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #2 : Remove Node : BRDF
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #1 : Remove Layer Shader BRDF
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 42  uu 81
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 74 ms 110 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 80 ms uu 110
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 114 ms
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 118 ms
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 20 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 42  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 44 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 42  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 44 ms 17 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 55
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #1 : Remove Layer Shader alSurfaceX
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #2 : Remove Node : alSurfaceX
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 142 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 110 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 112 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 32 ms
Debug : [    mrishadermaterialsview.cpp:245 ] : [ -- ] Removed old shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a890, 'alSurfaceX'
Debug : [    mrishadermaterialsview.cpp:251 ] : [ -- ] Added shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a4f0, 'Current Paint Target'
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 4 children nodes to this Shader
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #2 : Remove Node : alSurfaceX
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #1 : Remove Layer Shader alSurfaceX
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 42  uu 110
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 20 ms
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 296 ms
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 336 ms 69 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 338 ms uu 69
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 43  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 24 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 43  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 24 ms 17 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 43  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 28 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Color
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Constant
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Base Color Catalogue
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Channel/Channel Height
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Channel/Channel Color
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Add
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Subtract
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Multiply
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Divide
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Abs
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Position
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Surface Normal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Tangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Bitangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UV
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UDIM Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UV Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Ambient Occlusion
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Selection Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Displacement
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Displacement Simple
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Tessellation Clip To Screen
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Tessellation To Pixels
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Perturb Point
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Perturb Surface
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/Bottom Transparency
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/Merge
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/MergeNoAlpha
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Brightness
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Brightness Lookup
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Balance
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Contrast
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Flow
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Invert
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Log To Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Linear To Log
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Luminosity
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Clamp
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Lookup
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Switch
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Copy Channel
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color To Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Set Value
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Gamma
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/HSL
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/HSV
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Hue Shift
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Saturation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Levels
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Grade
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/sRGB2Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Premultiply Alpha
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Scale
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Shuffle
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Height As Normal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Tangent To Screen
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Tangent To World
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/World To Tangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Falloff Curve
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Cook Torrance
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Beckman
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Phong
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Blinn
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Flat
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/BRDF
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Standard Lighting
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/AiStandard
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/VRayMtl
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/RedshiftArchitectural
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Unreal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Layered/Layered
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Diffuse/Lambertian
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Diffuse/Minnaert
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Tangent Space To Eye Space
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Normal Modulation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Lighting Result Modulation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Color To Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Cube Map
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Sphere Map
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Cube Map Projector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Sphere Map Projector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Tri Planar Projection
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Environment Light
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Tiled
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/UV Grid
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Sphere
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Cube
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Object Space Linear Gradient
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/UV Linear Gradient
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Perlin
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Cellular
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Squiggle
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Fractal/Cloud
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Fractal/Turbulence
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Plant/Wood
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Misc/Oil
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Animation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Output
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Viewer
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Cross Bar 2
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Channel Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Channel Bake
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Current Layer
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Shuffle Copy
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Custom
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Empty
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Set Unlit
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Set Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/EmptyWithSkip
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Current Paint Target
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Shader Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Face Test
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Group
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Backdrop
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/StickyNote
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Dot
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/IBL
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Shader
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'BRDF', input count: 7
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 25 ms
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001F1FB078> from <bound method SnapshotUI._updateShotListAdded of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001F1FB090> from <bound method SnapshotUI._updateShotListRemoved of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 19 ms
Debug : [     mrishaderinputmanager.cpp:234 ] : [ !! ] Failed to find shader input 0x42a12460
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 49 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 43  uu 69
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 51 ms 69 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 43  uu 69
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 52 ms 69 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 43  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 53 ms 74 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 43  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 74 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 43  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 74 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 43  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 55 ms 74 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 43  uu 69
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 55 ms 69 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 56 ms uu 69
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 43  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 27 ms 8 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 43  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 25 ms 8 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 43  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 24 ms 17 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 43  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 27 ms 17 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 43  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 27 ms 13 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 43  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 30 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 14 more times
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #1 : Add Shader
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #2 : Add Shader alSurfaceX
Debug : [       mrilayershaderutils.cpp:304 ] : Add Shader 'alSurfaceX'
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Standalone/alSurfaceX
Debug : [     mriserializableobject.cpp:1017] : Attribute 'ConvertToGlossiness' already exists!
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node '', input count: 21
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Standalone/alSurfaceX
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'Shader', input count: 22
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Output
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'Shader', input count: 21
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Output
Debug : [ mrisnnodegraphviewcontext.cpp:1061] : [ -- ] About to position 'Output' underneath 'Output', factor : 3
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'alSurfaceX', input count: 21
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.DiffuseColor'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.DiffuseRoughness'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Specular1Color'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Specular1Roughness'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Specular1Anisotropy'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Specular1Rotation'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Specular2Color'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Specular2Roughness'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Specular2Anisotropy'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Specular2Rotation'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.TransmissionColor'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Opacity'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.SSSColor'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.SSSRadius'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.EmissionColor'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Bump'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Normal'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Displacement'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.Vector'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.ThicknessMap'
Debug : [            mrisngroupnode.cpp:482 ] : 0x449a1dd0 Input Connection already named '.View_Current_Channel'
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Set Unlit
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Set Unlit
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Set Vector
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Set Vector
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Surface/Displacement Simple
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Surface/Displacement Simple
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Utils/Tangent Space To Eye Space
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Utils/Tangent Space To Eye Space
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Utils/Normal Modulation
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Utils/Normal Modulation
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Filter/Height As Normal
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Filter/Height As Normal
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Utils/Tangent Space To Eye Space
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Utils/Tangent Space To Eye Space
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Utils/Color To Vector
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Utils/Color To Vector
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Refresh Group Inputs
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'alSurfaceX', input count: 21
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #2 : Add Shader alSurfaceX
Debug : [    mrishadermaterialsview.cpp:245 ] : [ -- ] Removed old shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a4f0, 'Current Paint Target'
Debug : [    mrishadermaterialsview.cpp:251 ] : [ -- ] Added shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x449a1dd0, 'alSurfaceX'
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 31 children nodes to this Shader
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #1 : Add Shader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 93 ms
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 98 ms
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 43  uu 69
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 1419 ms 108 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 1424 ms uu 108
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 44  uu 108
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 72 ms 108 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 73 ms uu 108
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 44  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 42 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 44  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 42 ms 17 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 44  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 45 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 151 ms
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Set Input 'alSurfaceX.DiffuseColor' to 'Diffuse_Head.Output'
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 44  uu 108
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 1479 ms 109 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 1484 ms uu 109
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 45  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 44 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 45  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 42 ms 17 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 45  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 45 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 150 ms
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Set Input 'alSurfaceX.Specular1Color' to 'Specular_Head.Output'
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 45  uu 109
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 1549 ms 110 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 1555 ms uu 110
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 43 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 43 ms 17 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 46 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Roughness
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Convert To Glossiness
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Roughness
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Convert To Glossiness
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Roughness
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Fresnel Mode
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Anisotropy
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Roughness
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Roughness
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Repeat : Message repeating...
Repeat : Last message was repeated 1 more time
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Rotation
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Anisotropy
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Repeat : Message repeating...
Repeat : Last message was repeated 3 more times
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Repeat : Message repeating...
Repeat : Last message was repeated 2 more times
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Fresnel Mode
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Roughness
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Reflectivity
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Reflectivity
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Fresnel Mode
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Reflectivity
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Edge tint
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 56
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 57
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #1 : Remove Layer Shader alSurfaceX
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #2 : Remove Node : alSurfaceX
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 150 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 112 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 117 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 36 ms
Debug : [    mrishadermaterialsview.cpp:245 ] : [ -- ] Removed old shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x449a1dd0, 'alSurfaceX'
Debug : [    mrishadermaterialsview.cpp:251 ] : [ -- ] Added shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a4f0, 'Current Paint Target'
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #2 : Remove Node : alSurfaceX
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #1 : Remove Layer Shader alSurfaceX
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 110
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 19 ms
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 51 ms 69 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 52 ms uu 69
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 18 ms
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 24 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 24 ms 17 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 27 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Color
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Constant
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Base Color Catalogue
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Channel/Channel Height
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Channel/Channel Color
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Add
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Subtract
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Multiply
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Divide
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Abs
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Position
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Surface Normal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Tangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Bitangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UV
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UDIM Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UV Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Ambient Occlusion
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Selection Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Displacement
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Displacement Simple
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Tessellation Clip To Screen
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Tessellation To Pixels
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Perturb Point
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Perturb Surface
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/Bottom Transparency
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/Merge
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/MergeNoAlpha
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Brightness
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Brightness Lookup
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Balance
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Contrast
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Flow
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Invert
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Log To Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Linear To Log
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Luminosity
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Clamp
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Lookup
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Switch
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Copy Channel
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color To Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Set Value
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Gamma
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/HSL
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/HSV
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Hue Shift
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Saturation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Levels
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Grade
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/sRGB2Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Premultiply Alpha
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Scale
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Shuffle
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Height As Normal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Tangent To Screen
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Tangent To World
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/World To Tangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Falloff Curve
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Cook Torrance
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Beckman
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Phong
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Blinn
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Flat
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/BRDF
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Standard Lighting
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/AiStandard
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/VRayMtl
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/RedshiftArchitectural
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Unreal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Layered/Layered
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Diffuse/Lambertian
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Diffuse/Minnaert
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Tangent Space To Eye Space
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Normal Modulation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Lighting Result Modulation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Color To Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Cube Map
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Sphere Map
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Cube Map Projector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Sphere Map Projector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Tri Planar Projection
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Environment Light
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Tiled
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/UV Grid
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Sphere
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Cube
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Object Space Linear Gradient
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/UV Linear Gradient
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Perlin
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Cellular
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Squiggle
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Fractal/Cloud
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Fractal/Turbulence
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Plant/Wood
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Misc/Oil
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Animation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Output
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Viewer
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Cross Bar 2
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Channel Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Channel Bake
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Current Layer
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Shuffle Copy
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Custom
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Empty
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Set Unlit
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Set Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/EmptyWithSkip
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Current Paint Target
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Shader Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Face Test
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Group
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Backdrop
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/StickyNote
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Dot
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/IBL
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Shader
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'BRDF', input count: 7
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 23 ms
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001F1FB048> from <bound method SnapshotUI._updateShotListAdded of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001F1FB060> from <bound method SnapshotUI._updateShotListRemoved of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 17 ms
Debug : [     mrishaderinputmanager.cpp:234 ] : [ !! ] Failed to find shader input 0x29564730
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 52 ms 69 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 51 ms 69 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 51 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 74 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 74 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 74 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 74 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 52 ms 69 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 54 ms uu 69
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 27 ms 8 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 24 ms 8 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 25 ms 17 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 26 ms 17 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 27 ms 13 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 30 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 14 more times
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Color
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Constant
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Base Color Catalogue
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Channel/Channel Height
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Channel/Channel Color
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Add
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Subtract
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Multiply
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Divide
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Abs
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Position
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Surface Normal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Tangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Bitangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UV
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UDIM Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UV Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Ambient Occlusion
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Selection Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Displacement
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Displacement Simple
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Tessellation Clip To Screen
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Tessellation To Pixels
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Perturb Point
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Perturb Surface
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/Bottom Transparency
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/Merge
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/MergeNoAlpha
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Brightness
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Brightness Lookup
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Balance
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Contrast
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Flow
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Invert
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Log To Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Linear To Log
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Luminosity
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Clamp
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Lookup
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Switch
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Copy Channel
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color To Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Set Value
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Gamma
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/HSL
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/HSV
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Hue Shift
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Saturation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Levels
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Grade
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/sRGB2Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Premultiply Alpha
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Scale
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Shuffle
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Height As Normal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Tangent To Screen
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Tangent To World
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/World To Tangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Falloff Curve
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Cook Torrance
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Beckman
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Phong
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Blinn
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Flat
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/BRDF
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Standard Lighting
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/AiStandard
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/VRayMtl
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/RedshiftArchitectural
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Unreal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Layered/Layered
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Diffuse/Lambertian
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Diffuse/Minnaert
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Tangent Space To Eye Space
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Normal Modulation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Lighting Result Modulation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Color To Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Cube Map
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Sphere Map
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Cube Map Projector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Sphere Map Projector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Tri Planar Projection
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Environment Light
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Tiled
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/UV Grid
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Sphere
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Cube
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Object Space Linear Gradient
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/UV Linear Gradient
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Perlin
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Cellular
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Squiggle
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Fractal/Cloud
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Fractal/Turbulence
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Plant/Wood
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Misc/Oil
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Animation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Output
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Viewer
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Cross Bar 2
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Channel Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Channel Bake
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Current Layer
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Shuffle Copy
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Custom
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Empty
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Set Unlit
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Set Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/EmptyWithSkip
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Current Paint Target
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Shader Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Face Test
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Group
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Backdrop
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/StickyNote
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Dot
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/IBL
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Shader
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'BRDF', input count: 7
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 24 ms
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001F1FB090> from <bound method SnapshotUI._updateShotListAdded of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001F1FB030> from <bound method SnapshotUI._updateShotListRemoved of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 17 ms
Debug : [     mrishaderinputmanager.cpp:234 ] : [ !! ] Failed to find shader input 0x2956fa40
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 51 ms 69 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 51 ms 69 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 74 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 74 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 55 ms 74 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 53 ms 74 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 53 ms 69 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 54 ms uu 69
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 27 ms 8 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 25 ms 8 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 24 ms 17 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 26 ms 17 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 28 ms 13 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 30 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 14 more times
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #1 : Add Shader
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #2 : Add Shader alSurfaceX
Debug : [       mrilayershaderutils.cpp:304 ] : Add Shader 'alSurfaceX'
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Standalone/alSurfaceX
Debug : [     mriserializableobject.cpp:1017] : Attribute 'ConvertToGlossiness' already exists!
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node '', input count: 21
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Standalone/alSurfaceX
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'Shader', input count: 22
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Output
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'Shader', input count: 21
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Output
Debug : [ mrisnnodegraphviewcontext.cpp:1061] : [ -- ] About to position 'Output' underneath 'Output', factor : 3
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'alSurfaceX', input count: 21
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.DiffuseColor'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.DiffuseRoughness'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Specular1Color'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Specular1Roughness'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Specular1Anisotropy'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Specular1Rotation'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Specular2Color'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Specular2Roughness'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Specular2Anisotropy'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Specular2Rotation'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.TransmissionColor'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Opacity'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.SSSColor'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.SSSRadius'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.EmissionColor'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Bump'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Normal'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Displacement'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.Vector'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.ThicknessMap'
Debug : [            mrisngroupnode.cpp:482 ] : 0x44ab5ce0 Input Connection already named '.View_Current_Channel'
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Set Unlit
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Set Unlit
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Set Vector
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Set Vector
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Surface/Displacement Simple
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Surface/Displacement Simple
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Utils/Tangent Space To Eye Space
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Utils/Tangent Space To Eye Space
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Utils/Normal Modulation
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Utils/Normal Modulation
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Filter/Height As Normal
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Filter/Height As Normal
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Utils/Tangent Space To Eye Space
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Utils/Tangent Space To Eye Space
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Utils/Color To Vector
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Utils/Color To Vector
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Refresh Group Inputs
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'alSurfaceX', input count: 21
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #2 : Add Shader alSurfaceX
Debug : [    mrishadermaterialsview.cpp:245 ] : [ -- ] Removed old shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a4f0, 'Current Paint Target'
Debug : [    mrishadermaterialsview.cpp:251 ] : [ -- ] Added shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x44ab5ce0, 'alSurfaceX'
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 31 children nodes to this Shader
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #1 : Add Shader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 95 ms
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 99 ms
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:711 ] : [ !! ] Shader 'Shader Network1' Compilation Failure. Not linking.
---SourceCode---
Shader Type: Fragment
1: #version 150
2: #define MRI_SHADER_FRAGMENT 1
3: #define MRI_NUM_PATCH_ATTRIBUTES 4096
4: #define MRI_SVT_GATHER_USE_QUINT 1
5: #define MRI_USE_CUBE_MAP_ARRAY 1
6: #define USE_DEFERRED_TEXTURE_2D_ARRAY 1
7: 
8: //! Description |  Shader Network evaluation fragment shader
9: //! Name |  Func_ShaderNetwork.frag
10: //! Author |  Jack Greasley, Kiyoyuki Nakagaki, Duncan Hopkins
11: //! Copyright |  Copyright (c) 2013 The Foundry 
12: 
13: #define MRI_LIGHT_ARRAY_SIZE 4
14: 
15: struct MriSystemFragmentState
16: {
17:     vec4 Diffuse;
18:     vec4 Unlit;
19:     vec4 VectorData;
20: 
21:     vec2 dUV;
22: 
23:     vec3 ProjectionCoord;
24:     vec2 TangentInProjectionSpace;
25:     vec2 BitangentInProjectionSpace;
26: 
27:     bool Hidden;
28:     bool Locked;
29:     bool Selected;
30: 
31:     float ProjectionExposure;
32:     float NonPreviewableProjectionExposure;
33: 
34:     bool PatchSelected;
35:     bool FaceSelected;
36:     bool ObjectSelected;
37: 
38:     float TriangleId;
39:     float TileId; 
40:     float MipLevel;
41: 
42:     bool GeoExists;
43: };
44: 
45: struct MriFragmentState
46: {
47:     float AmbientOcclusion;
48: 
49:     vec3 Position;
50:     vec2 UV;
51:     vec3 Normal;
52:     vec3 Tangent;
53:     vec3 Bitangent;
54: 
55:     vec3 NormalInEyeSpaceFromViewCamera;
56:     vec3 TangentInEyeSpaceFromViewCamera;
57:     vec3 BitangentInEyeSpaceFromViewCamera;
58:     vec3 ViewVectorInEyeSpaceFromViewCamera;
59:     vec3 FragmentPositionInEyeSpaceFromViewCamera;
60: 
61:     vec3 NormalInEyeSpaceFromProjectionCamera;
62:     vec3 TangentInEyeSpaceFromProjectionCamera;
63:     vec3 BitangentInEyeSpaceFromProjectionCamera;
64:     vec3 ViewVectorInEyeSpaceFromProjectionCamera;
65: 
66:     vec3 FragmentPositionInEyeSpaceFromProjectionCamera;
67:     vec3 FragmentPositionInNdcSpaceFromProjectionCamera;
68: 
69:     float PatchId;
70:     int   FaceId;
71:     int   FaceIndex;
72: };
73: 
74: struct Channel
75: {
76:     // r - int index; 
77:     // g - bool active;
78:     // b - bool invert;
79:     ivec3 ChannelValues;
80:     // a - reserved
81: };
82: 
83: #if defined( USE_DEPTH_PROJECTIONS)
84: struct MriLight
85: {
86:     int depthProjectorIndex;
87:     int depthProjectorCount;
88: };
89: 
90: struct MriDepthProjection
91: {
92:     mat4 transform;
93: };
94: #endif
95: 
96: 
97: //Gives the true texture coordinates for the base texture
98: vec2 svt_coords(vec2 coords);
99: 
100: //This function gives the raw color value from the texture in Base channel without any filters or projection applied 
101: vec4 svt_texture(Channel Base, vec2 coords);
102: vec4 svt_texture(Channel Base, in MriFragmentState State, in MriSystemFragmentState _State);
103: 
104: //Collect height values from bump map
105: vec4 get_heights(Channel Base, vec2 coords);
106: 
107: //This function gives the color value from the texture in Base channel with some filters and projection applied if applicable
108: vec4 texture_lookup(Channel Base, vec2 coords);
109: 
110: //texture look up function for version 2.0
111: vec4 texture_lookup2(Channel Base, in MriFragmentState State, in MriSystemFragmentState _State);
112: 
113: float tex_mip_level(vec2 coord);
114: 
115: //Default shadow casting function
116: float mriLightVisibility( in int LightIndex, vec3 FragmentPosition);
117: 
118: //Functions for evaluating values with a bit of UV offset.
119: float dFdu(float F);
120: float dFdv(float F);
121: vec2 dFdu(vec2 F);
122: vec2 dFdv(vec2 F);
123: mat2 dFd(vec2 F);
124: vec3 dFdu(vec3 F);
125: vec3 dFdv(vec3 F);
126: mat2x3 dFd(vec3 F);
127: 
128: float F(float f0, vec2 dUV);
129: vec2 F(vec2 f0, vec2 dUV);
130: vec3 F(vec3 f0, vec2 dUV);
131: 
132: void apply_projection_masks(inout MriFragmentState State, inout MriSystemFragmentState _State);
133: 
134: void evaluate_shader_network(inout MriFragmentState State, inout MriSystemFragmentState _State);
135: 
136: 
137: #define MRI_LIGHT_ARRAY_SIZE 4
138: 
139: // DO NOT CHANGE this structure with out adjusting the uniform upload C++ code.
140: struct MriLightSource
141: {
142:     vec4 Position;
143: 
144:     vec4 AmbientColor;
145:     vec4 DiffuseColor;
146:     vec4 SpecularColor;
147: 
148:     float SpotCutoff;
149:     float SpotExponent;
150: 
151:     float ConstantAttenuation;
152:     float LinearAttenuation;
153:     float QuadraticAttenuation;
154: };
155: 
156: // Returns the lighting value to use from the external environment map
157: //  shapness - how clear or blurred the light source is
158: //   0.0 - Totally blurred light sources. same as using dot( normal, light) calculation
159: //   1.0 - Totally sharp
160: vec3 mriEnvironmentLight( in vec3 normal, in float sharpness);
161: bool mriEnvironmentLightOn();
162: 
163: 
164: float mriBRDF_sqr(float x);
165: 
166: float mriBRDF_SchlickFresnel(float u);
167: float mriBRDF_GTR1(float NdotH, float a);
168: float mriBRDF_GTR2(float NdotH, float a);
169: float mriBRDF_GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay);
170: float mriBRDF_smithG_GGX(float Ndotv, float alphaG);
171: vec3 mriBRDF_mon2lin(vec3 x);
172: 
173: 
174: ////////////////////////////////////////////////////////////////////////////////
175: // Custom BRDF Function Library Extension Registration
176: // Copyright (c) 2014 Antonio Lisboa M. Neto. All Rights Reserved.
177: //////////////////////////////////////////////////////////////////////////////// 
178: // File: BRDF_FunctionLib_ext.glslc	
179: // Description: Function Library Extension for be used in the new Custom BRDF Shaders
180: ////////////////////////////////////////////////////////////////////////////////               	
181: // Author: Antonio Neto       	
182: // Web: www.netocg.blogspot.com			
183: // Email: netocg.fx@gmail.com
184: ////////////////////////////////////////////////////////////////////////////////			                                   	
185: // Date: Jan 25, 2014	         		
186: ////////////////////////////////////////////////////////////////////////////////
187: 
188: float att(vec3 L, int Light_Falloff, float Decay_Rate);
189: float color_toValue(vec3 Color);
190: vec3 pow_RGB(vec3 Color, float Value);
191: vec3 convert_Colorspace(vec3 color, int Colorspace_Profile);
192: float mriBRDF_Fresnel(vec3 L, vec3 H, float eta);
193: float mriBRDF_Fresnel_Schlicks(vec3 L, vec3 H, float Reflectance);
194: float mriBRDF_Fresnel_Dielectric(vec3 L, vec3 H, float ior);
195: float mriBRDF_Fresnel_Conductor(vec3 L, vec3 H, float eta, float k);
196: float nfresnel(float cos_theta_r, float eta);
197: float mriBRDF_Oren_Nayar(vec3 N, vec3 V, vec3 L, float difrough2);
198: float mriBRDF_Beckman(vec3 N, vec3 H, float specrough2);
199: float mriBRDF_Geo_att_Cook_Torrance(vec3 N, vec3 H, vec3 V, vec3 L);
200: float mriBRDF_Ward(vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specrough2);
201: float mriBRDF_Geo_att_Ward_Duer( vec3 L, vec3 V, vec3 N, vec3 H);
202: float mriBRDF_Ashikhmin_Shirley( vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specrough2);
203: float mriBRDF_Geo_Att_Ash_Sh00( vec3 N, vec3 V, vec3 L);
204: float mriBRDF_Blinn(vec3 N, vec3 H, float specrough2);
205: float mriBRDF_Geo_att_Schlick_Smith(vec3 N, vec3 L, vec3 V, float specrough2);
206: float mriBRDF_Phong(vec3 N, vec3 V, vec3 H, float specrough2);
207: float mriBRDF_Geo_att_Beckmann(vec3 N, vec3 V, float specrough2);
208: float mriBRDF_GTR(vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specGloss, float ggxTailFalloff);
209: float mriBRDF_Geo_att_smithG_GGX(float NdotV, float specGloss);
210: 
211: /****************************************************************************
212: * Camera information
213: *****************************************************************************/
214: // camera type of the current view
215: // 0 - Perspective
216: // 1 - Ortho
217: // 2 - UV
218: uniform int u_MriViewType;
219: 
220: // x:left, y:top, z:right, w:bottom
221: uniform vec4 u_MriViewport;
222: 
223: /****************************************************************************
224: * Matrices
225: *****************************************************************************/
226: uniform mat4 u_MriViewMatrix;
227: uniform mat4 u_MriModelViewMatrix;
228: uniform mat4 u_MriProjectionMatrix;
229: uniform mat4 u_MriNormalMatrix;
230: 
231: /****************************************************************************
232: * Object information
233: *****************************************************************************/
234: uniform int u_MriObjectId;
235: uniform vec3 u_MriObjectCenter;
236: uniform float u_MriObjectRadius;
237: 
238: /****************************************************************************
239: * Light information
240: *****************************************************************************/
241: //Lighting mode
242: // 0 - Flat
243: // 1 - Basic (Diffuse only)
244: // 2 - Full
245: uniform int u_MriLightingMode;
246: 
247: uniform MriLightSource u_MriLightSources[MRI_LIGHT_ARRAY_SIZE];
248: 
249: /****************************************************************************
250: * Misc
251: *****************************************************************************/
252: // The current animation frame
253: uniform int u_MriCurrentFrame;
254: 
255: // The system time in milliseconds. Will wrap every ~70 minutes.
256: uniform int u_MriSystemTime;
257: 
258: uniform vec2 u_MriMaxSupportedTextureSize;
259: 
260: 
261: 
262: float mriColorBlend(float pixel, float fPixel, float bPixel, float fAlpha, float bAlpha, int normal);
263: vec3 mriColorBlendv(vec3 modifiedColor, vec3 layerColor, vec3 baseColor, float layerAlpha, float baseAlpha, int normal);
264: float mriAlphaBlend( float fAlpha, float bAlpha);
265: float mriRgb2Lightness(vec4 RGBA);
266: vec4 mriRgb2Hsl(vec4 colorIn);
267: vec4 mriHsl2Rgb(vec4 colorIn);
268: vec4 mriRgb2Hsv(vec4 colorIn);
269: vec4 mriHsv2Rgb(vec4 colorIn);
270: 
271: vec4 Comp_Add(vec4 base,vec4 blend,float Opacity);
272: vec4 Comp_BurnHighlights(vec4 base,vec4 blend,float Opacity);
273: vec4 Comp_BurnMidrange(vec4 base,vec4 blend,float Opacity);
274: vec4 Comp_BurnShadows(vec4 base,vec4 blend,float Opacity);
275: vec4 Comp_Clear(vec4 base,vec4 blend,float Opacity);
276: vec4 Comp_Color(vec4 base,vec4 blend,float Opacity);
277: vec4 Comp_ColorBurn(vec4 base,vec4 blend,float Opacity);
278: vec4 Comp_ColorDodge(vec4 base,vec4 blend,float Opacity);
279: vec4 Comp_Copy(vec4 base,vec4 blend,float Opacity);
280: vec4 Comp_CopyRGB(vec4 base,vec4 blend,float Opacity);
281: vec4 Comp_Darken(vec4 base,vec4 blend,float Opacity);
282: vec4 Comp_Default(vec4 base,vec4 blend,float Opacity);
283: vec4 Comp_Difference(vec4 base,vec4 blend,float Opacity);
284: vec4 Comp_DodgeHighlights(vec4 base,vec4 blend,float Opacity);
285: vec4 Comp_DodgeMidrange(vec4 base,vec4 blend,float Opacity);
286: vec4 Comp_DodgeShadows(vec4 base,vec4 blend,float Opacity);
287: vec4 Comp_Exclusion(vec4 base,vec4 blend,float Opacity);
288: vec4 Comp_HardLight(vec4 base,vec4 blend,float Opacity);
289: vec4 Comp_HardMix(vec4 base,vec4 blend,float Opacity);
290: vec4 Comp_Hue(vec4 base,vec4 blend,float Opacity);
291: vec4 Comp_InverseDifference(vec4 base,vec4 blend,float Opacity);
292: vec4 Comp_Invert(vec4 base,vec4 blend,float Opacity);
293: vec4 Comp_Lighten(vec4 base,vec4 blend,float Opacity);
294: vec4 Comp_Luminance(vec4 base,vec4 blend,float Opacity);
295: vec4 Comp_Multiply(vec4 base,vec4 blend,float Opacity);
296: vec4 Comp_Overlay(vec4 base,vec4 blend,float Opacity);
297: vec4 Comp_PinLight(vec4 base,vec4 blend,float Opacity);
298: vec4 Comp_Saturation(vec4 base,vec4 blend,float Opacity);
299: vec4 Comp_Screen(vec4 base,vec4 blend,float Opacity);
300: vec4 Comp_SoftLight(vec4 base,vec4 blend,float Opacity);
301: vec4 Comp_SpongeDesaturate(vec4 base,vec4 blend,float Opacity);
302: vec4 Comp_VividLight(vec4 base,vec4 blend,float Opacity);
303: vec4 Comp_Contrast(vec4 base,vec4 blend,float Opacity);
304: vec4 Comp_Decontrast(vec4 base,vec4 blend,float Opacity);
305: vec4 Comp_MixRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
306: vec4 Comp_AddRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
307: vec4 Comp_ReorientedNormalMappingRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
308: 
309: // Blending functions the operate on the color channels only. Used by things such as color adjustments where the alpha channel needs to be ignored.
310: vec4 Comp_Default(vec4 Base, vec3 Blend, float Amount);
311: vec4 Comp_Add(vec4 Base, vec3 Blend, float Amount);
312: vec4 Comp_Color(vec4 Base, vec3 Blend, float Amount);
313: vec4 Comp_Copy(vec4 Base, vec3 Blend, float Amount);
314: vec4 Comp_CopyRGB(vec4 Base, vec3 Blend, float Amount);
315: vec4 Comp_Darken(vec4 Base, vec3 Blend, float Amount);
316: vec4 Comp_Difference(vec4 Base, vec3 Blend, float Amount);
317: vec4 Comp_Hue(vec4 Base, vec3 Blend, float Amount);
318: vec4 Comp_InverseDifference(vec4 Base, vec3 Blend, float Amount);
319: vec4 Comp_Lighten(vec4 Base, vec3 Blend, float Amount);
320: vec4 Comp_Luminance(vec4 Base, vec3 Blend, float Amount);
321: vec4 Comp_Multiply(vec4 Base, vec3 Blend, float Amount);
322: vec4 Comp_Saturation(vec4 Base, vec3 Blend, float Amount);
323: 
324: vec4 Comp_VecDefault2d(vec4 base,vec4 blend,float Opacity);
325: vec4 Comp_VecDefault3d(vec4 base,vec4 blend,float Opacity);
326: 
327: vec4 Comp_VecAdd3d(vec4 base,vec4 blend,float Opacity);
328: vec4 Comp_VecAdd2d(vec4 base,vec4 blend,float Opacity);
329: 
330: vec4 Comp_VecScale3d(vec4 base,vec4 blend,float Opacity);
331: 
332: //! macro | custom_blend_mode_declarations | // No custom blend modes
333: 
334: 
335: 
336: 
337: //Curve lookup functions
338: 
339: float mriCurveLookup( in int Line, in float InValue);
340: 
341: 
342: 
343: 
344: /****************************************************************************
345: * Noise functions
346: *****************************************************************************/
347: 
348: //These functions generate Perlin and Simplex noise from 2D,3D,4D inputs
349: float mriPerlinNoise(vec2 P);
350: float mriPerlinNoise(vec3 P);
351: float mriPerlinNoise(vec4 P);
352: float mriSimplexNoise(vec2 P);
353: float mriSimplexNoise(vec3 P);
354: float mriSimplexNoise(vec4 P);
355: 
356: // DEPRECATED in favor of more explicit function names above
357: float mriNoise(vec3 P); 
358: 
359: 
360: //Cellular (Worley) noise generation function based on 3D input and different types of norm(distance) calculation. This returns vec3 in which F1, F2 and F1-F2 are returned in r, g and b of the resulting vec3 respectively. Cellular noise is a noise obtained by calculating distance to randomly generated points. The definition of the distance is the norm. F1 is the distance to the closest point while F2 is the distance to the 2nd closest point.  
361: // norm - The norm(distance calculation) definition to use. 
362: //  0 : Manhattan norm
363: //  1 : Euclidian norm
364: //  2 : Chebyshev(Infinity) norm
365: //  3 : P-norm where P=0.5
366: vec3 mriCellular(vec3 P, int norm);
367: 
368: // DEPRECATED
369: // These functions are provided for backward compatibility since the older version of Mari had these.
370: // These are deprecated and to be removed in favor of more explicitly named functions above.
371: float noise(vec3 P);
372: vec3 cellular(vec3 P, int norm);
373: 
374: 
375: 
376: 
377: //Given the face index at the evaluation point (usually the fragment), this returns hiddenness, lockedness and selectedness of the face in r,g and b respectively.
378: //the a component is currently not used, but reserved for the future usage
379: vec4 mriFaceSystemAttribute(int FaceIndex);
380: 
381: //Given the primitiveID, returns the face index of the original mesh
382: int mriFaceIndex(int PrimitiveID);
383: 
384: 
385: 
386: /****************************************************************************
387: * Misc
388: *****************************************************************************/
389: //This is an untility function to do the implementation of how to interpret a given color value as a mask. Whoever needs to regard some color value as mask should call this function for consistent mechanism
390: float interpretAsExposure(in vec4 Color,int Mode);
391: 
392: 
393: 
394: 
395: // Function for handling standard Vector Painting Maths
396: 
397: vec3 vector_bias( vec3 vector);
398: vec3 vector_unbias( vec3 colour);
399: 
400: vec3 vector_paintToTangent3D( vec3 screen);
401: vec3 vector_paintToTangent2D( vec3 screen);
402: 
403: vec3 vector_worldToTangent( vec3 tangent);
404: vec3 vector_tangentToWorld( vec3 tangent);
405: vec3 vector_tangentToScreen( vec3 tangent);
406: 
407: 
408: 
409: //! macro | module_inputs | // No Module Inputs
410: //! macro | module_calls  | // No Module Calls
411: //! macro | module_declarations  | // No Module Declarations
412: 
413: //! macro | surface_mask_declarations | // No mask applied
414: //! macro | surface_mask_body         | // No mask applied
415: 
416: uniform int udim_size;
417: 
418: void store_state(inout MriFragmentState State, inout MriSystemFragmentState _State);
419: void derive_state(inout MriFragmentState State, inout MriSystemFragmentState _State, float du, float dv);
420: void restore_state(inout MriFragmentState State, inout MriSystemFragmentState _State);
421: 
422: #define REVAL(func,du,dv) store_state(State, _State);derive_state(State, _State, du, dv);func(State,_State);restore_state(State, _State);
423: 
424: 
425: 
426: float olefresnel(float r, float g, float c);
427: float get_n(float r,float g);
428: float get_k2(float r, float n);
429: float n_min(float r);
430: float n_max(float r);
431: vec3 FresnelConductor(vec3 Refelctivity, vec3 EdgeTint,float cos_theta);//=====================
432: // Forward Declaration of functions
433: //=====================
434: 
435: void node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
436: void node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
437: void node_516e4503_ea09_4104_8e31_2e667c820272_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
438: void node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
439: void node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
440: void node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
441: void node_45b7815b_0361_452e_b5c5_f476cf68940f_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
442: void node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
443: void node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
444: void node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
445: void node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
446: void node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
447: void node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
448: void node_83662364_52db_4f7b_b336_baca232fc310_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
449: 
450: //=====================
451: // Declaration of functions
452: //=====================
453: 
454: //=====================
455: //--- Style 2 Node 'Bottom Transparency' ---
456: //=====================
457: vec4 node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output; // Output 'Output' 
458: void node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
459: {
460:     vec4 Output; // Output 'Output' 
461: 
462:     Output = vec4( 0, 0, 0, 0);
463:         
464:     node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output = Output;
465: }
466: 
467: //=====================
468: //--- Style 2 Node 'Paint 3' ---
469: //=====================
470: uniform Channel Channel_node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_;
471: vec4 node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output; // Output 'Output' 
472: void node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
473: {
474:     vec4 Output; // Output 'Output' 
475: 
476:                   
477:         Output = texture_lookup2(Channel_node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_,State,_State);
478:                   
479:               
480:     node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output = Output;
481: }
482: 
483: //=====================
484: //--- Style 2 Node 'Merge_Bump_Head' ---
485: //=====================
486: uniform int AdvancedEnabled_node_516e4503_ea09_4104_8e31_2e667c820272_;
487: uniform float Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
488: uniform int AmountEnabled_node_516e4503_ea09_4104_8e31_2e667c820272_;
489: uniform int BlendIfBelow_node_516e4503_ea09_4104_8e31_2e667c820272_;
490: uniform int BlendIfThis_node_516e4503_ea09_4104_8e31_2e667c820272_;
491: uniform int BlendMode_node_516e4503_ea09_4104_8e31_2e667c820272_;
492: uniform int Component_node_516e4503_ea09_4104_8e31_2e667c820272_;
493: uniform int SwizzleA_node_516e4503_ea09_4104_8e31_2e667c820272_;
494: uniform int SwizzleB_node_516e4503_ea09_4104_8e31_2e667c820272_;
495: uniform int SwizzleG_node_516e4503_ea09_4104_8e31_2e667c820272_;
496: uniform int SwizzleR_node_516e4503_ea09_4104_8e31_2e667c820272_;
497: vec4 node_516e4503_ea09_4104_8e31_2e667c820272_Output; // Output 'Output' 
498: void node_516e4503_ea09_4104_8e31_2e667c820272_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
499: {
500:     vec4 Output; // Output 'Output' 
501: 
502:     if( 0 != 0)
503:     {
504:         // this is used to control what component we are pulling the key from
505:         vec3 Mult[5];
506: 
507:         Mult[0] = vec3(1.0/3.0,1.0/3.0,1.0/3.0);
508:         Mult[1] = vec3(1,0,0);
509:         Mult[2] = vec3(0,1,0);
510:         Mult[3] = vec3(0,0,1);
511:         Mult[4] = vec3(0.2126,0.7152,0.0722);
512: 
513: 
514:         // Calculate the amount from the component
515:         // a Mult value of (1,0,0) will isolate the red value
516:         // A mult value of (1,1,1) will give a gray scale
517: 
518:         float ThisAmount = dot(node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output.rgb , Mult[0]);
519:         float BelowAmount = dot(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output.rgb , Mult[0]);
520: 
521:         // now that we've pulled the component out of above and below
522:         // we lookup into the lut to find out the amount to scale the alpha values by
523: 
524:         float ThisAlpha  = mriCurveLookup(BlendIfThis_node_516e4503_ea09_4104_8e31_2e667c820272_,ThisAmount);
525:         float BelowAlpha = mriCurveLookup(BlendIfBelow_node_516e4503_ea09_4104_8e31_2e667c820272_,BelowAmount);
526: 
527:         // now we multiply the base alpha value by both values
528: 
529:         float AdvancedBlendAmount = ThisAlpha * BelowAlpha;
530:         if( 0 != 1)
531:         {
532:             AdvancedBlendAmount *= Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
533:         }
534: 
535:         Output = Comp_Default(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output, node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output, vec4(1,1,1,1).r * AdvancedBlendAmount);
536:     }
537:     else
538:     {
539:         float BlendAmount = 1;
540:         if( 0 != 1)
541:         {
542:             BlendAmount *= Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
543:         }
544:         Output = Comp_Default(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output, node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output, BlendAmount * vec4(1,1,1,1).r);
545:     }
546: 
547:     Output = vec4( Output.r, Output.g, Output.b, Output.a);
548: 
549:                 
550:     node_516e4503_ea09_4104_8e31_2e667c820272_Output = Output;
551: }
552: 
553: //=====================
554: //--- Style 2 Node 'Paint 4' ---
555: //=====================
556: uniform Channel Channel_node_5ab26bd0_71fd_473d_ba94_940da940e2a5_;
557: vec4 node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output; // Output 'Output' 
558: void node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
559: {
560:     vec4 Output; // Output 'Output' 
561: 
562:                   
563:         Output = texture_lookup2(Channel_node_5ab26bd0_71fd_473d_ba94_940da940e2a5_,State,_State);
564:                   
565:               
566:     node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output = Output;
567: }
568: 
569: //=====================
570: //--- Style 2 Node 'Layer' ---
571: //=====================
572: uniform int AdvancedEnabled_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
573: uniform float Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
574: uniform int AmountEnabled_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
575: uniform int BlendIfBelow_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
576: uniform int BlendIfThis_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
577: uniform int BlendMode_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
578: uniform int Component_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
579: uniform int SwizzleA_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
580: uniform int SwizzleB_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
581: uniform int SwizzleG_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
582: uniform int SwizzleR_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
583: vec4 node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output; // Output 'Output' 
584: void node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
585: {
586:     vec4 Output; // Output 'Output' 
587: 
588:     if( 0 != 0)
589:     {
590:         // this is used to control what component we are pulling the key from
591:         vec3 Mult[5];
592: 
593:         Mult[0] = vec3(1.0/3.0,1.0/3.0,1.0/3.0);
594:         Mult[1] = vec3(1,0,0);
595:         Mult[2] = vec3(0,1,0);
596:         Mult[3] = vec3(0,0,1);
597:         Mult[4] = vec3(0.2126,0.7152,0.0722);
598: 
599: 
600:         // Calculate the amount from the component
601:         // a Mult value of (1,0,0) will isolate the red value
602:         // A mult value of (1,1,1) will give a gray scale
603: 
604:         float ThisAmount = dot(node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output.rgb , Mult[0]);
605:         float BelowAmount = dot(node_516e4503_ea09_4104_8e31_2e667c820272_Output.rgb , Mult[0]);
606: 
607:         // now that we've pulled the component out of above and below
608:         // we lookup into the lut to find out the amount to scale the alpha values by
609: 
610:         float ThisAlpha  = mriCurveLookup(BlendIfThis_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_,ThisAmount);
611:         float BelowAlpha = mriCurveLookup(BlendIfBelow_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_,BelowAmount);
612: 
613:         // now we multiply the base alpha value by both values
614: 
615:         float AdvancedBlendAmount = ThisAlpha * BelowAlpha;
616:         if( 0 != 1)
617:         {
618:             AdvancedBlendAmount *= Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
619:         }
620: 
621:         Output = Comp_Default(node_516e4503_ea09_4104_8e31_2e667c820272_Output, node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output, vec4(1,1,1,1).r * AdvancedBlendAmount);
622:     }
623:     else
624:     {
625:         float BlendAmount = 1;
626:         if( 0 != 1)
627:         {
628:             BlendAmount *= Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
629:         }
630:         Output = Comp_Default(node_516e4503_ea09_4104_8e31_2e667c820272_Output, node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output, BlendAmount * vec4(1,1,1,1).r);
631:     }
632: 
633:     Output = vec4( Output.r, Output.g, Output.b, Output.a);
634: 
635:                 
636:     node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output = Output;
637: }
638: 
639: //=====================
640: //--- Style 2 Node 'Bump_Head' ---
641: //=====================
642: vec4 node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output; // Output 'Output' 
643: void node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
644: {
645:     vec4 Output; // Output 'Output' 
646: 
647:     Output = node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output;
648:                 
649:     node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output = Output;
650: }
651: 
652: //=====================
653: //--- Style 2 Node 'Current Channel' ---
654: //=====================
655: vec4 node_45b7815b_0361_452e_b5c5_f476cf68940f_Output; // Output 'Output' 
656: void node_45b7815b_0361_452e_b5c5_f476cf68940f_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
657: {
658:     vec4 Output; // Output 'Output' 
659: 
660:     Output = node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output;
661:                 
662:     node_45b7815b_0361_452e_b5c5_f476cf68940f_Output = Output;
663: }
664: 
665: //=====================
666: //--- Style 2 Node 'alSurfaceX/Height As Normal' ---
667: //=====================
668: uniform int BumpMode_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_;
669: uniform float BumpWeight_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_;
670: vec4 node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output; // Output 'Output' 
671: void node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
672: {
673:     vec4 Output; // Output 'Output' 
674: 
675:     // distance in texture space [0,1] between adjacent pixels at this mip level
676:     float Offset = exp2(_State.MipLevel)/u_MriMaxSupportedTextureSize.x;
677: 
678:     float BumpWeight = BumpWeight_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_/Offset;
679: 
680: 
681: #if 0
682:     // fudge factor
683:     BumpWeight *= 1.0/(30.0 * 16.0);
684: 
685:     // Bump mapping version A
686:     //Default Input Used : NO REVAL(Heightfunc,-Offset,0.0);
687:     float l=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
688: 
689:     //Default Input Used : NO REVAL(Heightfunc,Offset,0.0);
690:     float r=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
691: 
692:     //Default Input Used : NO REVAL(Heightfunc,0.0,-Offset);
693:     float b=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
694: 
695:     //Default Input Used : NO REVAL(Heightfunc,0.0,Offset);
696:     float t=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
697: 
698:     vec2 heightDelta = vec2( l - r, b - t);
699: #else
700:     // fudge factor
701:     BumpWeight *= 2.0/(30.0 * 16.0);
702: 
703:     // Bump mapping version A
704:     float c=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
705: 
706:     //Default Input Used : NO REVAL(Heightfunc,Offset,0.0);
707:     float r=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
708: 
709:     //Default Input Used : NO REVAL(Heightfunc,0.0,Offset);
710:     float t=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
711: 
712:     vec2 heightDelta = vec2( c - r, c - t);
713: #endif
714: 
715:     Output.rgb = normalize( vec3(heightDelta,1.0) ) * vec3(0.5,-0.5,0.5) + vec3(0.5); 
716:     Output.a = 1.0; 
717:                 
718:     node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output = Output;
719: }
720: 
721: //=====================
722: //--- Style 2 Node 'alSurfaceX/Normal Modulation' ---
723: //=====================
724: vec4 node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output; // Output 'Output' 
725: void node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
726: {
727:     vec4 Output; // Output 'Output' 
728: 
729:         vec3 norm = vec3(0.0, 0.0, 0.0);
730:         vec3 norm0 = vec4(0.5,0.5,1.0,1.0).rgb * 2.0 -1.0;
731:         vec3 norm1 = node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output.rgb * 2.0 - 1.0;
732: 
733:         norm += dot(norm0.xy,norm0.xy)>0.0 ? norm0  : vec3(0.0);
734:         norm += dot(norm1.xy,norm1.xy)>0.0 ? norm1  : vec3(0.0);
735: 
736:         //When there is no bump/normal, set it to default
737:         norm = dot(norm,norm)>0.0 ? norm  : vec3(0.0,0.0,1.0);
738: 
739:         Output.rgb = normalize(norm);
740:         Output.a = 1.0;
741:                 
742:     node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output = Output;
743: }
744: 
745: //=====================
746: //--- Style 2 Node 'alSurfaceX/Tangent Space To Eye Space' ---
747: //=====================
748: vec4 node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output; // Output 'Output' 
749: void node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
750: {
751:     vec4 Output; // Output 'Output' 
752: 
753:     mat3 tangentSpace2eyeSpace = mat3(
754:         State.TangentInEyeSpaceFromViewCamera,
755:         State.BitangentInEyeSpaceFromViewCamera,
756:         State.NormalInEyeSpaceFromViewCamera
757:     );
758:     Output.rgb = normalize( tangentSpace2eyeSpace * (node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output.rgb * vec3( 1,-1,1)));
759:     Output.a = node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output.a;
760:                 
761:     node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output = Output;
762: }
763: 
764: //=====================
765: //--- Style 2 Node 'alSurfaceX/Color To Vector' ---
766: //=====================
767: vec4 node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output; // Output 'Output' 
768: void node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
769: {
770:     vec4 Output; // Output 'Output' 
771: 
772:         vec3 norm = (vec4(1.0,0.5,0.5,1.0).rgb * 2.0) - 1.0;
773: 
774:         Output.rgb = norm;
775:         Output.a = 1.0;
776:                 
777:     node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output = Output;
778: }
779: 
780: //=====================
781: //--- Style 2 Node 'alSurfaceX/Tangent Space To Eye Space 2' ---
782: //=====================
783: vec4 node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output; // Output 'Output' 
784: void node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
785: {
786:     vec4 Output; // Output 'Output' 
787: 
788:     mat3 tangentSpace2eyeSpace = mat3(
789:         State.TangentInEyeSpaceFromViewCamera,
790:         State.BitangentInEyeSpaceFromViewCamera,
791:         State.NormalInEyeSpaceFromViewCamera
792:     );
793:     Output.rgb = normalize( tangentSpace2eyeSpace * (node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output.rgb * vec3( 1,-1,1)));
794:     Output.a = node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output.a;
795:                 
796:     node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output = Output;
797: }
798: 
799: //=====================
800: //--- Style 2 Node 'alSurfaceX/Set Unlit' ---
801: //=====================
802: vec4 node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output; // Output 'Output' 
803: void node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
804: {
805:     vec4 Output; // Output 'Output' 
806: 
807: 
808:     _State.Unlit = ((_State.Unlit.a==0.0) ? node_45b7815b_0361_452e_b5c5_f476cf68940f_Output : _State.Unlit);
809:     Output = node_45b7815b_0361_452e_b5c5_f476cf68940f_Output;
810:                 
811:     node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output = Output;
812: }
813: 
814: //=====================
815: //--- Style 2 Node 'alSurfaceX/' ---
816: //=====================
817: uniform float AmbientOcclusion_node_83662364_52db_4f7b_b336_baca232fc310_;
818: uniform vec4 BacklightColor_node_83662364_52db_4f7b_b336_baca232fc310_;
819: uniform float BacklightIndirectStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
820: uniform float BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
821: uniform bool ConvertToGlossiness_node_83662364_52db_4f7b_b336_baca232fc310_;
822: uniform float Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_;
823: uniform vec4 DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_;
824: uniform float DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
825: uniform float DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
826: uniform vec4 EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
827: uniform float EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
828: uniform int Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_;
829: uniform vec4 Opacity_node_83662364_52db_4f7b_b336_baca232fc310_;
830: uniform int Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_;
831: uniform vec4 SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_;
832: uniform vec4 SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_;
833: uniform float SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_;
834: uniform bool Solid_node_83662364_52db_4f7b_b336_baca232fc310_;
835: uniform float Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
836: uniform vec4 Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
837: uniform vec4 Specular1EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_;
838: uniform int Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_;
839: uniform float Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_;
840: uniform vec4 Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_;
841: uniform float Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
842: uniform float Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
843: uniform float Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;
844: uniform float Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
845: uniform vec4 Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_;
846: uniform vec4 Specular2EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_;
847: uniform int Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_;
848: uniform float Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_;
849: uniform vec4 Specular2Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_;
850: uniform float Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
851: uniform float Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
852: uniform float Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_;
853: uniform vec4 TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
854: uniform float TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_;
855: uniform bool TransmissionLinkToSpecular1_node_83662364_52db_4f7b_b336_baca232fc310_;
856: uniform float TransmissionRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
857: uniform float TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
858: uniform int shadingNode_node_83662364_52db_4f7b_b336_baca232fc310_;
859: vec4 node_83662364_52db_4f7b_b336_baca232fc310_Output; // Output 'Output' 
860: void node_83662364_52db_4f7b_b336_baca232fc310_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
861: {
862:     vec4 Output; // Output 'Output' 
863: 
864: 	shadingNode_node_83662364_52db_4f7b_b336_baca232fc310_; 
865: 	// Used for continually Mark what shader you are using in case you have renamed the name of the shader inside Mari. This var is also used for the exporter to identify what shader he is picking.
866: 	
867: 	DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_;
868: 	DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
869: 	Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
870: 	Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
871: 	Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
872: 	Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
873: 	Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_;
874: 	Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
875: 	Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
876: 	Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
877: 	Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
878: 	TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
879: 	TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
880: 	TransmissionRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
881: 	Opacity_node_83662364_52db_4f7b_b336_baca232fc310_;
882: 	SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_;
883: 	SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_;
884: 	EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;	
885: 	
886: 	// These control/input pairs are alpha blended together.
887: 	// If the Channel has an input connected the input is used.	
888: 	// Else the attribute slider is used instead.
889: 	// VAR Name   			 'mix' based on existence of an alpha in the channels	
890: 	vec3 difCol	   			= mix( vec3(0),		vec4(DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,		vec4(DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
891: 	vec3 specCol1  			= mix( vec3(0),		vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
892: 	vec3 specCol2  			= mix( vec3(0),		vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
893: 	vec3 reflCol1  			= mix( vec3(0),		vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
894: 	vec3 reflCol2  			= mix( vec3(0),		vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
895: 	vec3 refrCol  			= mix( vec3(0),		vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
896: 	vec3 transCol 			= mix( vec3(0),		vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
897: 	vec3 sssCol	   			= mix( vec3(0),		vec4(SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb, 			vec4(SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a				== 0 ? 0 : 1);
898: 	vec3 sssRadius 			= mix( vec3(0), 	vec4(SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb, 		vec4(SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 			== 0 ? 0 : 1);
899: 	vec3 emisCol   			= mix( vec3(0),		vec4(EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	 	vec4(EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a		== 0 ? 0 : 1);
900: 		
901: 	float difrough 	 		= mix( float(0),	vec4(DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
902: 	float spec1rough 		= mix( float(0),	vec4(Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
903: 	float ani1				= mix( float(0),	vec4(Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
904: 	float rot1 		 		= mix( float(0),	vec4(Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
905: 	float spec2rough 		= mix( float(0),	vec4(Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
906: 	float ani2				= mix( float(0),	vec4(Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
907: 	float rot2 		 		= mix( float(0),	vec4(Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
908: 	float refrarough		= mix( float(0),	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).r,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 	== 0 ? 0 : 1);
909: 	
910: 
911: 	vec3 Current_Channel_Selected = node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output.rgb;
912: 	
913: 	if(ConvertToGlossiness_node_83662364_52db_4f7b_b336_baca232fc310_ == true)
914: 	{
915: 		spec1rough = 1.0 - spec1rough;
916: 		spec2rough = 1.0 - spec2rough;
917: 	}
918: 	
919: 	// Check if there's Color painted at the rgb of the Opacity Channels	
920: 	vec3 opacityCol	 = vec3(0,0,0);
921: 	if (color_toValue(vec4(Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,0).rgb) == 0)
922: 	{
923: 		opacityCol = vec3(1.0) - Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb;
924: 	}
925: 	else
926: 	{
927: 		opacityCol = vec3(1.0) - vec4(Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,0).rgb;	
928: 	}	
929: 	
930: 	// The UV Viewport will display what is the Current Channel Selected, unless you don't have any channel. Then it will display the Mari`s alpha checkerboard pattern.	
931: 	if(u_MriViewType==2 || u_MriLightingMode==0)
932: 	{
933: 		// This is the cheapest way to use this "viewbuffer" feature, skipping most of the shader calculation.
934: 		
935: 		Output = node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output;		
936: 		
937: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 1)
938: 		{
939: 			Output.rgb = difCol.rgb;
940: 		}
941: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 2)
942: 		{
943: 			Output.rgb = specCol1.rgb;
944: 		}
945: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 3)
946: 		{
947: 			Output.rgb = reflCol1.rgb;
948: 		}
949: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 4)
950: 		{
951: 			Output.rgb = refrCol.rgb;
952: 		}
953: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 5)
954: 		{
955: 			Output.rgb = sssCol.rgb;
956: 		}
957: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 6)
958: 		{
959: 			Output.rgb = emisCol.rgb;
960: 		}
961: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7)
962: 		{
963: 			Output = vec4(0.5,0.5,0.5,0.0);
964: 		}
965: 		
966: 		//Display the Thickness imported image in the UV Viewport
967: 		if(u_MriViewType==2 && Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7) 
968: 		{
969: 			Output = vec4(0.5,0.5,0.5,0.0);			
970: 		}		
971: 	}
972: 	else
973: 	{
974: 		// ------------  All the shader math ------------
975: 		
976: 		const float PI = 3.14159265358979323846264;
977: 		const float TwoPI = 2.0 * PI;
978: 			
979: 		// View Direction
980: 		vec3 V = normalize(-State.ViewVectorInEyeSpaceFromViewCamera);
981: 		// Normal Direction
982: 		vec3 N = normalize(node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output.xyz);
983: 			
984: 		float NdotV = dot(N,V);
985: 		// On the wrong side of the face
986: 		if( NdotV <= 0.0)
987: 		{
988: 			N = -N;
989: 			NdotV = 1.0 - NdotV;
990: 		}
991: 				
992: 		//Enum Light direction
993: 		vec3 L = N;
994: 		// Half Vector
995: 		vec3 H = normalize(L+V);					
996: 		float cos_theta = dot(H,V);
997: 		vec3 RelectionTintColor1 = FresnelConductor(Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,Specular1EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,cos_theta);
998: 		//vec3 RelectionTintColor1 = Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb;
999: 		vec3 RelectionTintColor2 = FresnelConductor(Specular2Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,Specular2EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,cos_theta);
1000: 
1001: 				
1002: 		// Calculates the Space diagonal of the volume inside a cube
1003: 		vec3 viewPos = vec3(1.0);
1004: 		viewPos.x = mix(1, 2*abs(State.Position.x), abs(State.NormalInEyeSpaceFromViewCamera.x) );
1005: 		viewPos.y = mix(1, 2*abs(State.Position.y), abs(State.NormalInEyeSpaceFromViewCamera.y) );
1006: 		viewPos.z = mix(1, 2*abs(State.Position.z), abs(State.NormalInEyeSpaceFromViewCamera.z) );
1007: 		float base_diagonal = sqrt(viewPos.x*viewPos.x+viewPos.z*viewPos.z);
1008: 		float space_diagonal = sqrt(base_diagonal*base_diagonal + viewPos.y*viewPos.y);
1009: 			
1010: 		// Check if there is a texture assigned to the vec4(0.5,0.5,0.5,0.0) attribute, if does, then use it instead of the 1.5 value. 
1011: 		float Thickness = 1.5;	
1012: 		if(vec4(0.5,0.5,0.5,0.0).a > 0)	
1013: 		{
1014: 			Thickness = 1.0 + vec4(0.5,0.5,0.5,0.0).r;		
1015: 		}
1016: 		
1017: 		//Use the Baked texture to mix with the multiplication factors of the "Voxelized calculation method" based on depth of the scene
1018: 		if(u_MriViewType == 0) //gl buffer does not work well in perspective mode
1019: 		{
1020: 			//thickness based on position calculation mixed with obj radius
1021: 			vec3 P = State.Position*u_MriObjectRadius;
1022: 			float d = -dot(State.Position,P);
1023: 			float D = abs(d)/length(P);
1024: 			D /=u_MriObjectRadius;             
1025: 			
1026: 			Thickness *= mix( mix(2, 1, 1-NdotV)*u_MriObjectRadius, space_diagonal, (1-NdotV)*length(D));	
1027: 		}
1028: 		else
1029: 		{
1030: 			//thickness based on depth and obj radius
1031: 			float mult_factor = mix(2*u_MriObjectRadius, u_MriObjectRadius/2, gl_FragDepth);
1032: 			//thickness adjusment for the depth based on the Space diagonal of a cube created for each pixel on face.
1033: 			float mult_factor2 = mix( mix(space_diagonal, 1, (gl_FragDepth*(1-NdotV))), mix(u_MriObjectRadius, 1, (2*abs(gl_FragDepth - 0.5))*(1-NdotV)), 2*abs(gl_FragDepth - 0.5) )*PI; // this PI is just a adjusment to the color values between the two viewports
1034: 			
1035: 			Thickness *= mix(mult_factor, mult_factor2, gl_FragDepth);
1036: 		}	
1037: 		
1038: 				
1039: 		// Roughness attributes squared
1040: 		float difrough2 = difrough*difrough;		
1041: 		float spec1rough2 = spec1rough*spec1rough*spec1rough*spec1rough; // Arnold use a quadratic specrough for cook-torrance only(their wish was to use cubic, but that's expensive they say).	
1042: 		float spec2rough2 = spec2rough*spec2rough*spec2rough*spec2rough;
1043: 		float refrarough2 = refrarough*refrarough*refrarough*refrarough;
1044: 		
1045: 		float _glossiness = 1.0;
1046: 		float _Refra_glossiness = 1.0;
1047: 		float _ani1 = 2*(0.5-ani1); // internal variable to be used as anisotropy for the maths, this changes the anisotropy value to the range -1 and 1 that is used by V-ray and is correct for obtain the correct result from the BRDF Formula.
1048: 		float _ani2 = 2*(0.5-ani2);
1049: 		
1050: 		// IBL Glossiness adaptation to match the BRDF blur or 'spec lobe' for Environment Lighting
1051: 		_glossiness = mix(pow( 1-sqrt(spec1rough2), 2), pow( 1-(spec1rough), 3), 1-spec1rough);
1052: 		_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1053: 		
1054: 		if(_ani1 == 0.0 || spec1rough2 == 0.0) // There is no Anisotropy if the Specular Roughness = 0
1055: 		{
1056: 			_glossiness = pow( mix( 1-spec1rough2, 1-sqrt(spec1rough2), 1-spec1rough), mix(2, 3, 1-spec1rough) );
1057: 			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1058: 		}
1059: 		else
1060: 		{				  
1061: 			_glossiness = pow( mix( (abs(_ani1)/PI+1-sqrt(spec1rough2))/2, (abs(_ani1)+1-sqrt(spec1rough2))/2, 1-spec1rough), mix(1, (abs(_ani1)+1-sqrt(spec1rough2))*1.5, 1-spec1rough) );
1062: 			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1063: 		}
1064: 		
1065: 		// Fresnel var initialization	
1066: 		float F = 1.0;
1067: 		if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1068: 		{
1069: 			F = 0.0;
1070: 		}	
1071: 		
1072: 		// Anisotropic coords
1073: 		vec3 epsilon1 = vec3(0, 1, 0.15);
1074: 		vec3 X1 = vec3(1,0,0);
1075: 		vec3 Y1 = vec3(0,1,0);
1076: 		if(node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.a != 1.0)
1077: 		{
1078: 			X1.x = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.r;
1079: 			Y1.y = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.g;
1080: 		}
1081: 		if(ani1 != 0.5)
1082: 		{		
1083: 			epsilon1 = rot1 < 0.5 ? mix(Y1, X1, 2*rot1) : mix(X1, -Y1, 2*(rot1-0.5) );		
1084: 		}
1085: 				
1086: 		Y1 = normalize(cross(N, epsilon1));
1087: 		X1 = normalize(cross(N, Y1));
1088: 		
1089: 		vec3 epsilon2 = vec3(0, 1, 0.15);
1090: 		vec3 X2 = vec3(1,0,0);
1091: 		vec3 Y2 = vec3(0,1,0);
1092: 		if(node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.a != 1.0)
1093: 		{
1094: 			X2.x = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.r;
1095: 			Y2.y = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.g;
1096: 		}
1097: 		if(ani2 != 0.5)
1098: 		{		
1099: 			epsilon2 = rot2 < 0.5 ? mix(Y2, X2, 2*rot2) : mix(X2, -Y2, 2*(rot2-0.5) );		
1100: 		}
1101: 				
1102: 		Y2 = normalize(cross(N, epsilon2));
1103: 		X2 = normalize(cross(N, Y2));
1104: 
1105: 		// Energy variables initialization for each phase of the light calculation
1106: 		vec3 EnergyDiffuse = vec3(0.0);
1107: 		vec3 EnergyDiffuse_env = vec3(0.0); //avoid diffuse light bounces from lights to the obj
1108: 		vec3 EnergyBacklight = vec3(0.0);
1109: 		vec3 EnergyBacklight_env = vec3(0.0);
1110: 		vec3 EnergySpecular1 = vec3(0.0); //also separete the energy from highlights and reflection(point lights and environment light) also avoids lights bouncees from shader to the direct light sourcers the point lights.
1111: 		vec3 EnergySpecular_env1 = vec3(0.0);
1112: 		vec3 EnergyReflection_env1 = vec3(0.0);
1113: 		vec3 EnergySpecular2 = vec3(0.0); 
1114: 		vec3 EnergySpecular_env2 = vec3(0.0); 
1115: 		vec3 EnergyReflection_env2 = vec3(0.0);
1116: 		vec3 EnergyRefraction_env = vec3(0.0);
1117: 		vec3 EnergyTransmittance = vec3(1.0);
1118: 		vec3 EnergySSS = vec3(0.0);
1119: 		vec3 EnergySSS_env = vec3(0.0); //avoid SSS light bounces from lights to the obj
1120: 		vec3 EnergyOpacity_env = vec3(0.0);
1121: 		
1122: 		vec3 LightColour = vec3(0.0);
1123: 		float diffterm = 0.0;
1124: 		float specterm = 0.0;
1125: 		float specterm2 = 0.0;
1126: 		float refraterm = 0.0;
1127: 		vec3 _Absorbance = vec3 (1.0);
1128: 		
1129: 		
1130: 		
1131: 		for(int i=0;i<4;i++)
1132: 		{
1133: 			if( vec3( 0) == u_MriLightSources[i].DiffuseColor.rgb && vec3( 0) == u_MriLightSources[i].SpecularColor.rgb)
1134: 			{
1135: 				continue;
1136: 			}
1137: 
1138: 			float lightVisibility = mriLightVisibility( i, State.Position);		
1139: 			
1140: 			// Light Direction			
1141: 			vec3 L = normalize(u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera);
1142: 			vec3 LdistP = u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera;	
1143: 			
1144: 			// Half Vector
1145: 			vec3 H = normalize(L+V);		
1146: 			
1147: 			float LdotN = dot(L,N);		
1148: 			{			
1149: 				// ----------DIFFUSE TERM-----------
1150: 				// Oren-Nayar Diffuse Result from the Light Sources
1151: 				diffterm = 1.25*mriBRDF_Oren_Nayar(N, V, L, difrough2);
1152: 				EnergyDiffuse  += (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * (diffterm) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);
1153: 				
1154: 				// Check-box Calculate Fresnel to Diffuse
1155: 				//if($DiffuseFresnel == true)
1156: 				// Calculate fresnel attenuation for the Diffuse, using the specReflectance at normal or the $IOR attributes.		
1157: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1158: 				{
1159: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);
1160: 					// *FIX Light Occlusion/Shadow Issue*
1161: 					float F0 = (1 - TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)/(1 + TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1162: 					F0 = F0*F0;
1163: 					F = mix(F*(1-NdotV), F, F0);
1164: 					// Energy Conservation from Specular (Lights Sources)	
1165: 					EnergyDiffuse *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;						
1166: 				}
1167: 				
1168: 				// ----------Sub-Surface Scattering TERM-----------            
1169: 				float LdotN = dot(L,N);
1170: 				float LdotH = dot(L,H);
1171: 				
1172: 				float FL = mriBRDF_SchlickFresnel(LdotN);
1173: 				float FV = mriBRDF_SchlickFresnel(NdotV);			
1174: 							
1175: 				LightColour = (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);
1176: 					
1177: 				// creates a bit of a fake impression of difusion
1178: 				vec3 mixSSSdifusion = vec3(0.0);
1179: 				for (int j=0;j<3;j++)
1180: 				{			
1181: 					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), 1-sssRadius.rgb[j] );
1182: 				}
1183: 				vec3 Back_Scat_Color = 1.25*mixSSSdifusion*mixSSSdifusion;
1184: 				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
1185: 				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
1186: 				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;
1187: 				
1188: 				EnergySSS += Back_Scat_Color;
1189: 							
1190: 				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1191: 				//if($DiffuseFresnel == true)
1192: 				// The same fresnel attenuation that affects the diffuse above.
1193: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1194: 				{
1195: 					// Energy Conservation from Specular (Lights Sources)
1196: 					EnergySSS *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;														
1197: 				}
1198: 				
1199: 				// ----------BACKLIGHT TERM-----------
1200: 				if( LdotN <= 0.0)
1201: 				{
1202: 					if(BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_ > 0.0)
1203: 					{					
1204: 						diffterm = mriBRDF_Oren_Nayar(N, V, -L, difrough2);
1205: 						EnergyBacklight += ( u_MriLightSources[i].DiffuseColor.rgb) * diffterm * BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * BacklightColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb *att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_)/PI;
1206: 						
1207: 						// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1208: 						//if($DiffuseFresnel == true)
1209: 						if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1210: 						{
1211: 							F = mriBRDF_Fresnel(-L, -H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1212: 							// *FIX Light Occlusion/Shadow Issue*
1213: 							float F0 = (1 - TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)/(1 + TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1214: 							F0 = F0*F0;
1215: 							F = mix(F*(1-NdotV), F, F0);						
1216: 							// Energy Conservation from Specular (Lights Sources)
1217: 							// ----------BACKLIGHT TERM-----------
1218: 							EnergyBacklight *= 1.0 - min(PI * F * max(0.0, dot(-L,N)) * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_, 1.0);						
1219: 						}
1220: 					}
1221: 					else
1222: 					{
1223: 						continue;
1224: 					}	
1225: 				}			
1226: 				
1227: 				// ----------SPECULAR1 TERM-----------
1228: 				// Moved to here so would Avoid shadow issues in the Diffuse and SSS Calculation and will prevent future issues in the Specular Calculation.
1229: 				if( LdotN > 0.0)
1230: 				{				
1231: 					// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR
1232: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1233: 					{
1234: 						F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1235: 					}	
1236: 					else
1237: 					{
1238: 						F = 1.0;
1239: 					}					
1240: 					//BRDF Model Cook-Torrance
1241: 					// Cook-Torrance Specular Result
1242: 					specterm = mriBRDF_Beckman(N, H, max(spec1rough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(spec1rough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
1243: 					
1244: 					
1245: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1246: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1247: 					if(abs(_ani1) != 0.0) 
1248: 					{							
1249: 						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
1250: 						if(spec1rough2 == 0.0)
1251: 						{
1252: 							specterm = mriBRDF_Ward(N, V, L, H, X1, Y1, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
1253: 						}
1254: 						else
1255: 						{						
1256: 							// Isotropy specular assumes that ani = 0
1257: 							specterm = mriBRDF_Ward(N, V, L, H, X1, Y1, _ani1, 0.99-spec1rough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
1258: 						}					
1259: 					}						
1260: 					EnergySpecular1 += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);			
1261: 				}
1262: 				
1263: 				// ----------SPECULAR2 TERM-----------
1264: 				if( LdotN > 0.0)
1265: 				{				
1266: 					if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1267: 					{
1268: 						F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1269: 					}	
1270: 					else
1271: 					{
1272: 						F = 1.0;
1273: 					}					
1274: 										
1275: 					//BRDF Model Cook-Torrance
1276: 					// Cook-Torrance Specular Result
1277: 					specterm2 = mriBRDF_Beckman(N, H, max(spec2rough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(spec2rough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
1278: 					
1279: 					
1280: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1281: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1282: 					if(abs(_ani2) != 0.0) 
1283: 					{							
1284: 						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
1285: 						if(spec2rough2 == 0.0)
1286: 						{
1287: 							specterm2 = mriBRDF_Ward(N, V, L, H, X2, Y2, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
1288: 						}
1289: 						else
1290: 						{						
1291: 							// Isotropy specular assumes that ani = 0
1292: 							specterm2 = mriBRDF_Ward(N, V, L, H, X2, Y2, _ani2, 0.99-spec2rough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
1293: 						}					
1294: 					}						
1295: 					EnergySpecular2 += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm2) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);			
1296: 				}
1297: 
1298: 			}		
1299: 		}
1300: 		
1301: 		
1302: 		if( mriEnvironmentLightOn() == true)
1303: 		{
1304: 			{
1305: 				// ----------DIFFUSE TERM-----------
1306: 				// Env Light, Light Direction
1307: 				vec3 L = N;
1308: 				LightColour = mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 0.0);
1309: 				// This mix(PI, 2.5, difrough2) would preserve albedo.	
1310: 				EnergyDiffuse_env = mix(PI, 2.5, difrough2)*mriBRDF_Oren_Nayar(N, V, L, difrough2) * LightColour;            		
1311: 				
1312: 				// Check-box Calculate Fresnel to Diffuse 
1313: 				//if($DiffuseFresnel == true)
1314: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1315: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1316: 				{
1317: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1318: 					L = normalize( -reflect( V, N));
1319: 					// Half Vector
1320: 					vec3 H = normalize(L+V);					
1321: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1322: 					// Energy Conservation from Specular (Environment)					
1323: 					EnergyDiffuse_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1324: 					
1325: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1326: 					{
1327: 						F = 0.0; 
1328: 					}
1329: 					// Energy Conservation from Reflection (Environment)	
1330: 					EnergyDiffuse_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1331: 				}
1332: 			}
1333: 			
1334: 			{
1335: 				// ----------BACKLIGHT TERM-----------
1336: 				// Env Light, Light Direction
1337: 				// Backlight	
1338: 				vec3 L = normalize( -refract(V, -N*State.FragmentPositionInEyeSpaceFromViewCamera, 1.0) );				
1339: 				
1340: 				float lightVisibility = 1.0;			
1341: 				
1342: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);	
1343: 				
1344: 				EnergyBacklight_env += mix(vec3(0), LightColour, BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_)*mriBRDF_Oren_Nayar(N, V, N, difrough2);
1345: 				EnergyBacklight_env /= 1+difrough2/PI;
1346: 				
1347: 				//if($DiffuseFresnel == true)
1348: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1349: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1350: 				{
1351: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1352: 					L = normalize( -reflect( V, N));
1353: 					// Half Vector
1354: 					vec3 H = normalize(L+V);					
1355: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1356: 					// Energy Conservation from Specular (Environment)					
1357: 					EnergyBacklight_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1358: 						
1359: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1360: 					{
1361: 						F = 0.0; 
1362: 					}
1363: 					// Energy Conservation from Reflection (Environment)	
1364: 					EnergyBacklight_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1365: 				}
1366: 			}	
1367: 
1368: 			{
1369: 				// ----------SPECULAR TERM1-----------
1370: 				// Env Specular Reflection, Light Direction			
1371: 				vec3 L = normalize( -reflect( V, N));
1372: 				// Half Vector
1373: 				vec3 H = normalize(L+V);          			
1374: 				
1375: 				// How to calculate fresnel to specular equation, using specReflectance at normal or Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_
1376: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1377: 				{
1378: 					F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1379: 				}
1380: 				else
1381: 				{
1382: 					F = 1.0;
1383: 				}
1384: 				float LdotN = dot(L,N);
1385: 				if( 0.0 < LdotN)
1386: 				{
1387: 					float lightVisibility = 1.0;
1388: 					LightColour = vec3(0.0);				
1389: 
1390: 					//BRDF Model Cook-Torrance
1391: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
1392: 					// Cook-Torrance Specular Result from Environment
1393: 					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-spec1rough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
1394: 					
1395: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1396: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1397: 					if(abs(_ani1) != 0) 
1398: 					{									
1399: 						// Isotropy reflection
1400: 						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
1401: 							
1402: 						// Anisotropy reflection	
1403: 						if(_ani1 != 0.0 && spec1rough2 != 0)
1404: 						{
1405: 							// Caculate how much isotropy is the material based on roughness and anisotropy values.
1406: 							float _isotropy = abs(_ani1)*(1.1-spec1rough2);	
1407: 							
1408: 							LightColour = vec3(0.0);
1409: 							float i = 0;
1410: 							for (;i < _isotropy;)
1411: 							{
1412: 							
1413: 							// Define the direction of the anisotropy
1414: 							vec3 L1 = normalize( reflect( V, _ani1 < 0? X1:Y1 ));
1415: 								
1416: 							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
1417: 							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L1, L, 1-i), clamp(_glossiness + abs(_ani1*_ani1)*(1.0-spec1rough2)/9, .1, .9) );							
1418: 							i += 0.1;
1419: 							}
1420: 							LightColour /= i*10;												
1421: 						}		
1422: 						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-spec1rough), 0.0, 1.0 );					
1423: 					}
1424: 					EnergySpecular_env1 += specterm * (LightColour);		
1425: 				
1426: 			
1427: 					// ----------REFLECTION TERM-----------
1428: 					// Reset the fresnel value, and keep the L direction from the specular above.
1429: 					
1430: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1431: 					{
1432: 						F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1433: 					}
1434: 					else
1435: 					{
1436: 						F = 1.0;
1437: 					}
1438: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
1439: 					EnergyReflection_env1 += F * (LightColour);
1440: 				}	
1441: 			}		
1442: 
1443: 			{
1444: 				// ----------SPECULAR TERM2-----------
1445: 				// Env Specular Reflection, Light Direction			
1446: 				vec3 L = normalize( -reflect( V, N));
1447: 				// Half Vector
1448: 				vec3 H = normalize(L+V);          			
1449: 				
1450: 				// How to calculate fresnel to specular equation, using specReflectance at normal or Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_
1451: 				if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1452: 				{
1453: 					F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1454: 				}
1455: 				else
1456: 				{
1457: 					F = 1.0;
1458: 				}
1459: 				float LdotN = dot(L,N);
1460: 				if( 0.0 < LdotN)
1461: 				{
1462: 					float lightVisibility = 1.0;
1463: 					LightColour = vec3(0.0);				
1464: 
1465: 					//BRDF Model Cook-Torrance
1466: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
1467: 					// Cook-Torrance Specular Result from Environment
1468: 					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-spec2rough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
1469: 					
1470: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1471: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1472: 					if(abs(_ani2) != 0) 
1473: 					{									
1474: 						// Isotropy reflection
1475: 						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
1476: 							
1477: 						// Anisotropy reflection	
1478: 						if(_ani2 != 0.0 && spec2rough2 != 0)
1479: 						{
1480: 							// Caculate how much isotropy is the material based on roughness and anisotropy values.
1481: 							float _isotropy = abs(_ani2)*(1.1-spec2rough2);	
1482: 							
1483: 							LightColour = vec3(0.0);
1484: 							float i = 0;
1485: 							for (;i < _isotropy;)
1486: 							{
1487: 							
1488: 							// Define the direction of the anisotropy
1489: 							vec3 L2 = normalize( reflect( V, _ani2 < 0? X2:Y2 ));
1490: 								
1491: 							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
1492: 							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L2, L, 1-i), clamp(_glossiness + abs(_ani2*_ani2)*(1.0-spec2rough2)/9, .1, .9) );							
1493: 							i += 0.1;
1494: 							}
1495: 							LightColour /= i*10;												
1496: 						}		
1497: 						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-spec2rough), 0.0, 1.0 );					
1498: 					}
1499: 					EnergySpecular_env2 += specterm * (LightColour);		
1500: 				
1501: 			
1502: 					// ----------REFLECTION TERM-----------
1503: 					// Reset the fresnel value, and keep the L direction from the specular above.
1504: 					
1505: 					if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1506: 					{
1507: 						F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1508: 					}
1509: 					else
1510: 					{
1511: 						F = 1.0;
1512: 					}
1513: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
1514: 					EnergyReflection_env2 += F * (LightColour);
1515: 				}	
1516: 			}		
1517: 
1518: 			
1519: 			{
1520: 				// ----------REFRACTION TERM-----------
1521: 				// Env Refraction, Light Direction			
1522: 				// Refraction incoming direction
1523: 				vec3 Li = vec3(0.0);
1524: 				if(Solid_node_83662364_52db_4f7b_b336_baca232fc310_)
1525: 				{
1526: 					Li = normalize( -refract(V, -N, (1.0/TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)) );
1527: 				}
1528: 				else
1529: 				{
1530: 					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
1531: 					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, (1.0/TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)) );
1532: 				}
1533: 				
1534: 				float lightVisibility = 1.0;
1535: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, _Refra_glossiness);		
1536: 				
1537: 				EnergyRefraction_env += (LightColour);		
1538: 							
1539: 				_Absorbance = transCol.rgb;
1540: 				if (_Absorbance != vec3(1.0) )
1541: 				{			
1542: 					_Absorbance = pow_RGB(transCol.rgb, Thickness/10);
1543: 					EnergyTransmittance = _Absorbance;
1544: 				}
1545: 				
1546: 				// *TWEAK* This will preserve some energy from the reflection that is actually passing through the surface and not been reflected by the fresnel.
1547: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1548: 				{
1549: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1550: 					vec3 L = normalize( -reflect( V, N));
1551: 					float LdotN = dot(L,N);
1552: 					// Half Vector
1553: 					vec3 H = normalize(L+V);					
1554: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);					
1555: 					EnergyRefraction_env *=  1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;			
1556: 					
1557: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1558: 					{
1559: 						F = 0.0; 
1560: 					}
1561: 					EnergyRefraction_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;				
1562: 				}		
1563: 			}	
1564: 
1565: 			{
1566: 				// ----------Sub-Surface Scattering TERM-----------
1567: 				// Env Light, Light Direction
1568: 				// Sub-Surface Scattering	
1569: 				vec3 L = N;				
1570: 				// Half Vector
1571: 				vec3 H = normalize(L+V);			
1572: 				
1573: 				float LdotN = dot(L,N);
1574: 				float LdotH = dot(L,H);
1575: 				
1576: 				float FL = mriBRDF_SchlickFresnel(LdotN);
1577: 				float FV = mriBRDF_SchlickFresnel(NdotV);			
1578: 					
1579: 				float lightVisibility = 1.0;
1580: 				
1581: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);
1582: 				
1583: 				// creates a bit of a fake impression of difusion
1584: 				vec3 mixSSSdifusion = vec3(0.0);
1585: 				for (int j=0;j<3;j++)
1586: 				{			
1587: 					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), sssRadius.rgb[j] );
1588: 				}
1589: 				vec3 Back_Scat_Color = 1.25*mixSSSdifusion;
1590: 				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
1591: 				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
1592: 				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;						
1593: 				
1594: 				EnergySSS_env += Back_Scat_Color;
1595: 				
1596: 				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1597: 				//if($DiffuseFresnel == true)
1598: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1599: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1600: 				{
1601: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1602: 					L = normalize( -reflect( V, N));
1603: 					// Half Vector
1604: 					vec3 H = normalize(L+V);					
1605: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1606: 					EnergySSS_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1607: 					
1608: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1609: 					{
1610: 						F = 0.0; // picks from the math above, since this would be a value that comes from a global attribute for the entire fresnels math.
1611: 					}
1612: 					EnergySSS_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1613: 				}
1614: 			}
1615: 			
1616: 			{
1617: 				// ----------OPACITY TERM-----------
1618: 				// Env Opacity, Light Direction			
1619: 				// Opacity incoming direction
1620: 				// It should look like a Ghost with inverted colors!
1621: 				vec3 Li = vec3(0.0);
1622: 				if(Solid_node_83662364_52db_4f7b_b336_baca232fc310_)
1623: 				{
1624: 					Li = normalize( -refract(V, -N, 1.0) );
1625: 				}
1626: 				else
1627: 				{
1628: 					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
1629: 					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, 1.0) );
1630: 				}
1631: 				float lightVisibility = 1.0;
1632: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, 1.0);		
1633: 				EnergyOpacity_env += LightColour;				
1634: 			}
1635: 		}	
1636: 		
1637: 		// AO option
1638: 		float _AO = 1.0 - AmbientOcclusion_node_83662364_52db_4f7b_b336_baca232fc310_ * State.AmbientOcclusion;
1639: 		
1640: 		// Keep in mind that Arnold does not restrict the artists with a builtin Energy Conservation! So you have some artists freedom to break the rules as you wish.
1641: 		vec3 Kd = (EnergyDiffuse+EnergyBacklight + EnergyDiffuse_env+EnergyBacklight_env) * difCol.rgb * DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * _AO;
1642: 		vec3 Ks1 = (EnergySpecular1 + EnergySpecular_env1) * specCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor1* _AO;	
1643: 		vec3 Ks2 = (EnergySpecular2 + EnergySpecular_env2) * specCol2.rgb * Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor2* _AO;	
1644: 		//vec3 Kr1 = EnergyReflection_env1 * reflCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor1 * _AO;
1645: 		//vec3 Kr2 = EnergyReflection_env2 * reflCol2.rgb * Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor2 * _AO;
1646: 		vec3 Kt = EnergyRefraction_env * EnergyTransmittance * refrCol.rgb * TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * _AO;
1647: 		vec3 Ksss = (EnergySSS + EnergySSS_env) * SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_ * sssCol.rgb * _AO;	
1648: 		vec3 Opa = EnergyOpacity_env * opacityCol.rgb;
1649: 		
1650: 		// New Mari Lighting Mode workflow.
1651: 		// Lighting Mode => 0 - "Flat" - only display the Current Channel that is selected.
1652: 		// Lighting Mode =>	1 - Basic - Display Diffuse + Sub-surface Scattering
1653: 		// Lighting Mode => 2 - Full - Adds the specular/reflection + refraction + self-illumination on top of what the Basic mode displays
1654: 		Output.rgb = u_MriLightingMode==0 ? Current_Channel_Selected.rgb : Kd+Ksss;
1655: 		Output.rgb += u_MriLightingMode!=2 ? vec3(0.0) : Ks1+Ks2+Kt;
1656: 			
1657: 		// Emission
1658: 		Output.rgb += u_MriLightingMode==2 ? EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * emisCol.rgb : vec3(0.0);
1659: 
1660: 		// Opacity
1661: 		Output.rgb = u_MriLightingMode==2 ? mix(Opa.rgb, Output.rgb, 1.0-color_toValue(opacityCol.rgb)) : Output.rgb;
1662: 				
1663: 		// If displaying "flat" lighting mode 0 use the Current Channel alpha.
1664: 		Output.a = u_MriLightingMode==0 ? node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output.a : 1.0;		
1665: 		
1666: 		
1667: 		// Render Passes Mode, the beauty pass = 0 doesn't need an if statement, it has coded above and displayed by default
1668: 		// Lighting Mode == 1 ? #Channel * $Weight : #Channel * $ChannelWeight * Lighting Contribution
1669: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 1)
1670: 		{
1671: 			Output.rgb = (u_MriLightingMode==1 ? difCol.rgb * DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kd);
1672: 		}
1673: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 2)
1674: 		{
1675: 			Output.rgb = (u_MriLightingMode==1 ? specCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ : Ks1+Ks2);
1676: 		}
1677: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 3)
1678: 		{
1679: 			Output.rgb = (u_MriLightingMode==1 ? reflCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kr1+Kr2);
1680: 		}
1681: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 4)
1682: 		{
1683: 			Output.rgb = (u_MriLightingMode==1 ? refrCol.rgb * TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kt);
1684: 		}
1685: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 5)
1686: 		{
1687: 			Output.rgb = (u_MriLightingMode==1 ? sssCol.rgb * SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_ : Ksss);
1688: 		}
1689: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 6)
1690: 		{
1691: 			Output.rgb = emisCol.rgb * EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
1692: 		}
1693: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7)
1694: 		{
1695: 			Output.rgb = vec3(1.0/Thickness);			
1696: 		}	
1697: 	}
1698: 		
1699: 	            
1700:     node_83662364_52db_4f7b_b336_baca232fc310_Output = Output;
1701: }
1702: 
1703: //=====================
1704: //--- Style 2 Node 'Viewer' ---
1705: //=====================
1706: 
1707: 
1708: uniform bool projection_through_enabled;
1709: uniform float projectionDepthTexture_Offset;
1710: uniform sampler2D projectionDepthTexture;
1711: uniform bool ao_enabled;
1712: uniform float ao_value;
1713: uniform float ao_contrast;
1714: uniform float ao_invert;
1715: uniform int ao_curve;
1716: uniform float depth_start;
1717: uniform float depth_end;
1718: uniform float depth_falloff;
1719: uniform float depth_range;
1720: uniform sampler2D marqueeSelMask;
1721: uniform float marqueeSelMaskAmount;
1722: uniform mat3x2 marqueeSelMaskMatrix;
1723: float MarqueeSelMaskFunc( vec2 uv)
1724: {
1725:     return ( 1.0 - marqueeSelMaskAmount*(1.0-texture( marqueeSelMask, ( (marqueeSelMaskMatrix * vec3( uv, 1.0)) * vec2( 0.5, -0.5)) + vec2( 0.5, 0.5)).a));
1726: }
1727: uniform bool fn_enabled;
1728: uniform float fn_maskAmount;
1729: uniform float fn_size;
1730: uniform float fn_seed;
1731: uniform float fn_roughness;
1732: uniform float fn_contrast;
1733: uniform float fn_invert;
1734: uniform int fractal_curve;
1735: 
1736: 
1737: void apply_projection_masks(inout MriFragmentState State, inout MriSystemFragmentState _State)
1738: {
1739:     float projection_exposure_multipler = projection_through_enabled ? float(_State.ProjectionCoord.z <= 1.0) : float((_State.ProjectionCoord.z-projectionDepthTexture_Offset) <= texture(projectionDepthTexture,_State.ProjectionCoord.st).r);
1740: _State.NonPreviewableProjectionExposure *= projection_exposure_multipler;
1741: float Midpoint = (depth_end+depth_start)/2.0;float Distance = (abs(Midpoint+State.FragmentPositionInEyeSpaceFromProjectionCamera.z)-abs(Midpoint-depth_start))/(Midpoint-depth_start);_State.ProjectionExposure *= clamp(Distance/depth_falloff+1.0, 0.0, 1.0);_State.NonPreviewableProjectionExposure *= MarqueeSelMaskFunc( State.FragmentPositionInNdcSpaceFromProjectionCamera.st);
1742: 
1743: }
1744: 
1745: void evaluate_shader_network(inout MriFragmentState State, inout MriSystemFragmentState _State)
1746: {
1747:         {
1748:         node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(State,_State); // Evaluating Node 'Bottom Transparency'
1749:         node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(State,_State); // Evaluating Node 'Paint 3'
1750:         node_516e4503_ea09_4104_8e31_2e667c820272_func(State,_State); // Evaluating Node 'Merge_Bump_Head'
1751:         node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(State,_State); // Evaluating Node 'Paint 4'
1752:         node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(State,_State); // Evaluating Node 'Layer'
1753:         node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(State,_State); // Evaluating Node 'Bump_Head'
1754:         node_45b7815b_0361_452e_b5c5_f476cf68940f_func(State,_State); // Evaluating Node 'Current Channel'
1755:         node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(State,_State); // Evaluating Node 'alSurfaceX/Height As Normal'
1756:         node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(State,_State); // Evaluating Node 'alSurfaceX/Normal Modulation'
1757:         node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(State,_State); // Evaluating Node 'alSurfaceX/Tangent Space To Eye Space'
1758:         node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(State,_State); // Evaluating Node 'alSurfaceX/Color To Vector'
1759:         node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(State,_State); // Evaluating Node 'alSurfaceX/Tangent Space To Eye Space 2'
1760:         node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(State,_State); // Evaluating Node 'alSurfaceX/Set Unlit'
1761:         node_83662364_52db_4f7b_b336_baca232fc310_func(State,_State); // Evaluating Node 'alSurfaceX/'
1762:         {
1763: 
1764:     _State.Diffuse = node_83662364_52db_4f7b_b336_baca232fc310_Output;
1765:                 
1766:         }
1767:     }
1768: 
1769: }
1770: 
1771: 
0(1679) : error C1008: undefined variable "Kr1"
0(1679) : error C1008: undefined variable "Kr2"

---CompilerLog---
0(1679) : error C1008: undefined variable "Kr1"
0(1679) : error C1008: undefined variable "Kr2"


Debug : [   mrisnglslcontextmanager.cpp:748 ] : Reloading Shader 'Shader Network1'
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:711 ] : [ !! ] Shader 'Shader Network1' Compilation Failure. Not linking.
---SourceCode---
Shader Type: Fragment
1: #version 150
2: #define MRI_SHADER_FRAGMENT 1
3: #define MRI_NUM_PATCH_ATTRIBUTES 4096
4: #define MRI_SVT_GATHER_USE_QUINT 1
5: #define MRI_USE_CUBE_MAP_ARRAY 1
6: #define USE_DEFERRED_TEXTURE_2D_ARRAY 1
7: 
8: //! Description |  Shader Network evaluation fragment shader
9: //! Name |  Func_ShaderNetwork.frag
10: //! Author |  Jack Greasley, Kiyoyuki Nakagaki, Duncan Hopkins
11: //! Copyright |  Copyright (c) 2013 The Foundry 
12: 
13: #define MRI_LIGHT_ARRAY_SIZE 4
14: 
15: struct MriSystemFragmentState
16: {
17:     vec4 Diffuse;
18:     vec4 Unlit;
19:     vec4 VectorData;
20: 
21:     vec2 dUV;
22: 
23:     vec3 ProjectionCoord;
24:     vec2 TangentInProjectionSpace;
25:     vec2 BitangentInProjectionSpace;
26: 
27:     bool Hidden;
28:     bool Locked;
29:     bool Selected;
30: 
31:     float ProjectionExposure;
32:     float NonPreviewableProjectionExposure;
33: 
34:     bool PatchSelected;
35:     bool FaceSelected;
36:     bool ObjectSelected;
37: 
38:     float TriangleId;
39:     float TileId; 
40:     float MipLevel;
41: 
42:     bool GeoExists;
43: };
44: 
45: struct MriFragmentState
46: {
47:     float AmbientOcclusion;
48: 
49:     vec3 Position;
50:     vec2 UV;
51:     vec3 Normal;
52:     vec3 Tangent;
53:     vec3 Bitangent;
54: 
55:     vec3 NormalInEyeSpaceFromViewCamera;
56:     vec3 TangentInEyeSpaceFromViewCamera;
57:     vec3 BitangentInEyeSpaceFromViewCamera;
58:     vec3 ViewVectorInEyeSpaceFromViewCamera;
59:     vec3 FragmentPositionInEyeSpaceFromViewCamera;
60: 
61:     vec3 NormalInEyeSpaceFromProjectionCamera;
62:     vec3 TangentInEyeSpaceFromProjectionCamera;
63:     vec3 BitangentInEyeSpaceFromProjectionCamera;
64:     vec3 ViewVectorInEyeSpaceFromProjectionCamera;
65: 
66:     vec3 FragmentPositionInEyeSpaceFromProjectionCamera;
67:     vec3 FragmentPositionInNdcSpaceFromProjectionCamera;
68: 
69:     float PatchId;
70:     int   FaceId;
71:     int   FaceIndex;
72: };
73: 
74: struct Channel
75: {
76:     // r - int index; 
77:     // g - bool active;
78:     // b - bool invert;
79:     ivec3 ChannelValues;
80:     // a - reserved
81: };
82: 
83: #if defined( USE_DEPTH_PROJECTIONS)
84: struct MriLight
85: {
86:     int depthProjectorIndex;
87:     int depthProjectorCount;
88: };
89: 
90: struct MriDepthProjection
91: {
92:     mat4 transform;
93: };
94: #endif
95: 
96: 
97: //Gives the true texture coordinates for the base texture
98: vec2 svt_coords(vec2 coords);
99: 
100: //This function gives the raw color value from the texture in Base channel without any filters or projection applied 
101: vec4 svt_texture(Channel Base, vec2 coords);
102: vec4 svt_texture(Channel Base, in MriFragmentState State, in MriSystemFragmentState _State);
103: 
104: //Collect height values from bump map
105: vec4 get_heights(Channel Base, vec2 coords);
106: 
107: //This function gives the color value from the texture in Base channel with some filters and projection applied if applicable
108: vec4 texture_lookup(Channel Base, vec2 coords);
109: 
110: //texture look up function for version 2.0
111: vec4 texture_lookup2(Channel Base, in MriFragmentState State, in MriSystemFragmentState _State);
112: 
113: float tex_mip_level(vec2 coord);
114: 
115: //Default shadow casting function
116: float mriLightVisibility( in int LightIndex, vec3 FragmentPosition);
117: 
118: //Functions for evaluating values with a bit of UV offset.
119: float dFdu(float F);
120: float dFdv(float F);
121: vec2 dFdu(vec2 F);
122: vec2 dFdv(vec2 F);
123: mat2 dFd(vec2 F);
124: vec3 dFdu(vec3 F);
125: vec3 dFdv(vec3 F);
126: mat2x3 dFd(vec3 F);
127: 
128: float F(float f0, vec2 dUV);
129: vec2 F(vec2 f0, vec2 dUV);
130: vec3 F(vec3 f0, vec2 dUV);
131: 
132: void apply_projection_masks(inout MriFragmentState State, inout MriSystemFragmentState _State);
133: 
134: void evaluate_shader_network(inout MriFragmentState State, inout MriSystemFragmentState _State);
135: 
136: 
137: #define MRI_LIGHT_ARRAY_SIZE 4
138: 
139: // DO NOT CHANGE this structure with out adjusting the uniform upload C++ code.
140: struct MriLightSource
141: {
142:     vec4 Position;
143: 
144:     vec4 AmbientColor;
145:     vec4 DiffuseColor;
146:     vec4 SpecularColor;
147: 
148:     float SpotCutoff;
149:     float SpotExponent;
150: 
151:     float ConstantAttenuation;
152:     float LinearAttenuation;
153:     float QuadraticAttenuation;
154: };
155: 
156: // Returns the lighting value to use from the external environment map
157: //  shapness - how clear or blurred the light source is
158: //   0.0 - Totally blurred light sources. same as using dot( normal, light) calculation
159: //   1.0 - Totally sharp
160: vec3 mriEnvironmentLight( in vec3 normal, in float sharpness);
161: bool mriEnvironmentLightOn();
162: 
163: 
164: float mriBRDF_sqr(float x);
165: 
166: float mriBRDF_SchlickFresnel(float u);
167: float mriBRDF_GTR1(float NdotH, float a);
168: float mriBRDF_GTR2(float NdotH, float a);
169: float mriBRDF_GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay);
170: float mriBRDF_smithG_GGX(float Ndotv, float alphaG);
171: vec3 mriBRDF_mon2lin(vec3 x);
172: 
173: 
174: ////////////////////////////////////////////////////////////////////////////////
175: // Custom BRDF Function Library Extension Registration
176: // Copyright (c) 2014 Antonio Lisboa M. Neto. All Rights Reserved.
177: //////////////////////////////////////////////////////////////////////////////// 
178: // File: BRDF_FunctionLib_ext.glslc	
179: // Description: Function Library Extension for be used in the new Custom BRDF Shaders
180: ////////////////////////////////////////////////////////////////////////////////               	
181: // Author: Antonio Neto       	
182: // Web: www.netocg.blogspot.com			
183: // Email: netocg.fx@gmail.com
184: ////////////////////////////////////////////////////////////////////////////////			                                   	
185: // Date: Jan 25, 2014	         		
186: ////////////////////////////////////////////////////////////////////////////////
187: 
188: float att(vec3 L, int Light_Falloff, float Decay_Rate);
189: float color_toValue(vec3 Color);
190: vec3 pow_RGB(vec3 Color, float Value);
191: vec3 convert_Colorspace(vec3 color, int Colorspace_Profile);
192: float mriBRDF_Fresnel(vec3 L, vec3 H, float eta);
193: float mriBRDF_Fresnel_Schlicks(vec3 L, vec3 H, float Reflectance);
194: float mriBRDF_Fresnel_Dielectric(vec3 L, vec3 H, float ior);
195: float mriBRDF_Fresnel_Conductor(vec3 L, vec3 H, float eta, float k);
196: float nfresnel(float cos_theta_r, float eta);
197: float mriBRDF_Oren_Nayar(vec3 N, vec3 V, vec3 L, float difrough2);
198: float mriBRDF_Beckman(vec3 N, vec3 H, float specrough2);
199: float mriBRDF_Geo_att_Cook_Torrance(vec3 N, vec3 H, vec3 V, vec3 L);
200: float mriBRDF_Ward(vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specrough2);
201: float mriBRDF_Geo_att_Ward_Duer( vec3 L, vec3 V, vec3 N, vec3 H);
202: float mriBRDF_Ashikhmin_Shirley( vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specrough2);
203: float mriBRDF_Geo_Att_Ash_Sh00( vec3 N, vec3 V, vec3 L);
204: float mriBRDF_Blinn(vec3 N, vec3 H, float specrough2);
205: float mriBRDF_Geo_att_Schlick_Smith(vec3 N, vec3 L, vec3 V, float specrough2);
206: float mriBRDF_Phong(vec3 N, vec3 V, vec3 H, float specrough2);
207: float mriBRDF_Geo_att_Beckmann(vec3 N, vec3 V, float specrough2);
208: float mriBRDF_GTR(vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specGloss, float ggxTailFalloff);
209: float mriBRDF_Geo_att_smithG_GGX(float NdotV, float specGloss);
210: 
211: /****************************************************************************
212: * Camera information
213: *****************************************************************************/
214: // camera type of the current view
215: // 0 - Perspective
216: // 1 - Ortho
217: // 2 - UV
218: uniform int u_MriViewType;
219: 
220: // x:left, y:top, z:right, w:bottom
221: uniform vec4 u_MriViewport;
222: 
223: /****************************************************************************
224: * Matrices
225: *****************************************************************************/
226: uniform mat4 u_MriViewMatrix;
227: uniform mat4 u_MriModelViewMatrix;
228: uniform mat4 u_MriProjectionMatrix;
229: uniform mat4 u_MriNormalMatrix;
230: 
231: /****************************************************************************
232: * Object information
233: *****************************************************************************/
234: uniform int u_MriObjectId;
235: uniform vec3 u_MriObjectCenter;
236: uniform float u_MriObjectRadius;
237: 
238: /****************************************************************************
239: * Light information
240: *****************************************************************************/
241: //Lighting mode
242: // 0 - Flat
243: // 1 - Basic (Diffuse only)
244: // 2 - Full
245: uniform int u_MriLightingMode;
246: 
247: uniform MriLightSource u_MriLightSources[MRI_LIGHT_ARRAY_SIZE];
248: 
249: /****************************************************************************
250: * Misc
251: *****************************************************************************/
252: // The current animation frame
253: uniform int u_MriCurrentFrame;
254: 
255: // The system time in milliseconds. Will wrap every ~70 minutes.
256: uniform int u_MriSystemTime;
257: 
258: uniform vec2 u_MriMaxSupportedTextureSize;
259: 
260: 
261: 
262: float mriColorBlend(float pixel, float fPixel, float bPixel, float fAlpha, float bAlpha, int normal);
263: vec3 mriColorBlendv(vec3 modifiedColor, vec3 layerColor, vec3 baseColor, float layerAlpha, float baseAlpha, int normal);
264: float mriAlphaBlend( float fAlpha, float bAlpha);
265: float mriRgb2Lightness(vec4 RGBA);
266: vec4 mriRgb2Hsl(vec4 colorIn);
267: vec4 mriHsl2Rgb(vec4 colorIn);
268: vec4 mriRgb2Hsv(vec4 colorIn);
269: vec4 mriHsv2Rgb(vec4 colorIn);
270: 
271: vec4 Comp_Add(vec4 base,vec4 blend,float Opacity);
272: vec4 Comp_BurnHighlights(vec4 base,vec4 blend,float Opacity);
273: vec4 Comp_BurnMidrange(vec4 base,vec4 blend,float Opacity);
274: vec4 Comp_BurnShadows(vec4 base,vec4 blend,float Opacity);
275: vec4 Comp_Clear(vec4 base,vec4 blend,float Opacity);
276: vec4 Comp_Color(vec4 base,vec4 blend,float Opacity);
277: vec4 Comp_ColorBurn(vec4 base,vec4 blend,float Opacity);
278: vec4 Comp_ColorDodge(vec4 base,vec4 blend,float Opacity);
279: vec4 Comp_Copy(vec4 base,vec4 blend,float Opacity);
280: vec4 Comp_CopyRGB(vec4 base,vec4 blend,float Opacity);
281: vec4 Comp_Darken(vec4 base,vec4 blend,float Opacity);
282: vec4 Comp_Default(vec4 base,vec4 blend,float Opacity);
283: vec4 Comp_Difference(vec4 base,vec4 blend,float Opacity);
284: vec4 Comp_DodgeHighlights(vec4 base,vec4 blend,float Opacity);
285: vec4 Comp_DodgeMidrange(vec4 base,vec4 blend,float Opacity);
286: vec4 Comp_DodgeShadows(vec4 base,vec4 blend,float Opacity);
287: vec4 Comp_Exclusion(vec4 base,vec4 blend,float Opacity);
288: vec4 Comp_HardLight(vec4 base,vec4 blend,float Opacity);
289: vec4 Comp_HardMix(vec4 base,vec4 blend,float Opacity);
290: vec4 Comp_Hue(vec4 base,vec4 blend,float Opacity);
291: vec4 Comp_InverseDifference(vec4 base,vec4 blend,float Opacity);
292: vec4 Comp_Invert(vec4 base,vec4 blend,float Opacity);
293: vec4 Comp_Lighten(vec4 base,vec4 blend,float Opacity);
294: vec4 Comp_Luminance(vec4 base,vec4 blend,float Opacity);
295: vec4 Comp_Multiply(vec4 base,vec4 blend,float Opacity);
296: vec4 Comp_Overlay(vec4 base,vec4 blend,float Opacity);
297: vec4 Comp_PinLight(vec4 base,vec4 blend,float Opacity);
298: vec4 Comp_Saturation(vec4 base,vec4 blend,float Opacity);
299: vec4 Comp_Screen(vec4 base,vec4 blend,float Opacity);
300: vec4 Comp_SoftLight(vec4 base,vec4 blend,float Opacity);
301: vec4 Comp_SpongeDesaturate(vec4 base,vec4 blend,float Opacity);
302: vec4 Comp_VividLight(vec4 base,vec4 blend,float Opacity);
303: vec4 Comp_Contrast(vec4 base,vec4 blend,float Opacity);
304: vec4 Comp_Decontrast(vec4 base,vec4 blend,float Opacity);
305: vec4 Comp_MixRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
306: vec4 Comp_AddRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
307: vec4 Comp_ReorientedNormalMappingRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
308: 
309: // Blending functions the operate on the color channels only. Used by things such as color adjustments where the alpha channel needs to be ignored.
310: vec4 Comp_Default(vec4 Base, vec3 Blend, float Amount);
311: vec4 Comp_Add(vec4 Base, vec3 Blend, float Amount);
312: vec4 Comp_Color(vec4 Base, vec3 Blend, float Amount);
313: vec4 Comp_Copy(vec4 Base, vec3 Blend, float Amount);
314: vec4 Comp_CopyRGB(vec4 Base, vec3 Blend, float Amount);
315: vec4 Comp_Darken(vec4 Base, vec3 Blend, float Amount);
316: vec4 Comp_Difference(vec4 Base, vec3 Blend, float Amount);
317: vec4 Comp_Hue(vec4 Base, vec3 Blend, float Amount);
318: vec4 Comp_InverseDifference(vec4 Base, vec3 Blend, float Amount);
319: vec4 Comp_Lighten(vec4 Base, vec3 Blend, float Amount);
320: vec4 Comp_Luminance(vec4 Base, vec3 Blend, float Amount);
321: vec4 Comp_Multiply(vec4 Base, vec3 Blend, float Amount);
322: vec4 Comp_Saturation(vec4 Base, vec3 Blend, float Amount);
323: 
324: vec4 Comp_VecDefault2d(vec4 base,vec4 blend,float Opacity);
325: vec4 Comp_VecDefault3d(vec4 base,vec4 blend,float Opacity);
326: 
327: vec4 Comp_VecAdd3d(vec4 base,vec4 blend,float Opacity);
328: vec4 Comp_VecAdd2d(vec4 base,vec4 blend,float Opacity);
329: 
330: vec4 Comp_VecScale3d(vec4 base,vec4 blend,float Opacity);
331: 
332: //! macro | custom_blend_mode_declarations | // No custom blend modes
333: 
334: 
335: 
336: 
337: //Curve lookup functions
338: 
339: float mriCurveLookup( in int Line, in float InValue);
340: 
341: 
342: 
343: 
344: /****************************************************************************
345: * Noise functions
346: *****************************************************************************/
347: 
348: //These functions generate Perlin and Simplex noise from 2D,3D,4D inputs
349: float mriPerlinNoise(vec2 P);
350: float mriPerlinNoise(vec3 P);
351: float mriPerlinNoise(vec4 P);
352: float mriSimplexNoise(vec2 P);
353: float mriSimplexNoise(vec3 P);
354: float mriSimplexNoise(vec4 P);
355: 
356: // DEPRECATED in favor of more explicit function names above
357: float mriNoise(vec3 P); 
358: 
359: 
360: //Cellular (Worley) noise generation function based on 3D input and different types of norm(distance) calculation. This returns vec3 in which F1, F2 and F1-F2 are returned in r, g and b of the resulting vec3 respectively. Cellular noise is a noise obtained by calculating distance to randomly generated points. The definition of the distance is the norm. F1 is the distance to the closest point while F2 is the distance to the 2nd closest point.  
361: // norm - The norm(distance calculation) definition to use. 
362: //  0 : Manhattan norm
363: //  1 : Euclidian norm
364: //  2 : Chebyshev(Infinity) norm
365: //  3 : P-norm where P=0.5
366: vec3 mriCellular(vec3 P, int norm);
367: 
368: // DEPRECATED
369: // These functions are provided for backward compatibility since the older version of Mari had these.
370: // These are deprecated and to be removed in favor of more explicitly named functions above.
371: float noise(vec3 P);
372: vec3 cellular(vec3 P, int norm);
373: 
374: 
375: 
376: 
377: //Given the face index at the evaluation point (usually the fragment), this returns hiddenness, lockedness and selectedness of the face in r,g and b respectively.
378: //the a component is currently not used, but reserved for the future usage
379: vec4 mriFaceSystemAttribute(int FaceIndex);
380: 
381: //Given the primitiveID, returns the face index of the original mesh
382: int mriFaceIndex(int PrimitiveID);
383: 
384: 
385: 
386: /****************************************************************************
387: * Misc
388: *****************************************************************************/
389: //This is an untility function to do the implementation of how to interpret a given color value as a mask. Whoever needs to regard some color value as mask should call this function for consistent mechanism
390: float interpretAsExposure(in vec4 Color,int Mode);
391: 
392: 
393: 
394: 
395: // Function for handling standard Vector Painting Maths
396: 
397: vec3 vector_bias( vec3 vector);
398: vec3 vector_unbias( vec3 colour);
399: 
400: vec3 vector_paintToTangent3D( vec3 screen);
401: vec3 vector_paintToTangent2D( vec3 screen);
402: 
403: vec3 vector_worldToTangent( vec3 tangent);
404: vec3 vector_tangentToWorld( vec3 tangent);
405: vec3 vector_tangentToScreen( vec3 tangent);
406: 
407: 
408: 
409: //! macro | module_inputs | // No Module Inputs
410: //! macro | module_calls  | // No Module Calls
411: //! macro | module_declarations  | // No Module Declarations
412: 
413: //! macro | surface_mask_declarations | // No mask applied
414: //! macro | surface_mask_body         | // No mask applied
415: 
416: uniform int udim_size;
417: 
418: void store_state(inout MriFragmentState State, inout MriSystemFragmentState _State);
419: void derive_state(inout MriFragmentState State, inout MriSystemFragmentState _State, float du, float dv);
420: void restore_state(inout MriFragmentState State, inout MriSystemFragmentState _State);
421: 
422: #define REVAL(func,du,dv) store_state(State, _State);derive_state(State, _State, du, dv);func(State,_State);restore_state(State, _State);
423: 
424: 
425: 
426: float olefresnel(float r, float g, float c);
427: float get_n(float r,float g);
428: float get_k2(float r, float n);
429: float n_min(float r);
430: float n_max(float r);
431: vec3 FresnelConductor(vec3 Refelctivity, vec3 EdgeTint,float cos_theta);//=====================
432: // Forward Declaration of functions
433: //=====================
434: 
435: void node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
436: void node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
437: void node_516e4503_ea09_4104_8e31_2e667c820272_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
438: void node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
439: void node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
440: void node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
441: void node_45b7815b_0361_452e_b5c5_f476cf68940f_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
442: void node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
443: void node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
444: void node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
445: void node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
446: void node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
447: void node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
448: void node_83662364_52db_4f7b_b336_baca232fc310_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
449: 
450: //=====================
451: // Declaration of functions
452: //=====================
453: 
454: //=====================
455: //--- Style 2 Node 'Bottom Transparency' ---
456: //=====================
457: vec4 node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output; // Output 'Output' 
458: void node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
459: {
460:     vec4 Output; // Output 'Output' 
461: 
462:     Output = vec4( 0, 0, 0, 0);
463:         
464:     node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output = Output;
465: }
466: 
467: //=====================
468: //--- Style 2 Node 'Paint 3' ---
469: //=====================
470: uniform Channel Channel_node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_;
471: vec4 node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output; // Output 'Output' 
472: void node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
473: {
474:     vec4 Output; // Output 'Output' 
475: 
476:                   
477:         Output = texture_lookup2(Channel_node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_,State,_State);
478:                   
479:               
480:     node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output = Output;
481: }
482: 
483: //=====================
484: //--- Style 2 Node 'Merge_Bump_Head' ---
485: //=====================
486: uniform int AdvancedEnabled_node_516e4503_ea09_4104_8e31_2e667c820272_;
487: uniform float Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
488: uniform int AmountEnabled_node_516e4503_ea09_4104_8e31_2e667c820272_;
489: uniform int BlendIfBelow_node_516e4503_ea09_4104_8e31_2e667c820272_;
490: uniform int BlendIfThis_node_516e4503_ea09_4104_8e31_2e667c820272_;
491: uniform int BlendMode_node_516e4503_ea09_4104_8e31_2e667c820272_;
492: uniform int Component_node_516e4503_ea09_4104_8e31_2e667c820272_;
493: uniform int SwizzleA_node_516e4503_ea09_4104_8e31_2e667c820272_;
494: uniform int SwizzleB_node_516e4503_ea09_4104_8e31_2e667c820272_;
495: uniform int SwizzleG_node_516e4503_ea09_4104_8e31_2e667c820272_;
496: uniform int SwizzleR_node_516e4503_ea09_4104_8e31_2e667c820272_;
497: vec4 node_516e4503_ea09_4104_8e31_2e667c820272_Output; // Output 'Output' 
498: void node_516e4503_ea09_4104_8e31_2e667c820272_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
499: {
500:     vec4 Output; // Output 'Output' 
501: 
502:     if( 0 != 0)
503:     {
504:         // this is used to control what component we are pulling the key from
505:         vec3 Mult[5];
506: 
507:         Mult[0] = vec3(1.0/3.0,1.0/3.0,1.0/3.0);
508:         Mult[1] = vec3(1,0,0);
509:         Mult[2] = vec3(0,1,0);
510:         Mult[3] = vec3(0,0,1);
511:         Mult[4] = vec3(0.2126,0.7152,0.0722);
512: 
513: 
514:         // Calculate the amount from the component
515:         // a Mult value of (1,0,0) will isolate the red value
516:         // A mult value of (1,1,1) will give a gray scale
517: 
518:         float ThisAmount = dot(node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output.rgb , Mult[0]);
519:         float BelowAmount = dot(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output.rgb , Mult[0]);
520: 
521:         // now that we've pulled the component out of above and below
522:         // we lookup into the lut to find out the amount to scale the alpha values by
523: 
524:         float ThisAlpha  = mriCurveLookup(BlendIfThis_node_516e4503_ea09_4104_8e31_2e667c820272_,ThisAmount);
525:         float BelowAlpha = mriCurveLookup(BlendIfBelow_node_516e4503_ea09_4104_8e31_2e667c820272_,BelowAmount);
526: 
527:         // now we multiply the base alpha value by both values
528: 
529:         float AdvancedBlendAmount = ThisAlpha * BelowAlpha;
530:         if( 0 != 1)
531:         {
532:             AdvancedBlendAmount *= Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
533:         }
534: 
535:         Output = Comp_Default(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output, node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output, vec4(1,1,1,1).r * AdvancedBlendAmount);
536:     }
537:     else
538:     {
539:         float BlendAmount = 1;
540:         if( 0 != 1)
541:         {
542:             BlendAmount *= Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
543:         }
544:         Output = Comp_Default(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output, node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output, BlendAmount * vec4(1,1,1,1).r);
545:     }
546: 
547:     Output = vec4( Output.r, Output.g, Output.b, Output.a);
548: 
549:                 
550:     node_516e4503_ea09_4104_8e31_2e667c820272_Output = Output;
551: }
552: 
553: //=====================
554: //--- Style 2 Node 'Paint 4' ---
555: //=====================
556: uniform Channel Channel_node_5ab26bd0_71fd_473d_ba94_940da940e2a5_;
557: vec4 node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output; // Output 'Output' 
558: void node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
559: {
560:     vec4 Output; // Output 'Output' 
561: 
562:                   
563:         Output = texture_lookup2(Channel_node_5ab26bd0_71fd_473d_ba94_940da940e2a5_,State,_State);
564:                   
565:               
566:     node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output = Output;
567: }
568: 
569: //=====================
570: //--- Style 2 Node 'Layer' ---
571: //=====================
572: uniform int AdvancedEnabled_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
573: uniform float Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
574: uniform int AmountEnabled_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
575: uniform int BlendIfBelow_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
576: uniform int BlendIfThis_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
577: uniform int BlendMode_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
578: uniform int Component_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
579: uniform int SwizzleA_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
580: uniform int SwizzleB_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
581: uniform int SwizzleG_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
582: uniform int SwizzleR_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
583: vec4 node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output; // Output 'Output' 
584: void node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
585: {
586:     vec4 Output; // Output 'Output' 
587: 
588:     if( 0 != 0)
589:     {
590:         // this is used to control what component we are pulling the key from
591:         vec3 Mult[5];
592: 
593:         Mult[0] = vec3(1.0/3.0,1.0/3.0,1.0/3.0);
594:         Mult[1] = vec3(1,0,0);
595:         Mult[2] = vec3(0,1,0);
596:         Mult[3] = vec3(0,0,1);
597:         Mult[4] = vec3(0.2126,0.7152,0.0722);
598: 
599: 
600:         // Calculate the amount from the component
601:         // a Mult value of (1,0,0) will isolate the red value
602:         // A mult value of (1,1,1) will give a gray scale
603: 
604:         float ThisAmount = dot(node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output.rgb , Mult[0]);
605:         float BelowAmount = dot(node_516e4503_ea09_4104_8e31_2e667c820272_Output.rgb , Mult[0]);
606: 
607:         // now that we've pulled the component out of above and below
608:         // we lookup into the lut to find out the amount to scale the alpha values by
609: 
610:         float ThisAlpha  = mriCurveLookup(BlendIfThis_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_,ThisAmount);
611:         float BelowAlpha = mriCurveLookup(BlendIfBelow_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_,BelowAmount);
612: 
613:         // now we multiply the base alpha value by both values
614: 
615:         float AdvancedBlendAmount = ThisAlpha * BelowAlpha;
616:         if( 0 != 1)
617:         {
618:             AdvancedBlendAmount *= Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
619:         }
620: 
621:         Output = Comp_Default(node_516e4503_ea09_4104_8e31_2e667c820272_Output, node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output, vec4(1,1,1,1).r * AdvancedBlendAmount);
622:     }
623:     else
624:     {
625:         float BlendAmount = 1;
626:         if( 0 != 1)
627:         {
628:             BlendAmount *= Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
629:         }
630:         Output = Comp_Default(node_516e4503_ea09_4104_8e31_2e667c820272_Output, node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output, BlendAmount * vec4(1,1,1,1).r);
631:     }
632: 
633:     Output = vec4( Output.r, Output.g, Output.b, Output.a);
634: 
635:                 
636:     node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output = Output;
637: }
638: 
639: //=====================
640: //--- Style 2 Node 'Bump_Head' ---
641: //=====================
642: vec4 node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output; // Output 'Output' 
643: void node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
644: {
645:     vec4 Output; // Output 'Output' 
646: 
647:     Output = node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output;
648:                 
649:     node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output = Output;
650: }
651: 
652: //=====================
653: //--- Style 2 Node 'Current Channel' ---
654: //=====================
655: vec4 node_45b7815b_0361_452e_b5c5_f476cf68940f_Output; // Output 'Output' 
656: void node_45b7815b_0361_452e_b5c5_f476cf68940f_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
657: {
658:     vec4 Output; // Output 'Output' 
659: 
660:     Output = node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output;
661:                 
662:     node_45b7815b_0361_452e_b5c5_f476cf68940f_Output = Output;
663: }
664: 
665: //=====================
666: //--- Style 2 Node 'alSurfaceX/Height As Normal' ---
667: //=====================
668: uniform int BumpMode_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_;
669: uniform float BumpWeight_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_;
670: vec4 node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output; // Output 'Output' 
671: void node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
672: {
673:     vec4 Output; // Output 'Output' 
674: 
675:     // distance in texture space [0,1] between adjacent pixels at this mip level
676:     float Offset = exp2(_State.MipLevel)/u_MriMaxSupportedTextureSize.x;
677: 
678:     float BumpWeight = BumpWeight_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_/Offset;
679: 
680: 
681: #if 0
682:     // fudge factor
683:     BumpWeight *= 1.0/(30.0 * 16.0);
684: 
685:     // Bump mapping version A
686:     //Default Input Used : NO REVAL(Heightfunc,-Offset,0.0);
687:     float l=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
688: 
689:     //Default Input Used : NO REVAL(Heightfunc,Offset,0.0);
690:     float r=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
691: 
692:     //Default Input Used : NO REVAL(Heightfunc,0.0,-Offset);
693:     float b=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
694: 
695:     //Default Input Used : NO REVAL(Heightfunc,0.0,Offset);
696:     float t=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
697: 
698:     vec2 heightDelta = vec2( l - r, b - t);
699: #else
700:     // fudge factor
701:     BumpWeight *= 2.0/(30.0 * 16.0);
702: 
703:     // Bump mapping version A
704:     float c=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
705: 
706:     //Default Input Used : NO REVAL(Heightfunc,Offset,0.0);
707:     float r=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
708: 
709:     //Default Input Used : NO REVAL(Heightfunc,0.0,Offset);
710:     float t=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
711: 
712:     vec2 heightDelta = vec2( c - r, c - t);
713: #endif
714: 
715:     Output.rgb = normalize( vec3(heightDelta,1.0) ) * vec3(0.5,-0.5,0.5) + vec3(0.5); 
716:     Output.a = 1.0; 
717:                 
718:     node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output = Output;
719: }
720: 
721: //=====================
722: //--- Style 2 Node 'alSurfaceX/Normal Modulation' ---
723: //=====================
724: vec4 node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output; // Output 'Output' 
725: void node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
726: {
727:     vec4 Output; // Output 'Output' 
728: 
729:         vec3 norm = vec3(0.0, 0.0, 0.0);
730:         vec3 norm0 = vec4(0.5,0.5,1.0,1.0).rgb * 2.0 -1.0;
731:         vec3 norm1 = node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output.rgb * 2.0 - 1.0;
732: 
733:         norm += dot(norm0.xy,norm0.xy)>0.0 ? norm0  : vec3(0.0);
734:         norm += dot(norm1.xy,norm1.xy)>0.0 ? norm1  : vec3(0.0);
735: 
736:         //When there is no bump/normal, set it to default
737:         norm = dot(norm,norm)>0.0 ? norm  : vec3(0.0,0.0,1.0);
738: 
739:         Output.rgb = normalize(norm);
740:         Output.a = 1.0;
741:                 
742:     node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output = Output;
743: }
744: 
745: //=====================
746: //--- Style 2 Node 'alSurfaceX/Tangent Space To Eye Space' ---
747: //=====================
748: vec4 node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output; // Output 'Output' 
749: void node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
750: {
751:     vec4 Output; // Output 'Output' 
752: 
753:     mat3 tangentSpace2eyeSpace = mat3(
754:         State.TangentInEyeSpaceFromViewCamera,
755:         State.BitangentInEyeSpaceFromViewCamera,
756:         State.NormalInEyeSpaceFromViewCamera
757:     );
758:     Output.rgb = normalize( tangentSpace2eyeSpace * (node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output.rgb * vec3( 1,-1,1)));
759:     Output.a = node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output.a;
760:                 
761:     node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output = Output;
762: }
763: 
764: //=====================
765: //--- Style 2 Node 'alSurfaceX/Color To Vector' ---
766: //=====================
767: vec4 node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output; // Output 'Output' 
768: void node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
769: {
770:     vec4 Output; // Output 'Output' 
771: 
772:         vec3 norm = (vec4(1.0,0.5,0.5,1.0).rgb * 2.0) - 1.0;
773: 
774:         Output.rgb = norm;
775:         Output.a = 1.0;
776:                 
777:     node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output = Output;
778: }
779: 
780: //=====================
781: //--- Style 2 Node 'alSurfaceX/Tangent Space To Eye Space 2' ---
782: //=====================
783: vec4 node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output; // Output 'Output' 
784: void node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
785: {
786:     vec4 Output; // Output 'Output' 
787: 
788:     mat3 tangentSpace2eyeSpace = mat3(
789:         State.TangentInEyeSpaceFromViewCamera,
790:         State.BitangentInEyeSpaceFromViewCamera,
791:         State.NormalInEyeSpaceFromViewCamera
792:     );
793:     Output.rgb = normalize( tangentSpace2eyeSpace * (node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output.rgb * vec3( 1,-1,1)));
794:     Output.a = node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output.a;
795:                 
796:     node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output = Output;
797: }
798: 
799: //=====================
800: //--- Style 2 Node 'alSurfaceX/Set Unlit' ---
801: //=====================
802: vec4 node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output; // Output 'Output' 
803: void node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
804: {
805:     vec4 Output; // Output 'Output' 
806: 
807: 
808:     _State.Unlit = ((_State.Unlit.a==0.0) ? node_45b7815b_0361_452e_b5c5_f476cf68940f_Output : _State.Unlit);
809:     Output = node_45b7815b_0361_452e_b5c5_f476cf68940f_Output;
810:                 
811:     node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output = Output;
812: }
813: 
814: //=====================
815: //--- Style 2 Node 'alSurfaceX/' ---
816: //=====================
817: uniform float AmbientOcclusion_node_83662364_52db_4f7b_b336_baca232fc310_;
818: uniform vec4 BacklightColor_node_83662364_52db_4f7b_b336_baca232fc310_;
819: uniform float BacklightIndirectStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
820: uniform float BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
821: uniform bool ConvertToGlossiness_node_83662364_52db_4f7b_b336_baca232fc310_;
822: uniform float Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_;
823: uniform vec4 DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_;
824: uniform float DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
825: uniform float DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
826: uniform vec4 EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
827: uniform float EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
828: uniform int Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_;
829: uniform vec4 Opacity_node_83662364_52db_4f7b_b336_baca232fc310_;
830: uniform int Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_;
831: uniform vec4 SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_;
832: uniform vec4 SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_;
833: uniform float SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_;
834: uniform bool Solid_node_83662364_52db_4f7b_b336_baca232fc310_;
835: uniform float Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
836: uniform vec4 Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
837: uniform vec4 Specular1EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_;
838: uniform int Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_;
839: uniform float Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_;
840: uniform vec4 Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_;
841: uniform float Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
842: uniform float Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
843: uniform float Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;
844: uniform float Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
845: uniform vec4 Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_;
846: uniform vec4 Specular2EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_;
847: uniform int Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_;
848: uniform float Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_;
849: uniform vec4 Specular2Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_;
850: uniform float Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
851: uniform float Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
852: uniform float Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_;
853: uniform vec4 TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
854: uniform float TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_;
855: uniform bool TransmissionLinkToSpecular1_node_83662364_52db_4f7b_b336_baca232fc310_;
856: uniform float TransmissionRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
857: uniform float TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
858: uniform int shadingNode_node_83662364_52db_4f7b_b336_baca232fc310_;
859: vec4 node_83662364_52db_4f7b_b336_baca232fc310_Output; // Output 'Output' 
860: void node_83662364_52db_4f7b_b336_baca232fc310_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
861: {
862:     vec4 Output; // Output 'Output' 
863: 
864: 	shadingNode_node_83662364_52db_4f7b_b336_baca232fc310_; 
865: 	// Used for continually Mark what shader you are using in case you have renamed the name of the shader inside Mari. This var is also used for the exporter to identify what shader he is picking.
866: 	
867: 	DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_;
868: 	DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
869: 	Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
870: 	Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
871: 	Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
872: 	Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
873: 	Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_;
874: 	Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
875: 	Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
876: 	Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
877: 	Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
878: 	TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
879: 	TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
880: 	TransmissionRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
881: 	Opacity_node_83662364_52db_4f7b_b336_baca232fc310_;
882: 	SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_;
883: 	SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_;
884: 	EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;	
885: 	
886: 	// These control/input pairs are alpha blended together.
887: 	// If the Channel has an input connected the input is used.	
888: 	// Else the attribute slider is used instead.
889: 	// VAR Name   			 'mix' based on existence of an alpha in the channels	
890: 	vec3 difCol	   			= mix( vec3(0),		vec4(DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,		vec4(DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
891: 	vec3 specCol1  			= mix( vec3(0),		vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
892: 	vec3 specCol2  			= mix( vec3(0),		vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
893: 	vec3 reflCol1  			= mix( vec3(0),		vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
894: 	vec3 reflCol2  			= mix( vec3(0),		vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
895: 	vec3 refrCol  			= mix( vec3(0),		vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
896: 	vec3 transCol 			= mix( vec3(0),		vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
897: 	vec3 sssCol	   			= mix( vec3(0),		vec4(SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb, 			vec4(SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a				== 0 ? 0 : 1);
898: 	vec3 sssRadius 			= mix( vec3(0), 	vec4(SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb, 		vec4(SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 			== 0 ? 0 : 1);
899: 	vec3 emisCol   			= mix( vec3(0),		vec4(EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	 	vec4(EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a		== 0 ? 0 : 1);
900: 		
901: 	float difrough 	 		= mix( float(0),	vec4(DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
902: 	float spec1rough 		= mix( float(0),	vec4(Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
903: 	float ani1				= mix( float(0),	vec4(Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
904: 	float rot1 		 		= mix( float(0),	vec4(Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
905: 	float spec2rough 		= mix( float(0),	vec4(Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
906: 	float ani2				= mix( float(0),	vec4(Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
907: 	float rot2 		 		= mix( float(0),	vec4(Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
908: 	float refrarough		= mix( float(0),	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).r,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 	== 0 ? 0 : 1);
909: 	
910: 
911: 	vec3 Current_Channel_Selected = node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output.rgb;
912: 	
913: 	if(ConvertToGlossiness_node_83662364_52db_4f7b_b336_baca232fc310_ == true)
914: 	{
915: 		spec1rough = 1.0 - spec1rough;
916: 		spec2rough = 1.0 - spec2rough;
917: 	}
918: 	
919: 	// Check if there's Color painted at the rgb of the Opacity Channels	
920: 	vec3 opacityCol	 = vec3(0,0,0);
921: 	if (color_toValue(vec4(Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,0).rgb) == 0)
922: 	{
923: 		opacityCol = vec3(1.0) - Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb;
924: 	}
925: 	else
926: 	{
927: 		opacityCol = vec3(1.0) - vec4(Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,0).rgb;	
928: 	}	
929: 	
930: 	// The UV Viewport will display what is the Current Channel Selected, unless you don't have any channel. Then it will display the Mari`s alpha checkerboard pattern.	
931: 	if(u_MriViewType==2 || u_MriLightingMode==0)
932: 	{
933: 		// This is the cheapest way to use this "viewbuffer" feature, skipping most of the shader calculation.
934: 		
935: 		Output = node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output;		
936: 		
937: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 1)
938: 		{
939: 			Output.rgb = difCol.rgb;
940: 		}
941: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 2)
942: 		{
943: 			Output.rgb = specCol1.rgb;
944: 		}
945: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 3)
946: 		{
947: 			Output.rgb = reflCol1.rgb;
948: 		}
949: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 4)
950: 		{
951: 			Output.rgb = refrCol.rgb;
952: 		}
953: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 5)
954: 		{
955: 			Output.rgb = sssCol.rgb;
956: 		}
957: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 6)
958: 		{
959: 			Output.rgb = emisCol.rgb;
960: 		}
961: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7)
962: 		{
963: 			Output = vec4(0.5,0.5,0.5,0.0);
964: 		}
965: 		
966: 		//Display the Thickness imported image in the UV Viewport
967: 		if(u_MriViewType==2 && Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7) 
968: 		{
969: 			Output = vec4(0.5,0.5,0.5,0.0);			
970: 		}		
971: 	}
972: 	else
973: 	{
974: 		// ------------  All the shader math ------------
975: 		
976: 		const float PI = 3.14159265358979323846264;
977: 		const float TwoPI = 2.0 * PI;
978: 			
979: 		// View Direction
980: 		vec3 V = normalize(-State.ViewVectorInEyeSpaceFromViewCamera);
981: 		// Normal Direction
982: 		vec3 N = normalize(node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output.xyz);
983: 			
984: 		float NdotV = dot(N,V);
985: 		// On the wrong side of the face
986: 		if( NdotV <= 0.0)
987: 		{
988: 			N = -N;
989: 			NdotV = 1.0 - NdotV;
990: 		}
991: 				
992: 		//Enum Light direction
993: 		vec3 L = N;
994: 		// Half Vector
995: 		vec3 H = normalize(L+V);					
996: 		float cos_theta = dot(H,V);
997: 		vec3 RelectionTintColor1 = FresnelConductor(Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,Specular1EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,cos_theta);
998: 		//vec3 RelectionTintColor1 = Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb;
999: 		vec3 RelectionTintColor2 = FresnelConductor(Specular2Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,Specular2EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,cos_theta);
1000: 
1001: 				
1002: 		// Calculates the Space diagonal of the volume inside a cube
1003: 		vec3 viewPos = vec3(1.0);
1004: 		viewPos.x = mix(1, 2*abs(State.Position.x), abs(State.NormalInEyeSpaceFromViewCamera.x) );
1005: 		viewPos.y = mix(1, 2*abs(State.Position.y), abs(State.NormalInEyeSpaceFromViewCamera.y) );
1006: 		viewPos.z = mix(1, 2*abs(State.Position.z), abs(State.NormalInEyeSpaceFromViewCamera.z) );
1007: 		float base_diagonal = sqrt(viewPos.x*viewPos.x+viewPos.z*viewPos.z);
1008: 		float space_diagonal = sqrt(base_diagonal*base_diagonal + viewPos.y*viewPos.y);
1009: 			
1010: 		// Check if there is a texture assigned to the vec4(0.5,0.5,0.5,0.0) attribute, if does, then use it instead of the 1.5 value. 
1011: 		float Thickness = 1.5;	
1012: 		if(vec4(0.5,0.5,0.5,0.0).a > 0)	
1013: 		{
1014: 			Thickness = 1.0 + vec4(0.5,0.5,0.5,0.0).r;		
1015: 		}
1016: 		
1017: 		//Use the Baked texture to mix with the multiplication factors of the "Voxelized calculation method" based on depth of the scene
1018: 		if(u_MriViewType == 0) //gl buffer does not work well in perspective mode
1019: 		{
1020: 			//thickness based on position calculation mixed with obj radius
1021: 			vec3 P = State.Position*u_MriObjectRadius;
1022: 			float d = -dot(State.Position,P);
1023: 			float D = abs(d)/length(P);
1024: 			D /=u_MriObjectRadius;             
1025: 			
1026: 			Thickness *= mix( mix(2, 1, 1-NdotV)*u_MriObjectRadius, space_diagonal, (1-NdotV)*length(D));	
1027: 		}
1028: 		else
1029: 		{
1030: 			//thickness based on depth and obj radius
1031: 			float mult_factor = mix(2*u_MriObjectRadius, u_MriObjectRadius/2, gl_FragDepth);
1032: 			//thickness adjusment for the depth based on the Space diagonal of a cube created for each pixel on face.
1033: 			float mult_factor2 = mix( mix(space_diagonal, 1, (gl_FragDepth*(1-NdotV))), mix(u_MriObjectRadius, 1, (2*abs(gl_FragDepth - 0.5))*(1-NdotV)), 2*abs(gl_FragDepth - 0.5) )*PI; // this PI is just a adjusment to the color values between the two viewports
1034: 			
1035: 			Thickness *= mix(mult_factor, mult_factor2, gl_FragDepth);
1036: 		}	
1037: 		
1038: 				
1039: 		// Roughness attributes squared
1040: 		float difrough2 = difrough*difrough;		
1041: 		float spec1rough2 = spec1rough*spec1rough*spec1rough*spec1rough; // Arnold use a quadratic specrough for cook-torrance only(their wish was to use cubic, but that's expensive they say).	
1042: 		float spec2rough2 = spec2rough*spec2rough*spec2rough*spec2rough;
1043: 		float refrarough2 = refrarough*refrarough*refrarough*refrarough;
1044: 		
1045: 		float _glossiness = 1.0;
1046: 		float _Refra_glossiness = 1.0;
1047: 		float _ani1 = 2*(0.5-ani1); // internal variable to be used as anisotropy for the maths, this changes the anisotropy value to the range -1 and 1 that is used by V-ray and is correct for obtain the correct result from the BRDF Formula.
1048: 		float _ani2 = 2*(0.5-ani2);
1049: 		
1050: 		// IBL Glossiness adaptation to match the BRDF blur or 'spec lobe' for Environment Lighting
1051: 		_glossiness = mix(pow( 1-sqrt(spec1rough2), 2), pow( 1-(spec1rough), 3), 1-spec1rough);
1052: 		_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1053: 		
1054: 		if(_ani1 == 0.0 || spec1rough2 == 0.0) // There is no Anisotropy if the Specular Roughness = 0
1055: 		{
1056: 			_glossiness = pow( mix( 1-spec1rough2, 1-sqrt(spec1rough2), 1-spec1rough), mix(2, 3, 1-spec1rough) );
1057: 			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1058: 		}
1059: 		else
1060: 		{				  
1061: 			_glossiness = pow( mix( (abs(_ani1)/PI+1-sqrt(spec1rough2))/2, (abs(_ani1)+1-sqrt(spec1rough2))/2, 1-spec1rough), mix(1, (abs(_ani1)+1-sqrt(spec1rough2))*1.5, 1-spec1rough) );
1062: 			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1063: 		}
1064: 		
1065: 		// Fresnel var initialization	
1066: 		float F = 1.0;
1067: 		if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1068: 		{
1069: 			F = 0.0;
1070: 		}	
1071: 		
1072: 		// Anisotropic coords
1073: 		vec3 epsilon1 = vec3(0, 1, 0.15);
1074: 		vec3 X1 = vec3(1,0,0);
1075: 		vec3 Y1 = vec3(0,1,0);
1076: 		if(node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.a != 1.0)
1077: 		{
1078: 			X1.x = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.r;
1079: 			Y1.y = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.g;
1080: 		}
1081: 		if(ani1 != 0.5)
1082: 		{		
1083: 			epsilon1 = rot1 < 0.5 ? mix(Y1, X1, 2*rot1) : mix(X1, -Y1, 2*(rot1-0.5) );		
1084: 		}
1085: 				
1086: 		Y1 = normalize(cross(N, epsilon1));
1087: 		X1 = normalize(cross(N, Y1));
1088: 		
1089: 		vec3 epsilon2 = vec3(0, 1, 0.15);
1090: 		vec3 X2 = vec3(1,0,0);
1091: 		vec3 Y2 = vec3(0,1,0);
1092: 		if(node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.a != 1.0)
1093: 		{
1094: 			X2.x = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.r;
1095: 			Y2.y = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.g;
1096: 		}
1097: 		if(ani2 != 0.5)
1098: 		{		
1099: 			epsilon2 = rot2 < 0.5 ? mix(Y2, X2, 2*rot2) : mix(X2, -Y2, 2*(rot2-0.5) );		
1100: 		}
1101: 				
1102: 		Y2 = normalize(cross(N, epsilon2));
1103: 		X2 = normalize(cross(N, Y2));
1104: 
1105: 		// Energy variables initialization for each phase of the light calculation
1106: 		vec3 EnergyDiffuse = vec3(0.0);
1107: 		vec3 EnergyDiffuse_env = vec3(0.0); //avoid diffuse light bounces from lights to the obj
1108: 		vec3 EnergyBacklight = vec3(0.0);
1109: 		vec3 EnergyBacklight_env = vec3(0.0);
1110: 		vec3 EnergySpecular1 = vec3(0.0); //also separete the energy from highlights and reflection(point lights and environment light) also avoids lights bouncees from shader to the direct light sourcers the point lights.
1111: 		vec3 EnergySpecular_env1 = vec3(0.0);
1112: 		vec3 EnergyReflection_env1 = vec3(0.0);
1113: 		vec3 EnergySpecular2 = vec3(0.0); 
1114: 		vec3 EnergySpecular_env2 = vec3(0.0); 
1115: 		vec3 EnergyReflection_env2 = vec3(0.0);
1116: 		vec3 EnergyRefraction_env = vec3(0.0);
1117: 		vec3 EnergyTransmittance = vec3(1.0);
1118: 		vec3 EnergySSS = vec3(0.0);
1119: 		vec3 EnergySSS_env = vec3(0.0); //avoid SSS light bounces from lights to the obj
1120: 		vec3 EnergyOpacity_env = vec3(0.0);
1121: 		
1122: 		vec3 LightColour = vec3(0.0);
1123: 		float diffterm = 0.0;
1124: 		float specterm = 0.0;
1125: 		float specterm2 = 0.0;
1126: 		float refraterm = 0.0;
1127: 		vec3 _Absorbance = vec3 (1.0);
1128: 		
1129: 		
1130: 		
1131: 		for(int i=0;i<4;i++)
1132: 		{
1133: 			if( vec3( 0) == u_MriLightSources[i].DiffuseColor.rgb && vec3( 0) == u_MriLightSources[i].SpecularColor.rgb)
1134: 			{
1135: 				continue;
1136: 			}
1137: 
1138: 			float lightVisibility = mriLightVisibility( i, State.Position);		
1139: 			
1140: 			// Light Direction			
1141: 			vec3 L = normalize(u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera);
1142: 			vec3 LdistP = u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera;	
1143: 			
1144: 			// Half Vector
1145: 			vec3 H = normalize(L+V);		
1146: 			
1147: 			float LdotN = dot(L,N);		
1148: 			{			
1149: 				// ----------DIFFUSE TERM-----------
1150: 				// Oren-Nayar Diffuse Result from the Light Sources
1151: 				diffterm = 1.25*mriBRDF_Oren_Nayar(N, V, L, difrough2);
1152: 				EnergyDiffuse  += (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * (diffterm) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);
1153: 				
1154: 				// Check-box Calculate Fresnel to Diffuse
1155: 				//if($DiffuseFresnel == true)
1156: 				// Calculate fresnel attenuation for the Diffuse, using the specReflectance at normal or the $IOR attributes.		
1157: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1158: 				{
1159: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);
1160: 					// *FIX Light Occlusion/Shadow Issue*
1161: 					float F0 = (1 - TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)/(1 + TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1162: 					F0 = F0*F0;
1163: 					F = mix(F*(1-NdotV), F, F0);
1164: 					// Energy Conservation from Specular (Lights Sources)	
1165: 					EnergyDiffuse *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;						
1166: 				}
1167: 				
1168: 				// ----------Sub-Surface Scattering TERM-----------            
1169: 				float LdotN = dot(L,N);
1170: 				float LdotH = dot(L,H);
1171: 				
1172: 				float FL = mriBRDF_SchlickFresnel(LdotN);
1173: 				float FV = mriBRDF_SchlickFresnel(NdotV);			
1174: 							
1175: 				LightColour = (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);
1176: 					
1177: 				// creates a bit of a fake impression of difusion
1178: 				vec3 mixSSSdifusion = vec3(0.0);
1179: 				for (int j=0;j<3;j++)
1180: 				{			
1181: 					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), 1-sssRadius.rgb[j] );
1182: 				}
1183: 				vec3 Back_Scat_Color = 1.25*mixSSSdifusion*mixSSSdifusion;
1184: 				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
1185: 				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
1186: 				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;
1187: 				
1188: 				EnergySSS += Back_Scat_Color;
1189: 							
1190: 				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1191: 				//if($DiffuseFresnel == true)
1192: 				// The same fresnel attenuation that affects the diffuse above.
1193: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1194: 				{
1195: 					// Energy Conservation from Specular (Lights Sources)
1196: 					EnergySSS *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;														
1197: 				}
1198: 				
1199: 				// ----------BACKLIGHT TERM-----------
1200: 				if( LdotN <= 0.0)
1201: 				{
1202: 					if(BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_ > 0.0)
1203: 					{					
1204: 						diffterm = mriBRDF_Oren_Nayar(N, V, -L, difrough2);
1205: 						EnergyBacklight += ( u_MriLightSources[i].DiffuseColor.rgb) * diffterm * BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * BacklightColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb *att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_)/PI;
1206: 						
1207: 						// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1208: 						//if($DiffuseFresnel == true)
1209: 						if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1210: 						{
1211: 							F = mriBRDF_Fresnel(-L, -H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1212: 							// *FIX Light Occlusion/Shadow Issue*
1213: 							float F0 = (1 - TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)/(1 + TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1214: 							F0 = F0*F0;
1215: 							F = mix(F*(1-NdotV), F, F0);						
1216: 							// Energy Conservation from Specular (Lights Sources)
1217: 							// ----------BACKLIGHT TERM-----------
1218: 							EnergyBacklight *= 1.0 - min(PI * F * max(0.0, dot(-L,N)) * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_, 1.0);						
1219: 						}
1220: 					}
1221: 					else
1222: 					{
1223: 						continue;
1224: 					}	
1225: 				}			
1226: 				
1227: 				// ----------SPECULAR1 TERM-----------
1228: 				// Moved to here so would Avoid shadow issues in the Diffuse and SSS Calculation and will prevent future issues in the Specular Calculation.
1229: 				if( LdotN > 0.0)
1230: 				{				
1231: 					// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR
1232: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1233: 					{
1234: 						F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1235: 					}	
1236: 					else
1237: 					{
1238: 						F = 1.0;
1239: 					}					
1240: 					//BRDF Model Cook-Torrance
1241: 					// Cook-Torrance Specular Result
1242: 					specterm = mriBRDF_Beckman(N, H, max(spec1rough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(spec1rough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
1243: 					
1244: 					
1245: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1246: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1247: 					if(abs(_ani1) != 0.0) 
1248: 					{							
1249: 						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
1250: 						if(spec1rough2 == 0.0)
1251: 						{
1252: 							specterm = mriBRDF_Ward(N, V, L, H, X1, Y1, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
1253: 						}
1254: 						else
1255: 						{						
1256: 							// Isotropy specular assumes that ani = 0
1257: 							specterm = mriBRDF_Ward(N, V, L, H, X1, Y1, _ani1, 0.99-spec1rough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
1258: 						}					
1259: 					}						
1260: 					EnergySpecular1 += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);			
1261: 				}
1262: 				
1263: 				// ----------SPECULAR2 TERM-----------
1264: 				if( LdotN > 0.0)
1265: 				{				
1266: 					if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1267: 					{
1268: 						F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1269: 					}	
1270: 					else
1271: 					{
1272: 						F = 1.0;
1273: 					}					
1274: 										
1275: 					//BRDF Model Cook-Torrance
1276: 					// Cook-Torrance Specular Result
1277: 					specterm2 = mriBRDF_Beckman(N, H, max(spec2rough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(spec2rough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
1278: 					
1279: 					
1280: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1281: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1282: 					if(abs(_ani2) != 0.0) 
1283: 					{							
1284: 						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
1285: 						if(spec2rough2 == 0.0)
1286: 						{
1287: 							specterm2 = mriBRDF_Ward(N, V, L, H, X2, Y2, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
1288: 						}
1289: 						else
1290: 						{						
1291: 							// Isotropy specular assumes that ani = 0
1292: 							specterm2 = mriBRDF_Ward(N, V, L, H, X2, Y2, _ani2, 0.99-spec2rough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
1293: 						}					
1294: 					}						
1295: 					EnergySpecular2 += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm2) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);			
1296: 				}
1297: 
1298: 			}		
1299: 		}
1300: 		
1301: 		
1302: 		if( mriEnvironmentLightOn() == true)
1303: 		{
1304: 			{
1305: 				// ----------DIFFUSE TERM-----------
1306: 				// Env Light, Light Direction
1307: 				vec3 L = N;
1308: 				LightColour = mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 0.0);
1309: 				// This mix(PI, 2.5, difrough2) would preserve albedo.	
1310: 				EnergyDiffuse_env = mix(PI, 2.5, difrough2)*mriBRDF_Oren_Nayar(N, V, L, difrough2) * LightColour;            		
1311: 				
1312: 				// Check-box Calculate Fresnel to Diffuse 
1313: 				//if($DiffuseFresnel == true)
1314: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1315: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1316: 				{
1317: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1318: 					L = normalize( -reflect( V, N));
1319: 					// Half Vector
1320: 					vec3 H = normalize(L+V);					
1321: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1322: 					// Energy Conservation from Specular (Environment)					
1323: 					EnergyDiffuse_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1324: 					
1325: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1326: 					{
1327: 						F = 0.0; 
1328: 					}
1329: 					// Energy Conservation from Reflection (Environment)	
1330: 					EnergyDiffuse_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1331: 				}
1332: 			}
1333: 			
1334: 			{
1335: 				// ----------BACKLIGHT TERM-----------
1336: 				// Env Light, Light Direction
1337: 				// Backlight	
1338: 				vec3 L = normalize( -refract(V, -N*State.FragmentPositionInEyeSpaceFromViewCamera, 1.0) );				
1339: 				
1340: 				float lightVisibility = 1.0;			
1341: 				
1342: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);	
1343: 				
1344: 				EnergyBacklight_env += mix(vec3(0), LightColour, BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_)*mriBRDF_Oren_Nayar(N, V, N, difrough2);
1345: 				EnergyBacklight_env /= 1+difrough2/PI;
1346: 				
1347: 				//if($DiffuseFresnel == true)
1348: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1349: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1350: 				{
1351: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1352: 					L = normalize( -reflect( V, N));
1353: 					// Half Vector
1354: 					vec3 H = normalize(L+V);					
1355: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1356: 					// Energy Conservation from Specular (Environment)					
1357: 					EnergyBacklight_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1358: 						
1359: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1360: 					{
1361: 						F = 0.0; 
1362: 					}
1363: 					// Energy Conservation from Reflection (Environment)	
1364: 					EnergyBacklight_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1365: 				}
1366: 			}	
1367: 
1368: 			{
1369: 				// ----------SPECULAR TERM1-----------
1370: 				// Env Specular Reflection, Light Direction			
1371: 				vec3 L = normalize( -reflect( V, N));
1372: 				// Half Vector
1373: 				vec3 H = normalize(L+V);          			
1374: 				
1375: 				// How to calculate fresnel to specular equation, using specReflectance at normal or Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_
1376: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1377: 				{
1378: 					F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1379: 				}
1380: 				else
1381: 				{
1382: 					F = 1.0;
1383: 				}
1384: 				float LdotN = dot(L,N);
1385: 				if( 0.0 < LdotN)
1386: 				{
1387: 					float lightVisibility = 1.0;
1388: 					LightColour = vec3(0.0);				
1389: 
1390: 					//BRDF Model Cook-Torrance
1391: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
1392: 					// Cook-Torrance Specular Result from Environment
1393: 					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-spec1rough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
1394: 					
1395: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1396: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1397: 					if(abs(_ani1) != 0) 
1398: 					{									
1399: 						// Isotropy reflection
1400: 						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
1401: 							
1402: 						// Anisotropy reflection	
1403: 						if(_ani1 != 0.0 && spec1rough2 != 0)
1404: 						{
1405: 							// Caculate how much isotropy is the material based on roughness and anisotropy values.
1406: 							float _isotropy = abs(_ani1)*(1.1-spec1rough2);	
1407: 							
1408: 							LightColour = vec3(0.0);
1409: 							float i = 0;
1410: 							for (;i < _isotropy;)
1411: 							{
1412: 							
1413: 							// Define the direction of the anisotropy
1414: 							vec3 L1 = normalize( reflect( V, _ani1 < 0? X1:Y1 ));
1415: 								
1416: 							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
1417: 							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L1, L, 1-i), clamp(_glossiness + abs(_ani1*_ani1)*(1.0-spec1rough2)/9, .1, .9) );							
1418: 							i += 0.1;
1419: 							}
1420: 							LightColour /= i*10;												
1421: 						}		
1422: 						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-spec1rough), 0.0, 1.0 );					
1423: 					}
1424: 					EnergySpecular_env1 += specterm * (LightColour);		
1425: 				
1426: 			
1427: 					// ----------REFLECTION TERM-----------
1428: 					// Reset the fresnel value, and keep the L direction from the specular above.
1429: 					
1430: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1431: 					{
1432: 						F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1433: 					}
1434: 					else
1435: 					{
1436: 						F = 1.0;
1437: 					}
1438: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
1439: 					EnergyReflection_env1 += F * (LightColour);
1440: 				}	
1441: 			}		
1442: 
1443: 			{
1444: 				// ----------SPECULAR TERM2-----------
1445: 				// Env Specular Reflection, Light Direction			
1446: 				vec3 L = normalize( -reflect( V, N));
1447: 				// Half Vector
1448: 				vec3 H = normalize(L+V);          			
1449: 				
1450: 				// How to calculate fresnel to specular equation, using specReflectance at normal or Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_
1451: 				if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1452: 				{
1453: 					F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1454: 				}
1455: 				else
1456: 				{
1457: 					F = 1.0;
1458: 				}
1459: 				float LdotN = dot(L,N);
1460: 				if( 0.0 < LdotN)
1461: 				{
1462: 					float lightVisibility = 1.0;
1463: 					LightColour = vec3(0.0);				
1464: 
1465: 					//BRDF Model Cook-Torrance
1466: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
1467: 					// Cook-Torrance Specular Result from Environment
1468: 					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-spec2rough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
1469: 					
1470: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1471: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1472: 					if(abs(_ani2) != 0) 
1473: 					{									
1474: 						// Isotropy reflection
1475: 						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
1476: 							
1477: 						// Anisotropy reflection	
1478: 						if(_ani2 != 0.0 && spec2rough2 != 0)
1479: 						{
1480: 							// Caculate how much isotropy is the material based on roughness and anisotropy values.
1481: 							float _isotropy = abs(_ani2)*(1.1-spec2rough2);	
1482: 							
1483: 							LightColour = vec3(0.0);
1484: 							float i = 0;
1485: 							for (;i < _isotropy;)
1486: 							{
1487: 							
1488: 							// Define the direction of the anisotropy
1489: 							vec3 L2 = normalize( reflect( V, _ani2 < 0? X2:Y2 ));
1490: 								
1491: 							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
1492: 							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L2, L, 1-i), clamp(_glossiness + abs(_ani2*_ani2)*(1.0-spec2rough2)/9, .1, .9) );							
1493: 							i += 0.1;
1494: 							}
1495: 							LightColour /= i*10;												
1496: 						}		
1497: 						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-spec2rough), 0.0, 1.0 );					
1498: 					}
1499: 					EnergySpecular_env2 += specterm * (LightColour);		
1500: 				
1501: 			
1502: 					// ----------REFLECTION TERM-----------
1503: 					// Reset the fresnel value, and keep the L direction from the specular above.
1504: 					
1505: 					if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1506: 					{
1507: 						F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1508: 					}
1509: 					else
1510: 					{
1511: 						F = 1.0;
1512: 					}
1513: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
1514: 					EnergyReflection_env2 += F * (LightColour);
1515: 				}	
1516: 			}		
1517: 
1518: 			
1519: 			{
1520: 				// ----------REFRACTION TERM-----------
1521: 				// Env Refraction, Light Direction			
1522: 				// Refraction incoming direction
1523: 				vec3 Li = vec3(0.0);
1524: 				if(Solid_node_83662364_52db_4f7b_b336_baca232fc310_)
1525: 				{
1526: 					Li = normalize( -refract(V, -N, (1.0/TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)) );
1527: 				}
1528: 				else
1529: 				{
1530: 					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
1531: 					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, (1.0/TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)) );
1532: 				}
1533: 				
1534: 				float lightVisibility = 1.0;
1535: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, _Refra_glossiness);		
1536: 				
1537: 				EnergyRefraction_env += (LightColour);		
1538: 							
1539: 				_Absorbance = transCol.rgb;
1540: 				if (_Absorbance != vec3(1.0) )
1541: 				{			
1542: 					_Absorbance = pow_RGB(transCol.rgb, Thickness/10);
1543: 					EnergyTransmittance = _Absorbance;
1544: 				}
1545: 				
1546: 				// *TWEAK* This will preserve some energy from the reflection that is actually passing through the surface and not been reflected by the fresnel.
1547: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1548: 				{
1549: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1550: 					vec3 L = normalize( -reflect( V, N));
1551: 					float LdotN = dot(L,N);
1552: 					// Half Vector
1553: 					vec3 H = normalize(L+V);					
1554: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);					
1555: 					EnergyRefraction_env *=  1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;			
1556: 					
1557: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1558: 					{
1559: 						F = 0.0; 
1560: 					}
1561: 					EnergyRefraction_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;				
1562: 				}		
1563: 			}	
1564: 
1565: 			{
1566: 				// ----------Sub-Surface Scattering TERM-----------
1567: 				// Env Light, Light Direction
1568: 				// Sub-Surface Scattering	
1569: 				vec3 L = N;				
1570: 				// Half Vector
1571: 				vec3 H = normalize(L+V);			
1572: 				
1573: 				float LdotN = dot(L,N);
1574: 				float LdotH = dot(L,H);
1575: 				
1576: 				float FL = mriBRDF_SchlickFresnel(LdotN);
1577: 				float FV = mriBRDF_SchlickFresnel(NdotV);			
1578: 					
1579: 				float lightVisibility = 1.0;
1580: 				
1581: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);
1582: 				
1583: 				// creates a bit of a fake impression of difusion
1584: 				vec3 mixSSSdifusion = vec3(0.0);
1585: 				for (int j=0;j<3;j++)
1586: 				{			
1587: 					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), sssRadius.rgb[j] );
1588: 				}
1589: 				vec3 Back_Scat_Color = 1.25*mixSSSdifusion;
1590: 				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
1591: 				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
1592: 				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;						
1593: 				
1594: 				EnergySSS_env += Back_Scat_Color;
1595: 				
1596: 				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1597: 				//if($DiffuseFresnel == true)
1598: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1599: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1600: 				{
1601: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1602: 					L = normalize( -reflect( V, N));
1603: 					// Half Vector
1604: 					vec3 H = normalize(L+V);					
1605: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1606: 					EnergySSS_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1607: 					
1608: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1609: 					{
1610: 						F = 0.0; // picks from the math above, since this would be a value that comes from a global attribute for the entire fresnels math.
1611: 					}
1612: 					EnergySSS_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1613: 				}
1614: 			}
1615: 			
1616: 			{
1617: 				// ----------OPACITY TERM-----------
1618: 				// Env Opacity, Light Direction			
1619: 				// Opacity incoming direction
1620: 				// It should look like a Ghost with inverted colors!
1621: 				vec3 Li = vec3(0.0);
1622: 				if(Solid_node_83662364_52db_4f7b_b336_baca232fc310_)
1623: 				{
1624: 					Li = normalize( -refract(V, -N, 1.0) );
1625: 				}
1626: 				else
1627: 				{
1628: 					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
1629: 					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, 1.0) );
1630: 				}
1631: 				float lightVisibility = 1.0;
1632: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, 1.0);		
1633: 				EnergyOpacity_env += LightColour;				
1634: 			}
1635: 		}	
1636: 		
1637: 		// AO option
1638: 		float _AO = 1.0 - AmbientOcclusion_node_83662364_52db_4f7b_b336_baca232fc310_ * State.AmbientOcclusion;
1639: 		
1640: 		// Keep in mind that Arnold does not restrict the artists with a builtin Energy Conservation! So you have some artists freedom to break the rules as you wish.
1641: 		vec3 Kd = (EnergyDiffuse+EnergyBacklight + EnergyDiffuse_env+EnergyBacklight_env) * difCol.rgb * DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * _AO;
1642: 		vec3 Ks1 = (EnergySpecular1 + EnergySpecular_env1) * specCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor1* _AO;	
1643: 		vec3 Ks2 = (EnergySpecular2 + EnergySpecular_env2) * specCol2.rgb * Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor2* _AO;	
1644: 		//vec3 Kr1 = EnergyReflection_env1 * reflCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor1 * _AO;
1645: 		//vec3 Kr2 = EnergyReflection_env2 * reflCol2.rgb * Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor2 * _AO;
1646: 		vec3 Kt = EnergyRefraction_env * EnergyTransmittance * refrCol.rgb * TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * _AO;
1647: 		vec3 Ksss = (EnergySSS + EnergySSS_env) * SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_ * sssCol.rgb * _AO;	
1648: 		vec3 Opa = EnergyOpacity_env * opacityCol.rgb;
1649: 		
1650: 		// New Mari Lighting Mode workflow.
1651: 		// Lighting Mode => 0 - "Flat" - only display the Current Channel that is selected.
1652: 		// Lighting Mode =>	1 - Basic - Display Diffuse + Sub-surface Scattering
1653: 		// Lighting Mode => 2 - Full - Adds the specular/reflection + refraction + self-illumination on top of what the Basic mode displays
1654: 		Output.rgb = u_MriLightingMode==0 ? Current_Channel_Selected.rgb : Kd+Ksss;
1655: 		Output.rgb += u_MriLightingMode!=2 ? vec3(0.0) : Ks1+Ks2+Kt;
1656: 			
1657: 		// Emission
1658: 		Output.rgb += u_MriLightingMode==2 ? EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * emisCol.rgb : vec3(0.0);
1659: 
1660: 		// Opacity
1661: 		Output.rgb = u_MriLightingMode==2 ? mix(Opa.rgb, Output.rgb, 1.0-color_toValue(opacityCol.rgb)) : Output.rgb;
1662: 				
1663: 		// If displaying "flat" lighting mode 0 use the Current Channel alpha.
1664: 		Output.a = u_MriLightingMode==0 ? node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output.a : 1.0;		
1665: 		
1666: 		
1667: 		// Render Passes Mode, the beauty pass = 0 doesn't need an if statement, it has coded above and displayed by default
1668: 		// Lighting Mode == 1 ? #Channel * $Weight : #Channel * $ChannelWeight * Lighting Contribution
1669: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 1)
1670: 		{
1671: 			Output.rgb = (u_MriLightingMode==1 ? difCol.rgb * DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kd);
1672: 		}
1673: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 2)
1674: 		{
1675: 			Output.rgb = (u_MriLightingMode==1 ? specCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ : Ks1+Ks2);
1676: 		}
1677: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 3)
1678: 		{
1679: 			Output.rgb = (u_MriLightingMode==1 ? reflCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kr1+Kr2);
1680: 		}
1681: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 4)
1682: 		{
1683: 			Output.rgb = (u_MriLightingMode==1 ? refrCol.rgb * TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kt);
1684: 		}
1685: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 5)
1686: 		{
1687: 			Output.rgb = (u_MriLightingMode==1 ? sssCol.rgb * SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_ : Ksss);
1688: 		}
1689: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 6)
1690: 		{
1691: 			Output.rgb = emisCol.rgb * EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
1692: 		}
1693: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7)
1694: 		{
1695: 			Output.rgb = vec3(1.0/Thickness);			
1696: 		}	
1697: 	}
1698: 		
1699: 	            
1700:     node_83662364_52db_4f7b_b336_baca232fc310_Output = Output;
1701: }
1702: 
1703: //=====================
1704: //--- Style 2 Node 'Viewer' ---
1705: //=====================
1706: 
1707: 
1708: uniform bool projection_through_enabled;
1709: uniform float projectionDepthTexture_Offset;
1710: uniform sampler2D projectionDepthTexture;
1711: uniform bool ao_enabled;
1712: uniform float ao_value;
1713: uniform float ao_contrast;
1714: uniform float ao_invert;
1715: uniform int ao_curve;
1716: uniform float depth_start;
1717: uniform float depth_end;
1718: uniform float depth_falloff;
1719: uniform float depth_range;
1720: uniform sampler2D marqueeSelMask;
1721: uniform float marqueeSelMaskAmount;
1722: uniform mat3x2 marqueeSelMaskMatrix;
1723: float MarqueeSelMaskFunc( vec2 uv)
1724: {
1725:     return ( 1.0 - marqueeSelMaskAmount*(1.0-texture( marqueeSelMask, ( (marqueeSelMaskMatrix * vec3( uv, 1.0)) * vec2( 0.5, -0.5)) + vec2( 0.5, 0.5)).a));
1726: }
1727: uniform bool fn_enabled;
1728: uniform float fn_maskAmount;
1729: uniform float fn_size;
1730: uniform float fn_seed;
1731: uniform float fn_roughness;
1732: uniform float fn_contrast;
1733: uniform float fn_invert;
1734: uniform int fractal_curve;
1735: 
1736: 
1737: void apply_projection_masks(inout MriFragmentState State, inout MriSystemFragmentState _State)
1738: {
1739:     float projection_exposure_multipler = projection_through_enabled ? float(_State.ProjectionCoord.z <= 1.0) : float((_State.ProjectionCoord.z-projectionDepthTexture_Offset) <= texture(projectionDepthTexture,_State.ProjectionCoord.st).r);
1740: _State.NonPreviewableProjectionExposure *= projection_exposure_multipler;
1741: float Midpoint = (depth_end+depth_start)/2.0;float Distance = (abs(Midpoint+State.FragmentPositionInEyeSpaceFromProjectionCamera.z)-abs(Midpoint-depth_start))/(Midpoint-depth_start);_State.ProjectionExposure *= clamp(Distance/depth_falloff+1.0, 0.0, 1.0);_State.NonPreviewableProjectionExposure *= MarqueeSelMaskFunc( State.FragmentPositionInNdcSpaceFromProjectionCamera.st);
1742: 
1743: }
1744: 
1745: void evaluate_shader_network(inout MriFragmentState State, inout MriSystemFragmentState _State)
1746: {
1747:         {
1748:         node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(State,_State); // Evaluating Node 'Bottom Transparency'
1749:         node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(State,_State); // Evaluating Node 'Paint 3'
1750:         node_516e4503_ea09_4104_8e31_2e667c820272_func(State,_State); // Evaluating Node 'Merge_Bump_Head'
1751:         node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(State,_State); // Evaluating Node 'Paint 4'
1752:         node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(State,_State); // Evaluating Node 'Layer'
1753:         node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(State,_State); // Evaluating Node 'Bump_Head'
1754:         node_45b7815b_0361_452e_b5c5_f476cf68940f_func(State,_State); // Evaluating Node 'Current Channel'
1755:         node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(State,_State); // Evaluating Node 'alSurfaceX/Height As Normal'
1756:         node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(State,_State); // Evaluating Node 'alSurfaceX/Normal Modulation'
1757:         node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(State,_State); // Evaluating Node 'alSurfaceX/Tangent Space To Eye Space'
1758:         node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(State,_State); // Evaluating Node 'alSurfaceX/Color To Vector'
1759:         node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(State,_State); // Evaluating Node 'alSurfaceX/Tangent Space To Eye Space 2'
1760:         node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(State,_State); // Evaluating Node 'alSurfaceX/Set Unlit'
1761:         node_83662364_52db_4f7b_b336_baca232fc310_func(State,_State); // Evaluating Node 'alSurfaceX/'
1762:         {
1763: 
1764:     _State.Diffuse = node_83662364_52db_4f7b_b336_baca232fc310_Output;
1765:                 
1766:         }
1767:     }
1768: 
1769: }
1770: 
1771: 
0(1679) : error C1008: undefined variable "Kr1"
0(1679) : error C1008: undefined variable "Kr2"

---CompilerLog---
0(1679) : error C1008: undefined variable "Kr1"
0(1679) : error C1008: undefined variable "Kr2"


Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 411 ms uu 69 FAILED
Debug : [   mrisnglslcontextmanager.cpp:748 ] : Reloading Shader 'Shader Network1'
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:711 ] : [ !! ] Shader 'Shader Network1' Compilation Failure. Not linking.
---SourceCode---
Shader Type: Fragment
1: #version 150
2: #define MRI_SHADER_FRAGMENT 1
3: #define MRI_NUM_PATCH_ATTRIBUTES 4096
4: #define MRI_SVT_GATHER_USE_QUINT 1
5: #define MRI_USE_CUBE_MAP_ARRAY 1
6: #define USE_DEFERRED_TEXTURE_2D_ARRAY 1
7: 
8: //! Description |  Shader Network evaluation fragment shader
9: //! Name |  Func_ShaderNetwork.frag
10: //! Author |  Jack Greasley, Kiyoyuki Nakagaki, Duncan Hopkins
11: //! Copyright |  Copyright (c) 2013 The Foundry 
12: 
13: #define MRI_LIGHT_ARRAY_SIZE 4
14: 
15: struct MriSystemFragmentState
16: {
17:     vec4 Diffuse;
18:     vec4 Unlit;
19:     vec4 VectorData;
20: 
21:     vec2 dUV;
22: 
23:     vec3 ProjectionCoord;
24:     vec2 TangentInProjectionSpace;
25:     vec2 BitangentInProjectionSpace;
26: 
27:     bool Hidden;
28:     bool Locked;
29:     bool Selected;
30: 
31:     float ProjectionExposure;
32:     float NonPreviewableProjectionExposure;
33: 
34:     bool PatchSelected;
35:     bool FaceSelected;
36:     bool ObjectSelected;
37: 
38:     float TriangleId;
39:     float TileId; 
40:     float MipLevel;
41: 
42:     bool GeoExists;
43: };
44: 
45: struct MriFragmentState
46: {
47:     float AmbientOcclusion;
48: 
49:     vec3 Position;
50:     vec2 UV;
51:     vec3 Normal;
52:     vec3 Tangent;
53:     vec3 Bitangent;
54: 
55:     vec3 NormalInEyeSpaceFromViewCamera;
56:     vec3 TangentInEyeSpaceFromViewCamera;
57:     vec3 BitangentInEyeSpaceFromViewCamera;
58:     vec3 ViewVectorInEyeSpaceFromViewCamera;
59:     vec3 FragmentPositionInEyeSpaceFromViewCamera;
60: 
61:     vec3 NormalInEyeSpaceFromProjectionCamera;
62:     vec3 TangentInEyeSpaceFromProjectionCamera;
63:     vec3 BitangentInEyeSpaceFromProjectionCamera;
64:     vec3 ViewVectorInEyeSpaceFromProjectionCamera;
65: 
66:     vec3 FragmentPositionInEyeSpaceFromProjectionCamera;
67:     vec3 FragmentPositionInNdcSpaceFromProjectionCamera;
68: 
69:     float PatchId;
70:     int   FaceId;
71:     int   FaceIndex;
72: };
73: 
74: struct Channel
75: {
76:     // r - int index; 
77:     // g - bool active;
78:     // b - bool invert;
79:     ivec3 ChannelValues;
80:     // a - reserved
81: };
82: 
83: #if defined( USE_DEPTH_PROJECTIONS)
84: struct MriLight
85: {
86:     int depthProjectorIndex;
87:     int depthProjectorCount;
88: };
89: 
90: struct MriDepthProjection
91: {
92:     mat4 transform;
93: };
94: #endif
95: 
96: 
97: //Gives the true texture coordinates for the base texture
98: vec2 svt_coords(vec2 coords);
99: 
100: //This function gives the raw color value from the texture in Base channel without any filters or projection applied 
101: vec4 svt_texture(Channel Base, vec2 coords);
102: vec4 svt_texture(Channel Base, in MriFragmentState State, in MriSystemFragmentState _State);
103: 
104: //Collect height values from bump map
105: vec4 get_heights(Channel Base, vec2 coords);
106: 
107: //This function gives the color value from the texture in Base channel with some filters and projection applied if applicable
108: vec4 texture_lookup(Channel Base, vec2 coords);
109: 
110: //texture look up function for version 2.0
111: vec4 texture_lookup2(Channel Base, in MriFragmentState State, in MriSystemFragmentState _State);
112: 
113: float tex_mip_level(vec2 coord);
114: 
115: //Default shadow casting function
116: float mriLightVisibility( in int LightIndex, vec3 FragmentPosition);
117: 
118: //Functions for evaluating values with a bit of UV offset.
119: float dFdu(float F);
120: float dFdv(float F);
121: vec2 dFdu(vec2 F);
122: vec2 dFdv(vec2 F);
123: mat2 dFd(vec2 F);
124: vec3 dFdu(vec3 F);
125: vec3 dFdv(vec3 F);
126: mat2x3 dFd(vec3 F);
127: 
128: float F(float f0, vec2 dUV);
129: vec2 F(vec2 f0, vec2 dUV);
130: vec3 F(vec3 f0, vec2 dUV);
131: 
132: void apply_projection_masks(inout MriFragmentState State, inout MriSystemFragmentState _State);
133: 
134: void evaluate_shader_network(inout MriFragmentState State, inout MriSystemFragmentState _State);
135: 
136: 
137: #define MRI_LIGHT_ARRAY_SIZE 4
138: 
139: // DO NOT CHANGE this structure with out adjusting the uniform upload C++ code.
140: struct MriLightSource
141: {
142:     vec4 Position;
143: 
144:     vec4 AmbientColor;
145:     vec4 DiffuseColor;
146:     vec4 SpecularColor;
147: 
148:     float SpotCutoff;
149:     float SpotExponent;
150: 
151:     float ConstantAttenuation;
152:     float LinearAttenuation;
153:     float QuadraticAttenuation;
154: };
155: 
156: // Returns the lighting value to use from the external environment map
157: //  shapness - how clear or blurred the light source is
158: //   0.0 - Totally blurred light sources. same as using dot( normal, light) calculation
159: //   1.0 - Totally sharp
160: vec3 mriEnvironmentLight( in vec3 normal, in float sharpness);
161: bool mriEnvironmentLightOn();
162: 
163: 
164: float mriBRDF_sqr(float x);
165: 
166: float mriBRDF_SchlickFresnel(float u);
167: float mriBRDF_GTR1(float NdotH, float a);
168: float mriBRDF_GTR2(float NdotH, float a);
169: float mriBRDF_GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay);
170: float mriBRDF_smithG_GGX(float Ndotv, float alphaG);
171: vec3 mriBRDF_mon2lin(vec3 x);
172: 
173: 
174: ////////////////////////////////////////////////////////////////////////////////
175: // Custom BRDF Function Library Extension Registration
176: // Copyright (c) 2014 Antonio Lisboa M. Neto. All Rights Reserved.
177: //////////////////////////////////////////////////////////////////////////////// 
178: // File: BRDF_FunctionLib_ext.glslc	
179: // Description: Function Library Extension for be used in the new Custom BRDF Shaders
180: ////////////////////////////////////////////////////////////////////////////////               	
181: // Author: Antonio Neto       	
182: // Web: www.netocg.blogspot.com			
183: // Email: netocg.fx@gmail.com
184: ////////////////////////////////////////////////////////////////////////////////			                                   	
185: // Date: Jan 25, 2014	         		
186: ////////////////////////////////////////////////////////////////////////////////
187: 
188: float att(vec3 L, int Light_Falloff, float Decay_Rate);
189: float color_toValue(vec3 Color);
190: vec3 pow_RGB(vec3 Color, float Value);
191: vec3 convert_Colorspace(vec3 color, int Colorspace_Profile);
192: float mriBRDF_Fresnel(vec3 L, vec3 H, float eta);
193: float mriBRDF_Fresnel_Schlicks(vec3 L, vec3 H, float Reflectance);
194: float mriBRDF_Fresnel_Dielectric(vec3 L, vec3 H, float ior);
195: float mriBRDF_Fresnel_Conductor(vec3 L, vec3 H, float eta, float k);
196: float nfresnel(float cos_theta_r, float eta);
197: float mriBRDF_Oren_Nayar(vec3 N, vec3 V, vec3 L, float difrough2);
198: float mriBRDF_Beckman(vec3 N, vec3 H, float specrough2);
199: float mriBRDF_Geo_att_Cook_Torrance(vec3 N, vec3 H, vec3 V, vec3 L);
200: float mriBRDF_Ward(vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specrough2);
201: float mriBRDF_Geo_att_Ward_Duer( vec3 L, vec3 V, vec3 N, vec3 H);
202: float mriBRDF_Ashikhmin_Shirley( vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specrough2);
203: float mriBRDF_Geo_Att_Ash_Sh00( vec3 N, vec3 V, vec3 L);
204: float mriBRDF_Blinn(vec3 N, vec3 H, float specrough2);
205: float mriBRDF_Geo_att_Schlick_Smith(vec3 N, vec3 L, vec3 V, float specrough2);
206: float mriBRDF_Phong(vec3 N, vec3 V, vec3 H, float specrough2);
207: float mriBRDF_Geo_att_Beckmann(vec3 N, vec3 V, float specrough2);
208: float mriBRDF_GTR(vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specGloss, float ggxTailFalloff);
209: float mriBRDF_Geo_att_smithG_GGX(float NdotV, float specGloss);
210: 
211: /****************************************************************************
212: * Camera information
213: *****************************************************************************/
214: // camera type of the current view
215: // 0 - Perspective
216: // 1 - Ortho
217: // 2 - UV
218: uniform int u_MriViewType;
219: 
220: // x:left, y:top, z:right, w:bottom
221: uniform vec4 u_MriViewport;
222: 
223: /****************************************************************************
224: * Matrices
225: *****************************************************************************/
226: uniform mat4 u_MriViewMatrix;
227: uniform mat4 u_MriModelViewMatrix;
228: uniform mat4 u_MriProjectionMatrix;
229: uniform mat4 u_MriNormalMatrix;
230: 
231: /****************************************************************************
232: * Object information
233: *****************************************************************************/
234: uniform int u_MriObjectId;
235: uniform vec3 u_MriObjectCenter;
236: uniform float u_MriObjectRadius;
237: 
238: /****************************************************************************
239: * Light information
240: *****************************************************************************/
241: //Lighting mode
242: // 0 - Flat
243: // 1 - Basic (Diffuse only)
244: // 2 - Full
245: uniform int u_MriLightingMode;
246: 
247: uniform MriLightSource u_MriLightSources[MRI_LIGHT_ARRAY_SIZE];
248: 
249: /****************************************************************************
250: * Misc
251: *****************************************************************************/
252: // The current animation frame
253: uniform int u_MriCurrentFrame;
254: 
255: // The system time in milliseconds. Will wrap every ~70 minutes.
256: uniform int u_MriSystemTime;
257: 
258: uniform vec2 u_MriMaxSupportedTextureSize;
259: 
260: 
261: 
262: float mriColorBlend(float pixel, float fPixel, float bPixel, float fAlpha, float bAlpha, int normal);
263: vec3 mriColorBlendv(vec3 modifiedColor, vec3 layerColor, vec3 baseColor, float layerAlpha, float baseAlpha, int normal);
264: float mriAlphaBlend( float fAlpha, float bAlpha);
265: float mriRgb2Lightness(vec4 RGBA);
266: vec4 mriRgb2Hsl(vec4 colorIn);
267: vec4 mriHsl2Rgb(vec4 colorIn);
268: vec4 mriRgb2Hsv(vec4 colorIn);
269: vec4 mriHsv2Rgb(vec4 colorIn);
270: 
271: vec4 Comp_Add(vec4 base,vec4 blend,float Opacity);
272: vec4 Comp_BurnHighlights(vec4 base,vec4 blend,float Opacity);
273: vec4 Comp_BurnMidrange(vec4 base,vec4 blend,float Opacity);
274: vec4 Comp_BurnShadows(vec4 base,vec4 blend,float Opacity);
275: vec4 Comp_Clear(vec4 base,vec4 blend,float Opacity);
276: vec4 Comp_Color(vec4 base,vec4 blend,float Opacity);
277: vec4 Comp_ColorBurn(vec4 base,vec4 blend,float Opacity);
278: vec4 Comp_ColorDodge(vec4 base,vec4 blend,float Opacity);
279: vec4 Comp_Copy(vec4 base,vec4 blend,float Opacity);
280: vec4 Comp_CopyRGB(vec4 base,vec4 blend,float Opacity);
281: vec4 Comp_Darken(vec4 base,vec4 blend,float Opacity);
282: vec4 Comp_Default(vec4 base,vec4 blend,float Opacity);
283: vec4 Comp_Difference(vec4 base,vec4 blend,float Opacity);
284: vec4 Comp_DodgeHighlights(vec4 base,vec4 blend,float Opacity);
285: vec4 Comp_DodgeMidrange(vec4 base,vec4 blend,float Opacity);
286: vec4 Comp_DodgeShadows(vec4 base,vec4 blend,float Opacity);
287: vec4 Comp_Exclusion(vec4 base,vec4 blend,float Opacity);
288: vec4 Comp_HardLight(vec4 base,vec4 blend,float Opacity);
289: vec4 Comp_HardMix(vec4 base,vec4 blend,float Opacity);
290: vec4 Comp_Hue(vec4 base,vec4 blend,float Opacity);
291: vec4 Comp_InverseDifference(vec4 base,vec4 blend,float Opacity);
292: vec4 Comp_Invert(vec4 base,vec4 blend,float Opacity);
293: vec4 Comp_Lighten(vec4 base,vec4 blend,float Opacity);
294: vec4 Comp_Luminance(vec4 base,vec4 blend,float Opacity);
295: vec4 Comp_Multiply(vec4 base,vec4 blend,float Opacity);
296: vec4 Comp_Overlay(vec4 base,vec4 blend,float Opacity);
297: vec4 Comp_PinLight(vec4 base,vec4 blend,float Opacity);
298: vec4 Comp_Saturation(vec4 base,vec4 blend,float Opacity);
299: vec4 Comp_Screen(vec4 base,vec4 blend,float Opacity);
300: vec4 Comp_SoftLight(vec4 base,vec4 blend,float Opacity);
301: vec4 Comp_SpongeDesaturate(vec4 base,vec4 blend,float Opacity);
302: vec4 Comp_VividLight(vec4 base,vec4 blend,float Opacity);
303: vec4 Comp_Contrast(vec4 base,vec4 blend,float Opacity);
304: vec4 Comp_Decontrast(vec4 base,vec4 blend,float Opacity);
305: vec4 Comp_MixRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
306: vec4 Comp_AddRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
307: vec4 Comp_ReorientedNormalMappingRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
308: 
309: // Blending functions the operate on the color channels only. Used by things such as color adjustments where the alpha channel needs to be ignored.
310: vec4 Comp_Default(vec4 Base, vec3 Blend, float Amount);
311: vec4 Comp_Add(vec4 Base, vec3 Blend, float Amount);
312: vec4 Comp_Color(vec4 Base, vec3 Blend, float Amount);
313: vec4 Comp_Copy(vec4 Base, vec3 Blend, float Amount);
314: vec4 Comp_CopyRGB(vec4 Base, vec3 Blend, float Amount);
315: vec4 Comp_Darken(vec4 Base, vec3 Blend, float Amount);
316: vec4 Comp_Difference(vec4 Base, vec3 Blend, float Amount);
317: vec4 Comp_Hue(vec4 Base, vec3 Blend, float Amount);
318: vec4 Comp_InverseDifference(vec4 Base, vec3 Blend, float Amount);
319: vec4 Comp_Lighten(vec4 Base, vec3 Blend, float Amount);
320: vec4 Comp_Luminance(vec4 Base, vec3 Blend, float Amount);
321: vec4 Comp_Multiply(vec4 Base, vec3 Blend, float Amount);
322: vec4 Comp_Saturation(vec4 Base, vec3 Blend, float Amount);
323: 
324: vec4 Comp_VecDefault2d(vec4 base,vec4 blend,float Opacity);
325: vec4 Comp_VecDefault3d(vec4 base,vec4 blend,float Opacity);
326: 
327: vec4 Comp_VecAdd3d(vec4 base,vec4 blend,float Opacity);
328: vec4 Comp_VecAdd2d(vec4 base,vec4 blend,float Opacity);
329: 
330: vec4 Comp_VecScale3d(vec4 base,vec4 blend,float Opacity);
331: 
332: //! macro | custom_blend_mode_declarations | // No custom blend modes
333: 
334: 
335: 
336: 
337: //Curve lookup functions
338: 
339: float mriCurveLookup( in int Line, in float InValue);
340: 
341: 
342: 
343: 
344: /****************************************************************************
345: * Noise functions
346: *****************************************************************************/
347: 
348: //These functions generate Perlin and Simplex noise from 2D,3D,4D inputs
349: float mriPerlinNoise(vec2 P);
350: float mriPerlinNoise(vec3 P);
351: float mriPerlinNoise(vec4 P);
352: float mriSimplexNoise(vec2 P);
353: float mriSimplexNoise(vec3 P);
354: float mriSimplexNoise(vec4 P);
355: 
356: // DEPRECATED in favor of more explicit function names above
357: float mriNoise(vec3 P); 
358: 
359: 
360: //Cellular (Worley) noise generation function based on 3D input and different types of norm(distance) calculation. This returns vec3 in which F1, F2 and F1-F2 are returned in r, g and b of the resulting vec3 respectively. Cellular noise is a noise obtained by calculating distance to randomly generated points. The definition of the distance is the norm. F1 is the distance to the closest point while F2 is the distance to the 2nd closest point.  
361: // norm - The norm(distance calculation) definition to use. 
362: //  0 : Manhattan norm
363: //  1 : Euclidian norm
364: //  2 : Chebyshev(Infinity) norm
365: //  3 : P-norm where P=0.5
366: vec3 mriCellular(vec3 P, int norm);
367: 
368: // DEPRECATED
369: // These functions are provided for backward compatibility since the older version of Mari had these.
370: // These are deprecated and to be removed in favor of more explicitly named functions above.
371: float noise(vec3 P);
372: vec3 cellular(vec3 P, int norm);
373: 
374: 
375: 
376: 
377: //Given the face index at the evaluation point (usually the fragment), this returns hiddenness, lockedness and selectedness of the face in r,g and b respectively.
378: //the a component is currently not used, but reserved for the future usage
379: vec4 mriFaceSystemAttribute(int FaceIndex);
380: 
381: //Given the primitiveID, returns the face index of the original mesh
382: int mriFaceIndex(int PrimitiveID);
383: 
384: 
385: 
386: /****************************************************************************
387: * Misc
388: *****************************************************************************/
389: //This is an untility function to do the implementation of how to interpret a given color value as a mask. Whoever needs to regard some color value as mask should call this function for consistent mechanism
390: float interpretAsExposure(in vec4 Color,int Mode);
391: 
392: 
393: 
394: 
395: // Function for handling standard Vector Painting Maths
396: 
397: vec3 vector_bias( vec3 vector);
398: vec3 vector_unbias( vec3 colour);
399: 
400: vec3 vector_paintToTangent3D( vec3 screen);
401: vec3 vector_paintToTangent2D( vec3 screen);
402: 
403: vec3 vector_worldToTangent( vec3 tangent);
404: vec3 vector_tangentToWorld( vec3 tangent);
405: vec3 vector_tangentToScreen( vec3 tangent);
406: 
407: 
408: 
409: //! macro | module_inputs | // No Module Inputs
410: //! macro | module_calls  | // No Module Calls
411: //! macro | module_declarations  | // No Module Declarations
412: 
413: //! macro | surface_mask_declarations | // No mask applied
414: //! macro | surface_mask_body         | // No mask applied
415: 
416: uniform int udim_size;
417: 
418: void store_state(inout MriFragmentState State, inout MriSystemFragmentState _State);
419: void derive_state(inout MriFragmentState State, inout MriSystemFragmentState _State, float du, float dv);
420: void restore_state(inout MriFragmentState State, inout MriSystemFragmentState _State);
421: 
422: #define REVAL(func,du,dv) store_state(State, _State);derive_state(State, _State, du, dv);func(State,_State);restore_state(State, _State);
423: 
424: 
425: 
426: float olefresnel(float r, float g, float c);
427: float get_n(float r,float g);
428: float get_k2(float r, float n);
429: float n_min(float r);
430: float n_max(float r);
431: vec3 FresnelConductor(vec3 Refelctivity, vec3 EdgeTint,float cos_theta);//=====================
432: // Forward Declaration of functions
433: //=====================
434: 
435: void node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
436: void node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
437: void node_516e4503_ea09_4104_8e31_2e667c820272_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
438: void node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
439: void node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
440: void node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
441: void node_45b7815b_0361_452e_b5c5_f476cf68940f_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
442: void node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
443: void node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
444: void node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
445: void node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
446: void node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
447: void node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
448: void node_83662364_52db_4f7b_b336_baca232fc310_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
449: 
450: //=====================
451: // Declaration of functions
452: //=====================
453: 
454: //=====================
455: //--- Style 2 Node 'Bottom Transparency' ---
456: //=====================
457: vec4 node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output; // Output 'Output' 
458: void node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
459: {
460:     vec4 Output; // Output 'Output' 
461: 
462:     Output = vec4( 0, 0, 0, 0);
463:         
464:     node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output = Output;
465: }
466: 
467: //=====================
468: //--- Style 2 Node 'Paint 3' ---
469: //=====================
470: uniform Channel Channel_node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_;
471: vec4 node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output; // Output 'Output' 
472: void node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
473: {
474:     vec4 Output; // Output 'Output' 
475: 
476:                   
477:         Output = texture_lookup2(Channel_node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_,State,_State);
478:                   
479:               
480:     node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output = Output;
481: }
482: 
483: //=====================
484: //--- Style 2 Node 'Merge_Bump_Head' ---
485: //=====================
486: uniform int AdvancedEnabled_node_516e4503_ea09_4104_8e31_2e667c820272_;
487: uniform float Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
488: uniform int AmountEnabled_node_516e4503_ea09_4104_8e31_2e667c820272_;
489: uniform int BlendIfBelow_node_516e4503_ea09_4104_8e31_2e667c820272_;
490: uniform int BlendIfThis_node_516e4503_ea09_4104_8e31_2e667c820272_;
491: uniform int BlendMode_node_516e4503_ea09_4104_8e31_2e667c820272_;
492: uniform int Component_node_516e4503_ea09_4104_8e31_2e667c820272_;
493: uniform int SwizzleA_node_516e4503_ea09_4104_8e31_2e667c820272_;
494: uniform int SwizzleB_node_516e4503_ea09_4104_8e31_2e667c820272_;
495: uniform int SwizzleG_node_516e4503_ea09_4104_8e31_2e667c820272_;
496: uniform int SwizzleR_node_516e4503_ea09_4104_8e31_2e667c820272_;
497: vec4 node_516e4503_ea09_4104_8e31_2e667c820272_Output; // Output 'Output' 
498: void node_516e4503_ea09_4104_8e31_2e667c820272_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
499: {
500:     vec4 Output; // Output 'Output' 
501: 
502:     if( 0 != 0)
503:     {
504:         // this is used to control what component we are pulling the key from
505:         vec3 Mult[5];
506: 
507:         Mult[0] = vec3(1.0/3.0,1.0/3.0,1.0/3.0);
508:         Mult[1] = vec3(1,0,0);
509:         Mult[2] = vec3(0,1,0);
510:         Mult[3] = vec3(0,0,1);
511:         Mult[4] = vec3(0.2126,0.7152,0.0722);
512: 
513: 
514:         // Calculate the amount from the component
515:         // a Mult value of (1,0,0) will isolate the red value
516:         // A mult value of (1,1,1) will give a gray scale
517: 
518:         float ThisAmount = dot(node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output.rgb , Mult[0]);
519:         float BelowAmount = dot(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output.rgb , Mult[0]);
520: 
521:         // now that we've pulled the component out of above and below
522:         // we lookup into the lut to find out the amount to scale the alpha values by
523: 
524:         float ThisAlpha  = mriCurveLookup(BlendIfThis_node_516e4503_ea09_4104_8e31_2e667c820272_,ThisAmount);
525:         float BelowAlpha = mriCurveLookup(BlendIfBelow_node_516e4503_ea09_4104_8e31_2e667c820272_,BelowAmount);
526: 
527:         // now we multiply the base alpha value by both values
528: 
529:         float AdvancedBlendAmount = ThisAlpha * BelowAlpha;
530:         if( 0 != 1)
531:         {
532:             AdvancedBlendAmount *= Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
533:         }
534: 
535:         Output = Comp_Default(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output, node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output, vec4(1,1,1,1).r * AdvancedBlendAmount);
536:     }
537:     else
538:     {
539:         float BlendAmount = 1;
540:         if( 0 != 1)
541:         {
542:             BlendAmount *= Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
543:         }
544:         Output = Comp_Default(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output, node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output, BlendAmount * vec4(1,1,1,1).r);
545:     }
546: 
547:     Output = vec4( Output.r, Output.g, Output.b, Output.a);
548: 
549:                 
550:     node_516e4503_ea09_4104_8e31_2e667c820272_Output = Output;
551: }
552: 
553: //=====================
554: //--- Style 2 Node 'Paint 4' ---
555: //=====================
556: uniform Channel Channel_node_5ab26bd0_71fd_473d_ba94_940da940e2a5_;
557: vec4 node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output; // Output 'Output' 
558: void node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
559: {
560:     vec4 Output; // Output 'Output' 
561: 
562:                   
563:         Output = texture_lookup2(Channel_node_5ab26bd0_71fd_473d_ba94_940da940e2a5_,State,_State);
564:                   
565:               
566:     node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output = Output;
567: }
568: 
569: //=====================
570: //--- Style 2 Node 'Layer' ---
571: //=====================
572: uniform int AdvancedEnabled_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
573: uniform float Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
574: uniform int AmountEnabled_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
575: uniform int BlendIfBelow_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
576: uniform int BlendIfThis_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
577: uniform int BlendMode_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
578: uniform int Component_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
579: uniform int SwizzleA_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
580: uniform int SwizzleB_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
581: uniform int SwizzleG_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
582: uniform int SwizzleR_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
583: vec4 node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output; // Output 'Output' 
584: void node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
585: {
586:     vec4 Output; // Output 'Output' 
587: 
588:     if( 0 != 0)
589:     {
590:         // this is used to control what component we are pulling the key from
591:         vec3 Mult[5];
592: 
593:         Mult[0] = vec3(1.0/3.0,1.0/3.0,1.0/3.0);
594:         Mult[1] = vec3(1,0,0);
595:         Mult[2] = vec3(0,1,0);
596:         Mult[3] = vec3(0,0,1);
597:         Mult[4] = vec3(0.2126,0.7152,0.0722);
598: 
599: 
600:         // Calculate the amount from the component
601:         // a Mult value of (1,0,0) will isolate the red value
602:         // A mult value of (1,1,1) will give a gray scale
603: 
604:         float ThisAmount = dot(node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output.rgb , Mult[0]);
605:         float BelowAmount = dot(node_516e4503_ea09_4104_8e31_2e667c820272_Output.rgb , Mult[0]);
606: 
607:         // now that we've pulled the component out of above and below
608:         // we lookup into the lut to find out the amount to scale the alpha values by
609: 
610:         float ThisAlpha  = mriCurveLookup(BlendIfThis_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_,ThisAmount);
611:         float BelowAlpha = mriCurveLookup(BlendIfBelow_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_,BelowAmount);
612: 
613:         // now we multiply the base alpha value by both values
614: 
615:         float AdvancedBlendAmount = ThisAlpha * BelowAlpha;
616:         if( 0 != 1)
617:         {
618:             AdvancedBlendAmount *= Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
619:         }
620: 
621:         Output = Comp_Default(node_516e4503_ea09_4104_8e31_2e667c820272_Output, node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output, vec4(1,1,1,1).r * AdvancedBlendAmount);
622:     }
623:     else
624:     {
625:         float BlendAmount = 1;
626:         if( 0 != 1)
627:         {
628:             BlendAmount *= Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
629:         }
630:         Output = Comp_Default(node_516e4503_ea09_4104_8e31_2e667c820272_Output, node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output, BlendAmount * vec4(1,1,1,1).r);
631:     }
632: 
633:     Output = vec4( Output.r, Output.g, Output.b, Output.a);
634: 
635:                 
636:     node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output = Output;
637: }
638: 
639: //=====================
640: //--- Style 2 Node 'Bump_Head' ---
641: //=====================
642: vec4 node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output; // Output 'Output' 
643: void node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
644: {
645:     vec4 Output; // Output 'Output' 
646: 
647:     Output = node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output;
648:                 
649:     node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output = Output;
650: }
651: 
652: //=====================
653: //--- Style 2 Node 'Current Channel' ---
654: //=====================
655: vec4 node_45b7815b_0361_452e_b5c5_f476cf68940f_Output; // Output 'Output' 
656: void node_45b7815b_0361_452e_b5c5_f476cf68940f_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
657: {
658:     vec4 Output; // Output 'Output' 
659: 
660:     Output = node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output;
661:                 
662:     node_45b7815b_0361_452e_b5c5_f476cf68940f_Output = Output;
663: }
664: 
665: //=====================
666: //--- Style 2 Node 'alSurfaceX/Height As Normal' ---
667: //=====================
668: uniform int BumpMode_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_;
669: uniform float BumpWeight_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_;
670: vec4 node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output; // Output 'Output' 
671: void node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
672: {
673:     vec4 Output; // Output 'Output' 
674: 
675:     // distance in texture space [0,1] between adjacent pixels at this mip level
676:     float Offset = exp2(_State.MipLevel)/u_MriMaxSupportedTextureSize.x;
677: 
678:     float BumpWeight = BumpWeight_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_/Offset;
679: 
680: 
681: #if 0
682:     // fudge factor
683:     BumpWeight *= 1.0/(30.0 * 16.0);
684: 
685:     // Bump mapping version A
686:     //Default Input Used : NO REVAL(Heightfunc,-Offset,0.0);
687:     float l=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
688: 
689:     //Default Input Used : NO REVAL(Heightfunc,Offset,0.0);
690:     float r=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
691: 
692:     //Default Input Used : NO REVAL(Heightfunc,0.0,-Offset);
693:     float b=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
694: 
695:     //Default Input Used : NO REVAL(Heightfunc,0.0,Offset);
696:     float t=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
697: 
698:     vec2 heightDelta = vec2( l - r, b - t);
699: #else
700:     // fudge factor
701:     BumpWeight *= 2.0/(30.0 * 16.0);
702: 
703:     // Bump mapping version A
704:     float c=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
705: 
706:     //Default Input Used : NO REVAL(Heightfunc,Offset,0.0);
707:     float r=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
708: 
709:     //Default Input Used : NO REVAL(Heightfunc,0.0,Offset);
710:     float t=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
711: 
712:     vec2 heightDelta = vec2( c - r, c - t);
713: #endif
714: 
715:     Output.rgb = normalize( vec3(heightDelta,1.0) ) * vec3(0.5,-0.5,0.5) + vec3(0.5); 
716:     Output.a = 1.0; 
717:                 
718:     node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output = Output;
719: }
720: 
721: //=====================
722: //--- Style 2 Node 'alSurfaceX/Normal Modulation' ---
723: //=====================
724: vec4 node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output; // Output 'Output' 
725: void node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
726: {
727:     vec4 Output; // Output 'Output' 
728: 
729:         vec3 norm = vec3(0.0, 0.0, 0.0);
730:         vec3 norm0 = vec4(0.5,0.5,1.0,1.0).rgb * 2.0 -1.0;
731:         vec3 norm1 = node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output.rgb * 2.0 - 1.0;
732: 
733:         norm += dot(norm0.xy,norm0.xy)>0.0 ? norm0  : vec3(0.0);
734:         norm += dot(norm1.xy,norm1.xy)>0.0 ? norm1  : vec3(0.0);
735: 
736:         //When there is no bump/normal, set it to default
737:         norm = dot(norm,norm)>0.0 ? norm  : vec3(0.0,0.0,1.0);
738: 
739:         Output.rgb = normalize(norm);
740:         Output.a = 1.0;
741:                 
742:     node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output = Output;
743: }
744: 
745: //=====================
746: //--- Style 2 Node 'alSurfaceX/Tangent Space To Eye Space' ---
747: //=====================
748: vec4 node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output; // Output 'Output' 
749: void node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
750: {
751:     vec4 Output; // Output 'Output' 
752: 
753:     mat3 tangentSpace2eyeSpace = mat3(
754:         State.TangentInEyeSpaceFromViewCamera,
755:         State.BitangentInEyeSpaceFromViewCamera,
756:         State.NormalInEyeSpaceFromViewCamera
757:     );
758:     Output.rgb = normalize( tangentSpace2eyeSpace * (node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output.rgb * vec3( 1,-1,1)));
759:     Output.a = node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output.a;
760:                 
761:     node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output = Output;
762: }
763: 
764: //=====================
765: //--- Style 2 Node 'alSurfaceX/Color To Vector' ---
766: //=====================
767: vec4 node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output; // Output 'Output' 
768: void node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
769: {
770:     vec4 Output; // Output 'Output' 
771: 
772:         vec3 norm = (vec4(1.0,0.5,0.5,1.0).rgb * 2.0) - 1.0;
773: 
774:         Output.rgb = norm;
775:         Output.a = 1.0;
776:                 
777:     node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output = Output;
778: }
779: 
780: //=====================
781: //--- Style 2 Node 'alSurfaceX/Tangent Space To Eye Space 2' ---
782: //=====================
783: vec4 node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output; // Output 'Output' 
784: void node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
785: {
786:     vec4 Output; // Output 'Output' 
787: 
788:     mat3 tangentSpace2eyeSpace = mat3(
789:         State.TangentInEyeSpaceFromViewCamera,
790:         State.BitangentInEyeSpaceFromViewCamera,
791:         State.NormalInEyeSpaceFromViewCamera
792:     );
793:     Output.rgb = normalize( tangentSpace2eyeSpace * (node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output.rgb * vec3( 1,-1,1)));
794:     Output.a = node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output.a;
795:                 
796:     node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output = Output;
797: }
798: 
799: //=====================
800: //--- Style 2 Node 'alSurfaceX/Set Unlit' ---
801: //=====================
802: vec4 node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output; // Output 'Output' 
803: void node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
804: {
805:     vec4 Output; // Output 'Output' 
806: 
807: 
808:     _State.Unlit = ((_State.Unlit.a==0.0) ? node_45b7815b_0361_452e_b5c5_f476cf68940f_Output : _State.Unlit);
809:     Output = node_45b7815b_0361_452e_b5c5_f476cf68940f_Output;
810:                 
811:     node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output = Output;
812: }
813: 
814: //=====================
815: //--- Style 2 Node 'alSurfaceX/' ---
816: //=====================
817: uniform float AmbientOcclusion_node_83662364_52db_4f7b_b336_baca232fc310_;
818: uniform vec4 BacklightColor_node_83662364_52db_4f7b_b336_baca232fc310_;
819: uniform float BacklightIndirectStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
820: uniform float BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
821: uniform bool ConvertToGlossiness_node_83662364_52db_4f7b_b336_baca232fc310_;
822: uniform float Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_;
823: uniform vec4 DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_;
824: uniform float DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
825: uniform float DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
826: uniform vec4 EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
827: uniform float EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
828: uniform int Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_;
829: uniform vec4 Opacity_node_83662364_52db_4f7b_b336_baca232fc310_;
830: uniform int Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_;
831: uniform vec4 SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_;
832: uniform vec4 SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_;
833: uniform float SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_;
834: uniform bool Solid_node_83662364_52db_4f7b_b336_baca232fc310_;
835: uniform float Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
836: uniform vec4 Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
837: uniform vec4 Specular1EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_;
838: uniform int Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_;
839: uniform float Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_;
840: uniform vec4 Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_;
841: uniform float Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
842: uniform float Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
843: uniform float Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;
844: uniform float Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
845: uniform vec4 Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_;
846: uniform vec4 Specular2EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_;
847: uniform int Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_;
848: uniform float Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_;
849: uniform vec4 Specular2Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_;
850: uniform float Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
851: uniform float Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
852: uniform float Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_;
853: uniform vec4 TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
854: uniform float TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_;
855: uniform bool TransmissionLinkToSpecular1_node_83662364_52db_4f7b_b336_baca232fc310_;
856: uniform float TransmissionRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
857: uniform float TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
858: uniform int shadingNode_node_83662364_52db_4f7b_b336_baca232fc310_;
859: vec4 node_83662364_52db_4f7b_b336_baca232fc310_Output; // Output 'Output' 
860: void node_83662364_52db_4f7b_b336_baca232fc310_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
861: {
862:     vec4 Output; // Output 'Output' 
863: 
864: 	shadingNode_node_83662364_52db_4f7b_b336_baca232fc310_; 
865: 	// Used for continually Mark what shader you are using in case you have renamed the name of the shader inside Mari. This var is also used for the exporter to identify what shader he is picking.
866: 	
867: 	DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_;
868: 	DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
869: 	Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
870: 	Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
871: 	Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
872: 	Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
873: 	Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_;
874: 	Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
875: 	Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
876: 	Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
877: 	Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
878: 	TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
879: 	TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
880: 	TransmissionRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
881: 	Opacity_node_83662364_52db_4f7b_b336_baca232fc310_;
882: 	SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_;
883: 	SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_;
884: 	EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;	
885: 	
886: 	// These control/input pairs are alpha blended together.
887: 	// If the Channel has an input connected the input is used.	
888: 	// Else the attribute slider is used instead.
889: 	// VAR Name   			 'mix' based on existence of an alpha in the channels	
890: 	vec3 difCol	   			= mix( vec3(0),		vec4(DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,		vec4(DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
891: 	vec3 specCol1  			= mix( vec3(0),		vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
892: 	vec3 specCol2  			= mix( vec3(0),		vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
893: 	vec3 reflCol1  			= mix( vec3(0),		vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
894: 	vec3 reflCol2  			= mix( vec3(0),		vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
895: 	vec3 refrCol  			= mix( vec3(0),		vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
896: 	vec3 transCol 			= mix( vec3(0),		vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
897: 	vec3 sssCol	   			= mix( vec3(0),		vec4(SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb, 			vec4(SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a				== 0 ? 0 : 1);
898: 	vec3 sssRadius 			= mix( vec3(0), 	vec4(SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb, 		vec4(SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 			== 0 ? 0 : 1);
899: 	vec3 emisCol   			= mix( vec3(0),		vec4(EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	 	vec4(EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a		== 0 ? 0 : 1);
900: 		
901: 	float difrough 	 		= mix( float(0),	vec4(DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
902: 	float spec1rough 		= mix( float(0),	vec4(Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
903: 	float ani1				= mix( float(0),	vec4(Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
904: 	float rot1 		 		= mix( float(0),	vec4(Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
905: 	float spec2rough 		= mix( float(0),	vec4(Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
906: 	float ani2				= mix( float(0),	vec4(Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
907: 	float rot2 		 		= mix( float(0),	vec4(Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
908: 	float refrarough		= mix( float(0),	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).r,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 	== 0 ? 0 : 1);
909: 	
910: 
911: 	vec3 Current_Channel_Selected = node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output.rgb;
912: 	
913: 	if(ConvertToGlossiness_node_83662364_52db_4f7b_b336_baca232fc310_ == true)
914: 	{
915: 		spec1rough = 1.0 - spec1rough;
916: 		spec2rough = 1.0 - spec2rough;
917: 	}
918: 	
919: 	// Check if there's Color painted at the rgb of the Opacity Channels	
920: 	vec3 opacityCol	 = vec3(0,0,0);
921: 	if (color_toValue(vec4(Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,0).rgb) == 0)
922: 	{
923: 		opacityCol = vec3(1.0) - Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb;
924: 	}
925: 	else
926: 	{
927: 		opacityCol = vec3(1.0) - vec4(Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,0).rgb;	
928: 	}	
929: 	
930: 	// The UV Viewport will display what is the Current Channel Selected, unless you don't have any channel. Then it will display the Mari`s alpha checkerboard pattern.	
931: 	if(u_MriViewType==2 || u_MriLightingMode==0)
932: 	{
933: 		// This is the cheapest way to use this "viewbuffer" feature, skipping most of the shader calculation.
934: 		
935: 		Output = node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output;		
936: 		
937: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 1)
938: 		{
939: 			Output.rgb = difCol.rgb;
940: 		}
941: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 2)
942: 		{
943: 			Output.rgb = specCol1.rgb;
944: 		}
945: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 3)
946: 		{
947: 			Output.rgb = reflCol1.rgb;
948: 		}
949: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 4)
950: 		{
951: 			Output.rgb = refrCol.rgb;
952: 		}
953: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 5)
954: 		{
955: 			Output.rgb = sssCol.rgb;
956: 		}
957: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 6)
958: 		{
959: 			Output.rgb = emisCol.rgb;
960: 		}
961: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7)
962: 		{
963: 			Output = vec4(0.5,0.5,0.5,0.0);
964: 		}
965: 		
966: 		//Display the Thickness imported image in the UV Viewport
967: 		if(u_MriViewType==2 && Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7) 
968: 		{
969: 			Output = vec4(0.5,0.5,0.5,0.0);			
970: 		}		
971: 	}
972: 	else
973: 	{
974: 		// ------------  All the shader math ------------
975: 		
976: 		const float PI = 3.14159265358979323846264;
977: 		const float TwoPI = 2.0 * PI;
978: 			
979: 		// View Direction
980: 		vec3 V = normalize(-State.ViewVectorInEyeSpaceFromViewCamera);
981: 		// Normal Direction
982: 		vec3 N = normalize(node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output.xyz);
983: 			
984: 		float NdotV = dot(N,V);
985: 		// On the wrong side of the face
986: 		if( NdotV <= 0.0)
987: 		{
988: 			N = -N;
989: 			NdotV = 1.0 - NdotV;
990: 		}
991: 				
992: 		//Enum Light direction
993: 		vec3 L = N;
994: 		// Half Vector
995: 		vec3 H = normalize(L+V);					
996: 		float cos_theta = dot(H,V);
997: 		vec3 RelectionTintColor1 = FresnelConductor(Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,Specular1EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,cos_theta);
998: 		//vec3 RelectionTintColor1 = Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb;
999: 		vec3 RelectionTintColor2 = FresnelConductor(Specular2Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,Specular2EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,cos_theta);
1000: 
1001: 				
1002: 		// Calculates the Space diagonal of the volume inside a cube
1003: 		vec3 viewPos = vec3(1.0);
1004: 		viewPos.x = mix(1, 2*abs(State.Position.x), abs(State.NormalInEyeSpaceFromViewCamera.x) );
1005: 		viewPos.y = mix(1, 2*abs(State.Position.y), abs(State.NormalInEyeSpaceFromViewCamera.y) );
1006: 		viewPos.z = mix(1, 2*abs(State.Position.z), abs(State.NormalInEyeSpaceFromViewCamera.z) );
1007: 		float base_diagonal = sqrt(viewPos.x*viewPos.x+viewPos.z*viewPos.z);
1008: 		float space_diagonal = sqrt(base_diagonal*base_diagonal + viewPos.y*viewPos.y);
1009: 			
1010: 		// Check if there is a texture assigned to the vec4(0.5,0.5,0.5,0.0) attribute, if does, then use it instead of the 1.5 value. 
1011: 		float Thickness = 1.5;	
1012: 		if(vec4(0.5,0.5,0.5,0.0).a > 0)	
1013: 		{
1014: 			Thickness = 1.0 + vec4(0.5,0.5,0.5,0.0).r;		
1015: 		}
1016: 		
1017: 		//Use the Baked texture to mix with the multiplication factors of the "Voxelized calculation method" based on depth of the scene
1018: 		if(u_MriViewType == 0) //gl buffer does not work well in perspective mode
1019: 		{
1020: 			//thickness based on position calculation mixed with obj radius
1021: 			vec3 P = State.Position*u_MriObjectRadius;
1022: 			float d = -dot(State.Position,P);
1023: 			float D = abs(d)/length(P);
1024: 			D /=u_MriObjectRadius;             
1025: 			
1026: 			Thickness *= mix( mix(2, 1, 1-NdotV)*u_MriObjectRadius, space_diagonal, (1-NdotV)*length(D));	
1027: 		}
1028: 		else
1029: 		{
1030: 			//thickness based on depth and obj radius
1031: 			float mult_factor = mix(2*u_MriObjectRadius, u_MriObjectRadius/2, gl_FragDepth);
1032: 			//thickness adjusment for the depth based on the Space diagonal of a cube created for each pixel on face.
1033: 			float mult_factor2 = mix( mix(space_diagonal, 1, (gl_FragDepth*(1-NdotV))), mix(u_MriObjectRadius, 1, (2*abs(gl_FragDepth - 0.5))*(1-NdotV)), 2*abs(gl_FragDepth - 0.5) )*PI; // this PI is just a adjusment to the color values between the two viewports
1034: 			
1035: 			Thickness *= mix(mult_factor, mult_factor2, gl_FragDepth);
1036: 		}	
1037: 		
1038: 				
1039: 		// Roughness attributes squared
1040: 		float difrough2 = difrough*difrough;		
1041: 		float spec1rough2 = spec1rough*spec1rough*spec1rough*spec1rough; // Arnold use a quadratic specrough for cook-torrance only(their wish was to use cubic, but that's expensive they say).	
1042: 		float spec2rough2 = spec2rough*spec2rough*spec2rough*spec2rough;
1043: 		float refrarough2 = refrarough*refrarough*refrarough*refrarough;
1044: 		
1045: 		float _glossiness = 1.0;
1046: 		float _Refra_glossiness = 1.0;
1047: 		float _ani1 = 2*(0.5-ani1); // internal variable to be used as anisotropy for the maths, this changes the anisotropy value to the range -1 and 1 that is used by V-ray and is correct for obtain the correct result from the BRDF Formula.
1048: 		float _ani2 = 2*(0.5-ani2);
1049: 		
1050: 		// IBL Glossiness adaptation to match the BRDF blur or 'spec lobe' for Environment Lighting
1051: 		_glossiness = mix(pow( 1-sqrt(spec1rough2), 2), pow( 1-(spec1rough), 3), 1-spec1rough);
1052: 		_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1053: 		
1054: 		if(_ani1 == 0.0 || spec1rough2 == 0.0) // There is no Anisotropy if the Specular Roughness = 0
1055: 		{
1056: 			_glossiness = pow( mix( 1-spec1rough2, 1-sqrt(spec1rough2), 1-spec1rough), mix(2, 3, 1-spec1rough) );
1057: 			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1058: 		}
1059: 		else
1060: 		{				  
1061: 			_glossiness = pow( mix( (abs(_ani1)/PI+1-sqrt(spec1rough2))/2, (abs(_ani1)+1-sqrt(spec1rough2))/2, 1-spec1rough), mix(1, (abs(_ani1)+1-sqrt(spec1rough2))*1.5, 1-spec1rough) );
1062: 			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1063: 		}
1064: 		
1065: 		// Fresnel var initialization	
1066: 		float F = 1.0;
1067: 		if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1068: 		{
1069: 			F = 0.0;
1070: 		}	
1071: 		
1072: 		// Anisotropic coords
1073: 		vec3 epsilon1 = vec3(0, 1, 0.15);
1074: 		vec3 X1 = vec3(1,0,0);
1075: 		vec3 Y1 = vec3(0,1,0);
1076: 		if(node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.a != 1.0)
1077: 		{
1078: 			X1.x = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.r;
1079: 			Y1.y = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.g;
1080: 		}
1081: 		if(ani1 != 0.5)
1082: 		{		
1083: 			epsilon1 = rot1 < 0.5 ? mix(Y1, X1, 2*rot1) : mix(X1, -Y1, 2*(rot1-0.5) );		
1084: 		}
1085: 				
1086: 		Y1 = normalize(cross(N, epsilon1));
1087: 		X1 = normalize(cross(N, Y1));
1088: 		
1089: 		vec3 epsilon2 = vec3(0, 1, 0.15);
1090: 		vec3 X2 = vec3(1,0,0);
1091: 		vec3 Y2 = vec3(0,1,0);
1092: 		if(node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.a != 1.0)
1093: 		{
1094: 			X2.x = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.r;
1095: 			Y2.y = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.g;
1096: 		}
1097: 		if(ani2 != 0.5)
1098: 		{		
1099: 			epsilon2 = rot2 < 0.5 ? mix(Y2, X2, 2*rot2) : mix(X2, -Y2, 2*(rot2-0.5) );		
1100: 		}
1101: 				
1102: 		Y2 = normalize(cross(N, epsilon2));
1103: 		X2 = normalize(cross(N, Y2));
1104: 
1105: 		// Energy variables initialization for each phase of the light calculation
1106: 		vec3 EnergyDiffuse = vec3(0.0);
1107: 		vec3 EnergyDiffuse_env = vec3(0.0); //avoid diffuse light bounces from lights to the obj
1108: 		vec3 EnergyBacklight = vec3(0.0);
1109: 		vec3 EnergyBacklight_env = vec3(0.0);
1110: 		vec3 EnergySpecular1 = vec3(0.0); //also separete the energy from highlights and reflection(point lights and environment light) also avoids lights bouncees from shader to the direct light sourcers the point lights.
1111: 		vec3 EnergySpecular_env1 = vec3(0.0);
1112: 		vec3 EnergyReflection_env1 = vec3(0.0);
1113: 		vec3 EnergySpecular2 = vec3(0.0); 
1114: 		vec3 EnergySpecular_env2 = vec3(0.0); 
1115: 		vec3 EnergyReflection_env2 = vec3(0.0);
1116: 		vec3 EnergyRefraction_env = vec3(0.0);
1117: 		vec3 EnergyTransmittance = vec3(1.0);
1118: 		vec3 EnergySSS = vec3(0.0);
1119: 		vec3 EnergySSS_env = vec3(0.0); //avoid SSS light bounces from lights to the obj
1120: 		vec3 EnergyOpacity_env = vec3(0.0);
1121: 		
1122: 		vec3 LightColour = vec3(0.0);
1123: 		float diffterm = 0.0;
1124: 		float specterm = 0.0;
1125: 		float specterm2 = 0.0;
1126: 		float refraterm = 0.0;
1127: 		vec3 _Absorbance = vec3 (1.0);
1128: 		
1129: 		
1130: 		
1131: 		for(int i=0;i<4;i++)
1132: 		{
1133: 			if( vec3( 0) == u_MriLightSources[i].DiffuseColor.rgb && vec3( 0) == u_MriLightSources[i].SpecularColor.rgb)
1134: 			{
1135: 				continue;
1136: 			}
1137: 
1138: 			float lightVisibility = mriLightVisibility( i, State.Position);		
1139: 			
1140: 			// Light Direction			
1141: 			vec3 L = normalize(u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera);
1142: 			vec3 LdistP = u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera;	
1143: 			
1144: 			// Half Vector
1145: 			vec3 H = normalize(L+V);		
1146: 			
1147: 			float LdotN = dot(L,N);		
1148: 			{			
1149: 				// ----------DIFFUSE TERM-----------
1150: 				// Oren-Nayar Diffuse Result from the Light Sources
1151: 				diffterm = 1.25*mriBRDF_Oren_Nayar(N, V, L, difrough2);
1152: 				EnergyDiffuse  += (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * (diffterm) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);
1153: 				
1154: 				// Check-box Calculate Fresnel to Diffuse
1155: 				//if($DiffuseFresnel == true)
1156: 				// Calculate fresnel attenuation for the Diffuse, using the specReflectance at normal or the $IOR attributes.		
1157: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1158: 				{
1159: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);
1160: 					// *FIX Light Occlusion/Shadow Issue*
1161: 					float F0 = (1 - TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)/(1 + TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1162: 					F0 = F0*F0;
1163: 					F = mix(F*(1-NdotV), F, F0);
1164: 					// Energy Conservation from Specular (Lights Sources)	
1165: 					EnergyDiffuse *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;						
1166: 				}
1167: 				
1168: 				// ----------Sub-Surface Scattering TERM-----------            
1169: 				float LdotN = dot(L,N);
1170: 				float LdotH = dot(L,H);
1171: 				
1172: 				float FL = mriBRDF_SchlickFresnel(LdotN);
1173: 				float FV = mriBRDF_SchlickFresnel(NdotV);			
1174: 							
1175: 				LightColour = (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);
1176: 					
1177: 				// creates a bit of a fake impression of difusion
1178: 				vec3 mixSSSdifusion = vec3(0.0);
1179: 				for (int j=0;j<3;j++)
1180: 				{			
1181: 					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), 1-sssRadius.rgb[j] );
1182: 				}
1183: 				vec3 Back_Scat_Color = 1.25*mixSSSdifusion*mixSSSdifusion;
1184: 				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
1185: 				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
1186: 				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;
1187: 				
1188: 				EnergySSS += Back_Scat_Color;
1189: 							
1190: 				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1191: 				//if($DiffuseFresnel == true)
1192: 				// The same fresnel attenuation that affects the diffuse above.
1193: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1194: 				{
1195: 					// Energy Conservation from Specular (Lights Sources)
1196: 					EnergySSS *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;														
1197: 				}
1198: 				
1199: 				// ----------BACKLIGHT TERM-----------
1200: 				if( LdotN <= 0.0)
1201: 				{
1202: 					if(BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_ > 0.0)
1203: 					{					
1204: 						diffterm = mriBRDF_Oren_Nayar(N, V, -L, difrough2);
1205: 						EnergyBacklight += ( u_MriLightSources[i].DiffuseColor.rgb) * diffterm * BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * BacklightColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb *att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_)/PI;
1206: 						
1207: 						// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1208: 						//if($DiffuseFresnel == true)
1209: 						if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1210: 						{
1211: 							F = mriBRDF_Fresnel(-L, -H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1212: 							// *FIX Light Occlusion/Shadow Issue*
1213: 							float F0 = (1 - TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)/(1 + TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1214: 							F0 = F0*F0;
1215: 							F = mix(F*(1-NdotV), F, F0);						
1216: 							// Energy Conservation from Specular (Lights Sources)
1217: 							// ----------BACKLIGHT TERM-----------
1218: 							EnergyBacklight *= 1.0 - min(PI * F * max(0.0, dot(-L,N)) * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_, 1.0);						
1219: 						}
1220: 					}
1221: 					else
1222: 					{
1223: 						continue;
1224: 					}	
1225: 				}			
1226: 				
1227: 				// ----------SPECULAR1 TERM-----------
1228: 				// Moved to here so would Avoid shadow issues in the Diffuse and SSS Calculation and will prevent future issues in the Specular Calculation.
1229: 				if( LdotN > 0.0)
1230: 				{				
1231: 					// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR
1232: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1233: 					{
1234: 						F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1235: 					}	
1236: 					else
1237: 					{
1238: 						F = 1.0;
1239: 					}					
1240: 					//BRDF Model Cook-Torrance
1241: 					// Cook-Torrance Specular Result
1242: 					specterm = mriBRDF_Beckman(N, H, max(spec1rough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(spec1rough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
1243: 					
1244: 					
1245: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1246: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1247: 					if(abs(_ani1) != 0.0) 
1248: 					{							
1249: 						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
1250: 						if(spec1rough2 == 0.0)
1251: 						{
1252: 							specterm = mriBRDF_Ward(N, V, L, H, X1, Y1, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
1253: 						}
1254: 						else
1255: 						{						
1256: 							// Isotropy specular assumes that ani = 0
1257: 							specterm = mriBRDF_Ward(N, V, L, H, X1, Y1, _ani1, 0.99-spec1rough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
1258: 						}					
1259: 					}						
1260: 					EnergySpecular1 += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);			
1261: 				}
1262: 				
1263: 				// ----------SPECULAR2 TERM-----------
1264: 				if( LdotN > 0.0)
1265: 				{				
1266: 					if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1267: 					{
1268: 						F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1269: 					}	
1270: 					else
1271: 					{
1272: 						F = 1.0;
1273: 					}					
1274: 										
1275: 					//BRDF Model Cook-Torrance
1276: 					// Cook-Torrance Specular Result
1277: 					specterm2 = mriBRDF_Beckman(N, H, max(spec2rough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(spec2rough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
1278: 					
1279: 					
1280: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1281: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1282: 					if(abs(_ani2) != 0.0) 
1283: 					{							
1284: 						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
1285: 						if(spec2rough2 == 0.0)
1286: 						{
1287: 							specterm2 = mriBRDF_Ward(N, V, L, H, X2, Y2, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
1288: 						}
1289: 						else
1290: 						{						
1291: 							// Isotropy specular assumes that ani = 0
1292: 							specterm2 = mriBRDF_Ward(N, V, L, H, X2, Y2, _ani2, 0.99-spec2rough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
1293: 						}					
1294: 					}						
1295: 					EnergySpecular2 += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm2) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);			
1296: 				}
1297: 
1298: 			}		
1299: 		}
1300: 		
1301: 		
1302: 		if( mriEnvironmentLightOn() == true)
1303: 		{
1304: 			{
1305: 				// ----------DIFFUSE TERM-----------
1306: 				// Env Light, Light Direction
1307: 				vec3 L = N;
1308: 				LightColour = mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 0.0);
1309: 				// This mix(PI, 2.5, difrough2) would preserve albedo.	
1310: 				EnergyDiffuse_env = mix(PI, 2.5, difrough2)*mriBRDF_Oren_Nayar(N, V, L, difrough2) * LightColour;            		
1311: 				
1312: 				// Check-box Calculate Fresnel to Diffuse 
1313: 				//if($DiffuseFresnel == true)
1314: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1315: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1316: 				{
1317: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1318: 					L = normalize( -reflect( V, N));
1319: 					// Half Vector
1320: 					vec3 H = normalize(L+V);					
1321: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1322: 					// Energy Conservation from Specular (Environment)					
1323: 					EnergyDiffuse_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1324: 					
1325: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1326: 					{
1327: 						F = 0.0; 
1328: 					}
1329: 					// Energy Conservation from Reflection (Environment)	
1330: 					EnergyDiffuse_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1331: 				}
1332: 			}
1333: 			
1334: 			{
1335: 				// ----------BACKLIGHT TERM-----------
1336: 				// Env Light, Light Direction
1337: 				// Backlight	
1338: 				vec3 L = normalize( -refract(V, -N*State.FragmentPositionInEyeSpaceFromViewCamera, 1.0) );				
1339: 				
1340: 				float lightVisibility = 1.0;			
1341: 				
1342: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);	
1343: 				
1344: 				EnergyBacklight_env += mix(vec3(0), LightColour, BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_)*mriBRDF_Oren_Nayar(N, V, N, difrough2);
1345: 				EnergyBacklight_env /= 1+difrough2/PI;
1346: 				
1347: 				//if($DiffuseFresnel == true)
1348: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1349: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1350: 				{
1351: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1352: 					L = normalize( -reflect( V, N));
1353: 					// Half Vector
1354: 					vec3 H = normalize(L+V);					
1355: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1356: 					// Energy Conservation from Specular (Environment)					
1357: 					EnergyBacklight_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1358: 						
1359: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1360: 					{
1361: 						F = 0.0; 
1362: 					}
1363: 					// Energy Conservation from Reflection (Environment)	
1364: 					EnergyBacklight_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1365: 				}
1366: 			}	
1367: 
1368: 			{
1369: 				// ----------SPECULAR TERM1-----------
1370: 				// Env Specular Reflection, Light Direction			
1371: 				vec3 L = normalize( -reflect( V, N));
1372: 				// Half Vector
1373: 				vec3 H = normalize(L+V);          			
1374: 				
1375: 				// How to calculate fresnel to specular equation, using specReflectance at normal or Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_
1376: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1377: 				{
1378: 					F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1379: 				}
1380: 				else
1381: 				{
1382: 					F = 1.0;
1383: 				}
1384: 				float LdotN = dot(L,N);
1385: 				if( 0.0 < LdotN)
1386: 				{
1387: 					float lightVisibility = 1.0;
1388: 					LightColour = vec3(0.0);				
1389: 
1390: 					//BRDF Model Cook-Torrance
1391: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
1392: 					// Cook-Torrance Specular Result from Environment
1393: 					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-spec1rough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
1394: 					
1395: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1396: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1397: 					if(abs(_ani1) != 0) 
1398: 					{									
1399: 						// Isotropy reflection
1400: 						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
1401: 							
1402: 						// Anisotropy reflection	
1403: 						if(_ani1 != 0.0 && spec1rough2 != 0)
1404: 						{
1405: 							// Caculate how much isotropy is the material based on roughness and anisotropy values.
1406: 							float _isotropy = abs(_ani1)*(1.1-spec1rough2);	
1407: 							
1408: 							LightColour = vec3(0.0);
1409: 							float i = 0;
1410: 							for (;i < _isotropy;)
1411: 							{
1412: 							
1413: 							// Define the direction of the anisotropy
1414: 							vec3 L1 = normalize( reflect( V, _ani1 < 0? X1:Y1 ));
1415: 								
1416: 							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
1417: 							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L1, L, 1-i), clamp(_glossiness + abs(_ani1*_ani1)*(1.0-spec1rough2)/9, .1, .9) );							
1418: 							i += 0.1;
1419: 							}
1420: 							LightColour /= i*10;												
1421: 						}		
1422: 						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-spec1rough), 0.0, 1.0 );					
1423: 					}
1424: 					EnergySpecular_env1 += specterm * (LightColour);		
1425: 				
1426: 			
1427: 					// ----------REFLECTION TERM-----------
1428: 					// Reset the fresnel value, and keep the L direction from the specular above.
1429: 					
1430: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1431: 					{
1432: 						F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1433: 					}
1434: 					else
1435: 					{
1436: 						F = 1.0;
1437: 					}
1438: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
1439: 					EnergyReflection_env1 += F * (LightColour);
1440: 				}	
1441: 			}		
1442: 
1443: 			{
1444: 				// ----------SPECULAR TERM2-----------
1445: 				// Env Specular Reflection, Light Direction			
1446: 				vec3 L = normalize( -reflect( V, N));
1447: 				// Half Vector
1448: 				vec3 H = normalize(L+V);          			
1449: 				
1450: 				// How to calculate fresnel to specular equation, using specReflectance at normal or Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_
1451: 				if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1452: 				{
1453: 					F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1454: 				}
1455: 				else
1456: 				{
1457: 					F = 1.0;
1458: 				}
1459: 				float LdotN = dot(L,N);
1460: 				if( 0.0 < LdotN)
1461: 				{
1462: 					float lightVisibility = 1.0;
1463: 					LightColour = vec3(0.0);				
1464: 
1465: 					//BRDF Model Cook-Torrance
1466: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
1467: 					// Cook-Torrance Specular Result from Environment
1468: 					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-spec2rough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
1469: 					
1470: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1471: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1472: 					if(abs(_ani2) != 0) 
1473: 					{									
1474: 						// Isotropy reflection
1475: 						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
1476: 							
1477: 						// Anisotropy reflection	
1478: 						if(_ani2 != 0.0 && spec2rough2 != 0)
1479: 						{
1480: 							// Caculate how much isotropy is the material based on roughness and anisotropy values.
1481: 							float _isotropy = abs(_ani2)*(1.1-spec2rough2);	
1482: 							
1483: 							LightColour = vec3(0.0);
1484: 							float i = 0;
1485: 							for (;i < _isotropy;)
1486: 							{
1487: 							
1488: 							// Define the direction of the anisotropy
1489: 							vec3 L2 = normalize( reflect( V, _ani2 < 0? X2:Y2 ));
1490: 								
1491: 							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
1492: 							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L2, L, 1-i), clamp(_glossiness + abs(_ani2*_ani2)*(1.0-spec2rough2)/9, .1, .9) );							
1493: 							i += 0.1;
1494: 							}
1495: 							LightColour /= i*10;												
1496: 						}		
1497: 						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-spec2rough), 0.0, 1.0 );					
1498: 					}
1499: 					EnergySpecular_env2 += specterm * (LightColour);		
1500: 				
1501: 			
1502: 					// ----------REFLECTION TERM-----------
1503: 					// Reset the fresnel value, and keep the L direction from the specular above.
1504: 					
1505: 					if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1506: 					{
1507: 						F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1508: 					}
1509: 					else
1510: 					{
1511: 						F = 1.0;
1512: 					}
1513: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
1514: 					EnergyReflection_env2 += F * (LightColour);
1515: 				}	
1516: 			}		
1517: 
1518: 			
1519: 			{
1520: 				// ----------REFRACTION TERM-----------
1521: 				// Env Refraction, Light Direction			
1522: 				// Refraction incoming direction
1523: 				vec3 Li = vec3(0.0);
1524: 				if(Solid_node_83662364_52db_4f7b_b336_baca232fc310_)
1525: 				{
1526: 					Li = normalize( -refract(V, -N, (1.0/TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)) );
1527: 				}
1528: 				else
1529: 				{
1530: 					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
1531: 					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, (1.0/TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)) );
1532: 				}
1533: 				
1534: 				float lightVisibility = 1.0;
1535: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, _Refra_glossiness);		
1536: 				
1537: 				EnergyRefraction_env += (LightColour);		
1538: 							
1539: 				_Absorbance = transCol.rgb;
1540: 				if (_Absorbance != vec3(1.0) )
1541: 				{			
1542: 					_Absorbance = pow_RGB(transCol.rgb, Thickness/10);
1543: 					EnergyTransmittance = _Absorbance;
1544: 				}
1545: 				
1546: 				// *TWEAK* This will preserve some energy from the reflection that is actually passing through the surface and not been reflected by the fresnel.
1547: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1548: 				{
1549: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1550: 					vec3 L = normalize( -reflect( V, N));
1551: 					float LdotN = dot(L,N);
1552: 					// Half Vector
1553: 					vec3 H = normalize(L+V);					
1554: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);					
1555: 					EnergyRefraction_env *=  1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;			
1556: 					
1557: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1558: 					{
1559: 						F = 0.0; 
1560: 					}
1561: 					EnergyRefraction_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;				
1562: 				}		
1563: 			}	
1564: 
1565: 			{
1566: 				// ----------Sub-Surface Scattering TERM-----------
1567: 				// Env Light, Light Direction
1568: 				// Sub-Surface Scattering	
1569: 				vec3 L = N;				
1570: 				// Half Vector
1571: 				vec3 H = normalize(L+V);			
1572: 				
1573: 				float LdotN = dot(L,N);
1574: 				float LdotH = dot(L,H);
1575: 				
1576: 				float FL = mriBRDF_SchlickFresnel(LdotN);
1577: 				float FV = mriBRDF_SchlickFresnel(NdotV);			
1578: 					
1579: 				float lightVisibility = 1.0;
1580: 				
1581: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);
1582: 				
1583: 				// creates a bit of a fake impression of difusion
1584: 				vec3 mixSSSdifusion = vec3(0.0);
1585: 				for (int j=0;j<3;j++)
1586: 				{			
1587: 					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), sssRadius.rgb[j] );
1588: 				}
1589: 				vec3 Back_Scat_Color = 1.25*mixSSSdifusion;
1590: 				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
1591: 				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
1592: 				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;						
1593: 				
1594: 				EnergySSS_env += Back_Scat_Color;
1595: 				
1596: 				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1597: 				//if($DiffuseFresnel == true)
1598: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1599: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1600: 				{
1601: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1602: 					L = normalize( -reflect( V, N));
1603: 					// Half Vector
1604: 					vec3 H = normalize(L+V);					
1605: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1606: 					EnergySSS_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1607: 					
1608: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1609: 					{
1610: 						F = 0.0; // picks from the math above, since this would be a value that comes from a global attribute for the entire fresnels math.
1611: 					}
1612: 					EnergySSS_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1613: 				}
1614: 			}
1615: 			
1616: 			{
1617: 				// ----------OPACITY TERM-----------
1618: 				// Env Opacity, Light Direction			
1619: 				// Opacity incoming direction
1620: 				// It should look like a Ghost with inverted colors!
1621: 				vec3 Li = vec3(0.0);
1622: 				if(Solid_node_83662364_52db_4f7b_b336_baca232fc310_)
1623: 				{
1624: 					Li = normalize( -refract(V, -N, 1.0) );
1625: 				}
1626: 				else
1627: 				{
1628: 					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
1629: 					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, 1.0) );
1630: 				}
1631: 				float lightVisibility = 1.0;
1632: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, 1.0);		
1633: 				EnergyOpacity_env += LightColour;				
1634: 			}
1635: 		}	
1636: 		
1637: 		// AO option
1638: 		float _AO = 1.0 - AmbientOcclusion_node_83662364_52db_4f7b_b336_baca232fc310_ * State.AmbientOcclusion;
1639: 		
1640: 		// Keep in mind that Arnold does not restrict the artists with a builtin Energy Conservation! So you have some artists freedom to break the rules as you wish.
1641: 		vec3 Kd = (EnergyDiffuse+EnergyBacklight + EnergyDiffuse_env+EnergyBacklight_env) * difCol.rgb * DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * _AO;
1642: 		vec3 Ks1 = (EnergySpecular1 + EnergySpecular_env1) * specCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor1* _AO;	
1643: 		vec3 Ks2 = (EnergySpecular2 + EnergySpecular_env2) * specCol2.rgb * Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor2* _AO;	
1644: 		//vec3 Kr1 = EnergyReflection_env1 * reflCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor1 * _AO;
1645: 		//vec3 Kr2 = EnergyReflection_env2 * reflCol2.rgb * Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor2 * _AO;
1646: 		vec3 Kt = EnergyRefraction_env * EnergyTransmittance * refrCol.rgb * TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * _AO;
1647: 		vec3 Ksss = (EnergySSS + EnergySSS_env) * SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_ * sssCol.rgb * _AO;	
1648: 		vec3 Opa = EnergyOpacity_env * opacityCol.rgb;
1649: 		
1650: 		// New Mari Lighting Mode workflow.
1651: 		// Lighting Mode => 0 - "Flat" - only display the Current Channel that is selected.
1652: 		// Lighting Mode =>	1 - Basic - Display Diffuse + Sub-surface Scattering
1653: 		// Lighting Mode => 2 - Full - Adds the specular/reflection + refraction + self-illumination on top of what the Basic mode displays
1654: 		Output.rgb = u_MriLightingMode==0 ? Current_Channel_Selected.rgb : Kd+Ksss;
1655: 		Output.rgb += u_MriLightingMode!=2 ? vec3(0.0) : Ks1+Ks2+Kt;
1656: 			
1657: 		// Emission
1658: 		Output.rgb += u_MriLightingMode==2 ? EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * emisCol.rgb : vec3(0.0);
1659: 
1660: 		// Opacity
1661: 		Output.rgb = u_MriLightingMode==2 ? mix(Opa.rgb, Output.rgb, 1.0-color_toValue(opacityCol.rgb)) : Output.rgb;
1662: 				
1663: 		// If displaying "flat" lighting mode 0 use the Current Channel alpha.
1664: 		Output.a = u_MriLightingMode==0 ? node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output.a : 1.0;		
1665: 		
1666: 		
1667: 		// Render Passes Mode, the beauty pass = 0 doesn't need an if statement, it has coded above and displayed by default
1668: 		// Lighting Mode == 1 ? #Channel * $Weight : #Channel * $ChannelWeight * Lighting Contribution
1669: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 1)
1670: 		{
1671: 			Output.rgb = (u_MriLightingMode==1 ? difCol.rgb * DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kd);
1672: 		}
1673: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 2)
1674: 		{
1675: 			Output.rgb = (u_MriLightingMode==1 ? specCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ : Ks1+Ks2);
1676: 		}
1677: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 3)
1678: 		{
1679: 			Output.rgb = (u_MriLightingMode==1 ? reflCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kr1+Kr2);
1680: 		}
1681: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 4)
1682: 		{
1683: 			Output.rgb = (u_MriLightingMode==1 ? refrCol.rgb * TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kt);
1684: 		}
1685: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 5)
1686: 		{
1687: 			Output.rgb = (u_MriLightingMode==1 ? sssCol.rgb * SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_ : Ksss);
1688: 		}
1689: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 6)
1690: 		{
1691: 			Output.rgb = emisCol.rgb * EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
1692: 		}
1693: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7)
1694: 		{
1695: 			Output.rgb = vec3(1.0/Thickness);			
1696: 		}	
1697: 	}
1698: 		
1699: 	            
1700:     node_83662364_52db_4f7b_b336_baca232fc310_Output = Output;
1701: }
1702: 
1703: //=====================
1704: //--- Style 2 Node 'Viewer' ---
1705: //=====================
1706: 
1707: 
1708: uniform bool projection_through_enabled;
1709: uniform float projectionDepthTexture_Offset;
1710: uniform sampler2D projectionDepthTexture;
1711: uniform bool ao_enabled;
1712: uniform float ao_value;
1713: uniform float ao_contrast;
1714: uniform float ao_invert;
1715: uniform int ao_curve;
1716: uniform float depth_start;
1717: uniform float depth_end;
1718: uniform float depth_falloff;
1719: uniform float depth_range;
1720: uniform sampler2D marqueeSelMask;
1721: uniform float marqueeSelMaskAmount;
1722: uniform mat3x2 marqueeSelMaskMatrix;
1723: float MarqueeSelMaskFunc( vec2 uv)
1724: {
1725:     return ( 1.0 - marqueeSelMaskAmount*(1.0-texture( marqueeSelMask, ( (marqueeSelMaskMatrix * vec3( uv, 1.0)) * vec2( 0.5, -0.5)) + vec2( 0.5, 0.5)).a));
1726: }
1727: uniform bool fn_enabled;
1728: uniform float fn_maskAmount;
1729: uniform float fn_size;
1730: uniform float fn_seed;
1731: uniform float fn_roughness;
1732: uniform float fn_contrast;
1733: uniform float fn_invert;
1734: uniform int fractal_curve;
1735: 
1736: 
1737: void apply_projection_masks(inout MriFragmentState State, inout MriSystemFragmentState _State)
1738: {
1739:     float projection_exposure_multipler = projection_through_enabled ? float(_State.ProjectionCoord.z <= 1.0) : float((_State.ProjectionCoord.z-projectionDepthTexture_Offset) <= texture(projectionDepthTexture,_State.ProjectionCoord.st).r);
1740: _State.NonPreviewableProjectionExposure *= projection_exposure_multipler;
1741: float Midpoint = (depth_end+depth_start)/2.0;float Distance = (abs(Midpoint+State.FragmentPositionInEyeSpaceFromProjectionCamera.z)-abs(Midpoint-depth_start))/(Midpoint-depth_start);_State.ProjectionExposure *= clamp(Distance/depth_falloff+1.0, 0.0, 1.0);_State.NonPreviewableProjectionExposure *= MarqueeSelMaskFunc( State.FragmentPositionInNdcSpaceFromProjectionCamera.st);
1742: 
1743: }
1744: 
1745: void evaluate_shader_network(inout MriFragmentState State, inout MriSystemFragmentState _State)
1746: {
1747:         {
1748:         node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(State,_State); // Evaluating Node 'Bottom Transparency'
1749:         node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(State,_State); // Evaluating Node 'Paint 3'
1750:         node_516e4503_ea09_4104_8e31_2e667c820272_func(State,_State); // Evaluating Node 'Merge_Bump_Head'
1751:         node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(State,_State); // Evaluating Node 'Paint 4'
1752:         node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(State,_State); // Evaluating Node 'Layer'
1753:         node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(State,_State); // Evaluating Node 'Bump_Head'
1754:         node_45b7815b_0361_452e_b5c5_f476cf68940f_func(State,_State); // Evaluating Node 'Current Channel'
1755:         node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(State,_State); // Evaluating Node 'alSurfaceX/Height As Normal'
1756:         node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(State,_State); // Evaluating Node 'alSurfaceX/Normal Modulation'
1757:         node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(State,_State); // Evaluating Node 'alSurfaceX/Tangent Space To Eye Space'
1758:         node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(State,_State); // Evaluating Node 'alSurfaceX/Color To Vector'
1759:         node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(State,_State); // Evaluating Node 'alSurfaceX/Tangent Space To Eye Space 2'
1760:         node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(State,_State); // Evaluating Node 'alSurfaceX/Set Unlit'
1761:         node_83662364_52db_4f7b_b336_baca232fc310_func(State,_State); // Evaluating Node 'alSurfaceX/'
1762:         {
1763: 
1764:     _State.Diffuse = node_83662364_52db_4f7b_b336_baca232fc310_Output;
1765:                 
1766:         }
1767:     }
1768: 
1769: }
1770: 
1771: 
0(1679) : error C1008: undefined variable "Kr1"
0(1679) : error C1008: undefined variable "Kr2"

---CompilerLog---
0(1679) : error C1008: undefined variable "Kr1"
0(1679) : error C1008: undefined variable "Kr2"


Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 356 ms uu 69 FAILED
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 43 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 42 ms 17 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 45 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [           mricanvaswidget.cpp:2850] : Current Render Chain - 1st level op 'Initialize Matrix Stacks' failed
 Failed Stack :
  Deferred Renderer
  Offscreen Render Op
  Enable Lighting
  Setup Camera
Debug : [           mricanvaswidget.cpp:1142] : Creating Render Error Texture
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Color
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Constant
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Basic/Base Color Catalogue
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Channel/Channel Height
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Channel/Channel Color
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Add
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Subtract
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Multiply
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Divide
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Abs
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Math/Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Position
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Surface Normal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Tangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Bitangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UV
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UDIM Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/UV Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Ambient Occlusion
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Geometry/Selection Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Displacement
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Displacement Simple
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Tessellation Clip To Screen
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Tessellation To Pixels
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Perturb Point
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Surface/Perturb Surface
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/Bottom Transparency
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/Merge
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Layer/MergeNoAlpha
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Brightness
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Brightness Lookup
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Balance
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Contrast
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Flow
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Invert
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Log To Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Linear To Log
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Luminosity
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Clamp
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Lookup
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color Switch
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Copy Channel
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Color To Mask
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Set Value
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Gamma
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/HSL
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/HSV
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Hue Shift
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Saturation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Levels
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Grade
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/sRGB2Linear
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Premultiply Alpha
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Scale
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Shuffle
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Height As Normal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Tangent To Screen
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Tangent To World
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/World To Tangent
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Filter/Falloff Curve
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Cook Torrance
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Beckman
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Phong
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Specular/Blinn
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Flat
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/BRDF
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Standard Lighting
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/AiStandard
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/VRayMtl
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/RedshiftArchitectural
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Standalone/Unreal
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Layered/Layered
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Diffuse/Lambertian
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Diffuse/Minnaert
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Tangent Space To Eye Space
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Normal Modulation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Lighting Result Modulation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/Utils/Color To Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Cube Map
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Sphere Map
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Cube Map Projector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Sphere Map Projector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Tri Planar Projection
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Environment/Environment Light
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Tiled
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/UV Grid
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Sphere
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Cube
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/Object Space Linear Gradient
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Pattern/UV Linear Gradient
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Perlin
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Cellular
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Noise/Squiggle
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Fractal/Cloud
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Fractal/Turbulence
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Plant/Wood
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Procedural/Misc/Oil
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Animation
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Output
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Viewer
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Cross Bar 2
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Channel Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Channel Bake
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Current Layer
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Shuffle Copy
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Custom
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Empty
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Set Unlit
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Set Vector
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/EmptyWithSkip
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Current Paint Target
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Shader Input
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Face Test
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Group
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Backdrop
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/StickyNote
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Misc/Dot
Debug : [   mrishadernetworkmanager.cpp:410 ] :     Lighting/IBL
Debug : [   mrishadernetworkmanager.cpp:410 ] :     _System/Shader
Debug : [                mripainter.cpp:194 ] : This method is deprecated
Debug : [                mriproject.cpp:1558] : [ -- ] About to autosave project ...
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 7a600f36-a798-4a3f-a1c6-3b6641a58e0e 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 3d9ac0e7-9489-4115-9e46-20a7b889e2c4 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 4b438c38-5e2c-4533-b316-e9318e0b3bfe 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 51da21ab-ed90-4b64-8084-46cd7ce6f743 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of f58743b0-ff3e-421d-82a7-98f796bf976a 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of ecffadb3-f059-48b6-9e2c-0da6c4553212 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 78b723f8-ca72-4857-9965-f69722df0652 4
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 344920b6-ba9b-4aef-b100-39d52b45daa3 4
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 7a600f36-a798-4a3f-a1c6-3b6641a58e0e 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 3d9ac0e7-9489-4115-9e46-20a7b889e2c4 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 4b438c38-5e2c-4533-b316-e9318e0b3bfe 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 51da21ab-ed90-4b64-8084-46cd7ce6f743 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of f58743b0-ff3e-421d-82a7-98f796bf976a 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of ecffadb3-f059-48b6-9e2c-0da6c4553212 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 78b723f8-ca72-4857-9965-f69722df0652 4
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 344920b6-ba9b-4aef-b100-39d52b45daa3 4
Debug : [                mriproject.cpp:1683] : Copying C:/Users/kai.xu/AppData/Local/Temp/autosave.tmp to D:/Mari/026011bb-437d-4dd3-ae5b-20bb7a1b2095/autosave.mri
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'BRDF', input count: 7
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 146 ms
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001F1FB060> from <bound method SnapshotUI._updateShotListAdded of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [               application.cpp:430 ] : [!!] Failed to disconnect <PySide.QtCore.SignalInstance object at 0x000000001F1FB078> from <bound method SnapshotUI._updateShotListRemoved of <Mari.system.snapshots.SnapshotUI object at 0x000000001E3B5388>>
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 112 ms
Debug : [     mrishaderinputmanager.cpp:234 ] : [ !! ] Failed to find shader input 0x42e3e720
Debug : [     mriserializableobject.cpp:1017] : Attribute 'ConvertToGlossiness' already exists!
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node '', input count: 21
Debug : [   mrishadernetworkmanager.cpp:1603] : [ Nodes ] To Convert Unversioned 22 Custom 0 Same 114 Different 1 New 0 Old 0 BottomTransparency 0
Debug : [   mrishadernetworkmanager.cpp:1751] : [ Nodes ] Convert 1 Change 0
Debug : [     mriserializableobject.cpp:1017] : Attribute 'ConvertToGlossiness' already exists!
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node '', input count: 21
Debug : [             mrisnbasenode.cpp:5261] : [ -- ] About to upgrade node 'alSurfaceX/'
Debug : [     mriserializableobject.cpp:1017] : Attribute 'ConvertToGlossiness' already exists!
Debug : [             mrisnbasenode.cpp:5031] : [ !! ] Node 'alSurfaceX/' Cannot create Attribute name 'Specular2/ConvertToGlossiness'
Debug : [             mrisnbasenode.cpp:5278] : [ !! ] Upgrade nodes failed : add attributes
Debug : [   mrishadernetworkmanager.cpp:1277] : Cannot upgrade nodes for UUID 'alSurfaceX'
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 57 ms 55 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 61 ms 56 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:711 ] : [ !! ] Shader 'Shader Network1' Compilation Failure. Not linking.
---SourceCode---
Shader Type: Fragment
1: #version 150
2: #define MRI_SHADER_FRAGMENT 1
3: #define MRI_NUM_PATCH_ATTRIBUTES 4096
4: #define MRI_SVT_GATHER_USE_QUINT 1
5: #define MRI_USE_CUBE_MAP_ARRAY 1
6: #define USE_DEFERRED_TEXTURE_2D_ARRAY 1
7: 
8: //! Description |  Shader Network evaluation fragment shader
9: //! Name |  Func_ShaderNetwork.frag
10: //! Author |  Jack Greasley, Kiyoyuki Nakagaki, Duncan Hopkins
11: //! Copyright |  Copyright (c) 2013 The Foundry 
12: 
13: #define MRI_LIGHT_ARRAY_SIZE 4
14: 
15: struct MriSystemFragmentState
16: {
17:     vec4 Diffuse;
18:     vec4 Unlit;
19:     vec4 VectorData;
20: 
21:     vec2 dUV;
22: 
23:     vec3 ProjectionCoord;
24:     vec2 TangentInProjectionSpace;
25:     vec2 BitangentInProjectionSpace;
26: 
27:     bool Hidden;
28:     bool Locked;
29:     bool Selected;
30: 
31:     float ProjectionExposure;
32:     float NonPreviewableProjectionExposure;
33: 
34:     bool PatchSelected;
35:     bool FaceSelected;
36:     bool ObjectSelected;
37: 
38:     float TriangleId;
39:     float TileId; 
40:     float MipLevel;
41: 
42:     bool GeoExists;
43: };
44: 
45: struct MriFragmentState
46: {
47:     float AmbientOcclusion;
48: 
49:     vec3 Position;
50:     vec2 UV;
51:     vec3 Normal;
52:     vec3 Tangent;
53:     vec3 Bitangent;
54: 
55:     vec3 NormalInEyeSpaceFromViewCamera;
56:     vec3 TangentInEyeSpaceFromViewCamera;
57:     vec3 BitangentInEyeSpaceFromViewCamera;
58:     vec3 ViewVectorInEyeSpaceFromViewCamera;
59:     vec3 FragmentPositionInEyeSpaceFromViewCamera;
60: 
61:     vec3 NormalInEyeSpaceFromProjectionCamera;
62:     vec3 TangentInEyeSpaceFromProjectionCamera;
63:     vec3 BitangentInEyeSpaceFromProjectionCamera;
64:     vec3 ViewVectorInEyeSpaceFromProjectionCamera;
65: 
66:     vec3 FragmentPositionInEyeSpaceFromProjectionCamera;
67:     vec3 FragmentPositionInNdcSpaceFromProjectionCamera;
68: 
69:     float PatchId;
70:     int   FaceId;
71:     int   FaceIndex;
72: };
73: 
74: struct Channel
75: {
76:     // r - int index; 
77:     // g - bool active;
78:     // b - bool invert;
79:     ivec3 ChannelValues;
80:     // a - reserved
81: };
82: 
83: #if defined( USE_DEPTH_PROJECTIONS)
84: struct MriLight
85: {
86:     int depthProjectorIndex;
87:     int depthProjectorCount;
88: };
89: 
90: struct MriDepthProjection
91: {
92:     mat4 transform;
93: };
94: #endif
95: 
96: 
97: //Gives the true texture coordinates for the base texture
98: vec2 svt_coords(vec2 coords);
99: 
100: //This function gives the raw color value from the texture in Base channel without any filters or projection applied 
101: vec4 svt_texture(Channel Base, vec2 coords);
102: vec4 svt_texture(Channel Base, in MriFragmentState State, in MriSystemFragmentState _State);
103: 
104: //Collect height values from bump map
105: vec4 get_heights(Channel Base, vec2 coords);
106: 
107: //This function gives the color value from the texture in Base channel with some filters and projection applied if applicable
108: vec4 texture_lookup(Channel Base, vec2 coords);
109: 
110: //texture look up function for version 2.0
111: vec4 texture_lookup2(Channel Base, in MriFragmentState State, in MriSystemFragmentState _State);
112: 
113: float tex_mip_level(vec2 coord);
114: 
115: //Default shadow casting function
116: float mriLightVisibility( in int LightIndex, vec3 FragmentPosition);
117: 
118: //Functions for evaluating values with a bit of UV offset.
119: float dFdu(float F);
120: float dFdv(float F);
121: vec2 dFdu(vec2 F);
122: vec2 dFdv(vec2 F);
123: mat2 dFd(vec2 F);
124: vec3 dFdu(vec3 F);
125: vec3 dFdv(vec3 F);
126: mat2x3 dFd(vec3 F);
127: 
128: float F(float f0, vec2 dUV);
129: vec2 F(vec2 f0, vec2 dUV);
130: vec3 F(vec3 f0, vec2 dUV);
131: 
132: void apply_projection_masks(inout MriFragmentState State, inout MriSystemFragmentState _State);
133: 
134: void evaluate_shader_network(inout MriFragmentState State, inout MriSystemFragmentState _State);
135: 
136: 
137: #define MRI_LIGHT_ARRAY_SIZE 4
138: 
139: // DO NOT CHANGE this structure with out adjusting the uniform upload C++ code.
140: struct MriLightSource
141: {
142:     vec4 Position;
143: 
144:     vec4 AmbientColor;
145:     vec4 DiffuseColor;
146:     vec4 SpecularColor;
147: 
148:     float SpotCutoff;
149:     float SpotExponent;
150: 
151:     float ConstantAttenuation;
152:     float LinearAttenuation;
153:     float QuadraticAttenuation;
154: };
155: 
156: // Returns the lighting value to use from the external environment map
157: //  shapness - how clear or blurred the light source is
158: //   0.0 - Totally blurred light sources. same as using dot( normal, light) calculation
159: //   1.0 - Totally sharp
160: vec3 mriEnvironmentLight( in vec3 normal, in float sharpness);
161: bool mriEnvironmentLightOn();
162: 
163: 
164: float mriBRDF_sqr(float x);
165: 
166: float mriBRDF_SchlickFresnel(float u);
167: float mriBRDF_GTR1(float NdotH, float a);
168: float mriBRDF_GTR2(float NdotH, float a);
169: float mriBRDF_GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay);
170: float mriBRDF_smithG_GGX(float Ndotv, float alphaG);
171: vec3 mriBRDF_mon2lin(vec3 x);
172: 
173: 
174: ////////////////////////////////////////////////////////////////////////////////
175: // Custom BRDF Function Library Extension Registration
176: // Copyright (c) 2014 Antonio Lisboa M. Neto. All Rights Reserved.
177: //////////////////////////////////////////////////////////////////////////////// 
178: // File: BRDF_FunctionLib_ext.glslc	
179: // Description: Function Library Extension for be used in the new Custom BRDF Shaders
180: ////////////////////////////////////////////////////////////////////////////////               	
181: // Author: Antonio Neto       	
182: // Web: www.netocg.blogspot.com			
183: // Email: netocg.fx@gmail.com
184: ////////////////////////////////////////////////////////////////////////////////			                                   	
185: // Date: Jan 25, 2014	         		
186: ////////////////////////////////////////////////////////////////////////////////
187: 
188: float att(vec3 L, int Light_Falloff, float Decay_Rate);
189: float color_toValue(vec3 Color);
190: vec3 pow_RGB(vec3 Color, float Value);
191: vec3 convert_Colorspace(vec3 color, int Colorspace_Profile);
192: float mriBRDF_Fresnel(vec3 L, vec3 H, float eta);
193: float mriBRDF_Fresnel_Schlicks(vec3 L, vec3 H, float Reflectance);
194: float mriBRDF_Fresnel_Dielectric(vec3 L, vec3 H, float ior);
195: float mriBRDF_Fresnel_Conductor(vec3 L, vec3 H, float eta, float k);
196: float nfresnel(float cos_theta_r, float eta);
197: float mriBRDF_Oren_Nayar(vec3 N, vec3 V, vec3 L, float difrough2);
198: float mriBRDF_Beckman(vec3 N, vec3 H, float specrough2);
199: float mriBRDF_Geo_att_Cook_Torrance(vec3 N, vec3 H, vec3 V, vec3 L);
200: float mriBRDF_Ward(vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specrough2);
201: float mriBRDF_Geo_att_Ward_Duer( vec3 L, vec3 V, vec3 N, vec3 H);
202: float mriBRDF_Ashikhmin_Shirley( vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specrough2);
203: float mriBRDF_Geo_Att_Ash_Sh00( vec3 N, vec3 V, vec3 L);
204: float mriBRDF_Blinn(vec3 N, vec3 H, float specrough2);
205: float mriBRDF_Geo_att_Schlick_Smith(vec3 N, vec3 L, vec3 V, float specrough2);
206: float mriBRDF_Phong(vec3 N, vec3 V, vec3 H, float specrough2);
207: float mriBRDF_Geo_att_Beckmann(vec3 N, vec3 V, float specrough2);
208: float mriBRDF_GTR(vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specGloss, float ggxTailFalloff);
209: float mriBRDF_Geo_att_smithG_GGX(float NdotV, float specGloss);
210: 
211: /****************************************************************************
212: * Camera information
213: *****************************************************************************/
214: // camera type of the current view
215: // 0 - Perspective
216: // 1 - Ortho
217: // 2 - UV
218: uniform int u_MriViewType;
219: 
220: // x:left, y:top, z:right, w:bottom
221: uniform vec4 u_MriViewport;
222: 
223: /****************************************************************************
224: * Matrices
225: *****************************************************************************/
226: uniform mat4 u_MriViewMatrix;
227: uniform mat4 u_MriModelViewMatrix;
228: uniform mat4 u_MriProjectionMatrix;
229: uniform mat4 u_MriNormalMatrix;
230: 
231: /****************************************************************************
232: * Object information
233: *****************************************************************************/
234: uniform int u_MriObjectId;
235: uniform vec3 u_MriObjectCenter;
236: uniform float u_MriObjectRadius;
237: 
238: /****************************************************************************
239: * Light information
240: *****************************************************************************/
241: //Lighting mode
242: // 0 - Flat
243: // 1 - Basic (Diffuse only)
244: // 2 - Full
245: uniform int u_MriLightingMode;
246: 
247: uniform MriLightSource u_MriLightSources[MRI_LIGHT_ARRAY_SIZE];
248: 
249: /****************************************************************************
250: * Misc
251: *****************************************************************************/
252: // The current animation frame
253: uniform int u_MriCurrentFrame;
254: 
255: // The system time in milliseconds. Will wrap every ~70 minutes.
256: uniform int u_MriSystemTime;
257: 
258: uniform vec2 u_MriMaxSupportedTextureSize;
259: 
260: 
261: 
262: float mriColorBlend(float pixel, float fPixel, float bPixel, float fAlpha, float bAlpha, int normal);
263: vec3 mriColorBlendv(vec3 modifiedColor, vec3 layerColor, vec3 baseColor, float layerAlpha, float baseAlpha, int normal);
264: float mriAlphaBlend( float fAlpha, float bAlpha);
265: float mriRgb2Lightness(vec4 RGBA);
266: vec4 mriRgb2Hsl(vec4 colorIn);
267: vec4 mriHsl2Rgb(vec4 colorIn);
268: vec4 mriRgb2Hsv(vec4 colorIn);
269: vec4 mriHsv2Rgb(vec4 colorIn);
270: 
271: vec4 Comp_Add(vec4 base,vec4 blend,float Opacity);
272: vec4 Comp_BurnHighlights(vec4 base,vec4 blend,float Opacity);
273: vec4 Comp_BurnMidrange(vec4 base,vec4 blend,float Opacity);
274: vec4 Comp_BurnShadows(vec4 base,vec4 blend,float Opacity);
275: vec4 Comp_Clear(vec4 base,vec4 blend,float Opacity);
276: vec4 Comp_Color(vec4 base,vec4 blend,float Opacity);
277: vec4 Comp_ColorBurn(vec4 base,vec4 blend,float Opacity);
278: vec4 Comp_ColorDodge(vec4 base,vec4 blend,float Opacity);
279: vec4 Comp_Copy(vec4 base,vec4 blend,float Opacity);
280: vec4 Comp_CopyRGB(vec4 base,vec4 blend,float Opacity);
281: vec4 Comp_Darken(vec4 base,vec4 blend,float Opacity);
282: vec4 Comp_Default(vec4 base,vec4 blend,float Opacity);
283: vec4 Comp_Difference(vec4 base,vec4 blend,float Opacity);
284: vec4 Comp_DodgeHighlights(vec4 base,vec4 blend,float Opacity);
285: vec4 Comp_DodgeMidrange(vec4 base,vec4 blend,float Opacity);
286: vec4 Comp_DodgeShadows(vec4 base,vec4 blend,float Opacity);
287: vec4 Comp_Exclusion(vec4 base,vec4 blend,float Opacity);
288: vec4 Comp_HardLight(vec4 base,vec4 blend,float Opacity);
289: vec4 Comp_HardMix(vec4 base,vec4 blend,float Opacity);
290: vec4 Comp_Hue(vec4 base,vec4 blend,float Opacity);
291: vec4 Comp_InverseDifference(vec4 base,vec4 blend,float Opacity);
292: vec4 Comp_Invert(vec4 base,vec4 blend,float Opacity);
293: vec4 Comp_Lighten(vec4 base,vec4 blend,float Opacity);
294: vec4 Comp_Luminance(vec4 base,vec4 blend,float Opacity);
295: vec4 Comp_Multiply(vec4 base,vec4 blend,float Opacity);
296: vec4 Comp_Overlay(vec4 base,vec4 blend,float Opacity);
297: vec4 Comp_PinLight(vec4 base,vec4 blend,float Opacity);
298: vec4 Comp_Saturation(vec4 base,vec4 blend,float Opacity);
299: vec4 Comp_Screen(vec4 base,vec4 blend,float Opacity);
300: vec4 Comp_SoftLight(vec4 base,vec4 blend,float Opacity);
301: vec4 Comp_SpongeDesaturate(vec4 base,vec4 blend,float Opacity);
302: vec4 Comp_VividLight(vec4 base,vec4 blend,float Opacity);
303: vec4 Comp_Contrast(vec4 base,vec4 blend,float Opacity);
304: vec4 Comp_Decontrast(vec4 base,vec4 blend,float Opacity);
305: vec4 Comp_MixRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
306: vec4 Comp_AddRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
307: vec4 Comp_ReorientedNormalMappingRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
308: 
309: // Blending functions the operate on the color channels only. Used by things such as color adjustments where the alpha channel needs to be ignored.
310: vec4 Comp_Default(vec4 Base, vec3 Blend, float Amount);
311: vec4 Comp_Add(vec4 Base, vec3 Blend, float Amount);
312: vec4 Comp_Color(vec4 Base, vec3 Blend, float Amount);
313: vec4 Comp_Copy(vec4 Base, vec3 Blend, float Amount);
314: vec4 Comp_CopyRGB(vec4 Base, vec3 Blend, float Amount);
315: vec4 Comp_Darken(vec4 Base, vec3 Blend, float Amount);
316: vec4 Comp_Difference(vec4 Base, vec3 Blend, float Amount);
317: vec4 Comp_Hue(vec4 Base, vec3 Blend, float Amount);
318: vec4 Comp_InverseDifference(vec4 Base, vec3 Blend, float Amount);
319: vec4 Comp_Lighten(vec4 Base, vec3 Blend, float Amount);
320: vec4 Comp_Luminance(vec4 Base, vec3 Blend, float Amount);
321: vec4 Comp_Multiply(vec4 Base, vec3 Blend, float Amount);
322: vec4 Comp_Saturation(vec4 Base, vec3 Blend, float Amount);
323: 
324: vec4 Comp_VecDefault2d(vec4 base,vec4 blend,float Opacity);
325: vec4 Comp_VecDefault3d(vec4 base,vec4 blend,float Opacity);
326: 
327: vec4 Comp_VecAdd3d(vec4 base,vec4 blend,float Opacity);
328: vec4 Comp_VecAdd2d(vec4 base,vec4 blend,float Opacity);
329: 
330: vec4 Comp_VecScale3d(vec4 base,vec4 blend,float Opacity);
331: 
332: //! macro | custom_blend_mode_declarations | // No custom blend modes
333: 
334: 
335: 
336: 
337: //Curve lookup functions
338: 
339: float mriCurveLookup( in int Line, in float InValue);
340: 
341: 
342: 
343: 
344: /****************************************************************************
345: * Noise functions
346: *****************************************************************************/
347: 
348: //These functions generate Perlin and Simplex noise from 2D,3D,4D inputs
349: float mriPerlinNoise(vec2 P);
350: float mriPerlinNoise(vec3 P);
351: float mriPerlinNoise(vec4 P);
352: float mriSimplexNoise(vec2 P);
353: float mriSimplexNoise(vec3 P);
354: float mriSimplexNoise(vec4 P);
355: 
356: // DEPRECATED in favor of more explicit function names above
357: float mriNoise(vec3 P); 
358: 
359: 
360: //Cellular (Worley) noise generation function based on 3D input and different types of norm(distance) calculation. This returns vec3 in which F1, F2 and F1-F2 are returned in r, g and b of the resulting vec3 respectively. Cellular noise is a noise obtained by calculating distance to randomly generated points. The definition of the distance is the norm. F1 is the distance to the closest point while F2 is the distance to the 2nd closest point.  
361: // norm - The norm(distance calculation) definition to use. 
362: //  0 : Manhattan norm
363: //  1 : Euclidian norm
364: //  2 : Chebyshev(Infinity) norm
365: //  3 : P-norm where P=0.5
366: vec3 mriCellular(vec3 P, int norm);
367: 
368: // DEPRECATED
369: // These functions are provided for backward compatibility since the older version of Mari had these.
370: // These are deprecated and to be removed in favor of more explicitly named functions above.
371: float noise(vec3 P);
372: vec3 cellular(vec3 P, int norm);
373: 
374: 
375: 
376: 
377: //Given the face index at the evaluation point (usually the fragment), this returns hiddenness, lockedness and selectedness of the face in r,g and b respectively.
378: //the a component is currently not used, but reserved for the future usage
379: vec4 mriFaceSystemAttribute(int FaceIndex);
380: 
381: //Given the primitiveID, returns the face index of the original mesh
382: int mriFaceIndex(int PrimitiveID);
383: 
384: 
385: 
386: /****************************************************************************
387: * Misc
388: *****************************************************************************/
389: //This is an untility function to do the implementation of how to interpret a given color value as a mask. Whoever needs to regard some color value as mask should call this function for consistent mechanism
390: float interpretAsExposure(in vec4 Color,int Mode);
391: 
392: 
393: 
394: 
395: // Function for handling standard Vector Painting Maths
396: 
397: vec3 vector_bias( vec3 vector);
398: vec3 vector_unbias( vec3 colour);
399: 
400: vec3 vector_paintToTangent3D( vec3 screen);
401: vec3 vector_paintToTangent2D( vec3 screen);
402: 
403: vec3 vector_worldToTangent( vec3 tangent);
404: vec3 vector_tangentToWorld( vec3 tangent);
405: vec3 vector_tangentToScreen( vec3 tangent);
406: 
407: 
408: 
409: //! macro | module_inputs | // No Module Inputs
410: //! macro | module_calls  | // No Module Calls
411: //! macro | module_declarations  | // No Module Declarations
412: 
413: //! macro | surface_mask_declarations | // No mask applied
414: //! macro | surface_mask_body         | // No mask applied
415: 
416: uniform int udim_size;
417: 
418: void store_state(inout MriFragmentState State, inout MriSystemFragmentState _State);
419: void derive_state(inout MriFragmentState State, inout MriSystemFragmentState _State, float du, float dv);
420: void restore_state(inout MriFragmentState State, inout MriSystemFragmentState _State);
421: 
422: #define REVAL(func,du,dv) store_state(State, _State);derive_state(State, _State, du, dv);func(State,_State);restore_state(State, _State);
423: 
424: 
425: 
426: float olefresnel(float r, float g, float c);
427: float get_n(float r,float g);
428: float get_k2(float r, float n);
429: float n_min(float r);
430: float n_max(float r);
431: vec3 FresnelConductor(vec3 Refelctivity, vec3 EdgeTint,float cos_theta);//=====================
432: // Forward Declaration of functions
433: //=====================
434: 
435: void node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
436: void node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
437: void node_516e4503_ea09_4104_8e31_2e667c820272_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
438: void node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
439: void node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
440: void node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
441: void node_45b7815b_0361_452e_b5c5_f476cf68940f_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
442: void node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
443: void node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
444: void node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
445: void node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
446: void node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
447: void node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
448: void node_83662364_52db_4f7b_b336_baca232fc310_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
449: 
450: //=====================
451: // Declaration of functions
452: //=====================
453: 
454: //=====================
455: //--- Style 2 Node 'Bottom Transparency' ---
456: //=====================
457: vec4 node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output; // Output 'Output' 
458: void node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
459: {
460:     vec4 Output; // Output 'Output' 
461: 
462:     Output = vec4( 0, 0, 0, 0);
463:         
464:     node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output = Output;
465: }
466: 
467: //=====================
468: //--- Style 2 Node 'Paint 3' ---
469: //=====================
470: uniform Channel Channel_node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_;
471: vec4 node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output; // Output 'Output' 
472: void node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
473: {
474:     vec4 Output; // Output 'Output' 
475: 
476:                   
477:         Output = texture_lookup2(Channel_node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_,State,_State);
478:                   
479:               
480:     node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output = Output;
481: }
482: 
483: //=====================
484: //--- Style 2 Node 'Merge_Bump_Head' ---
485: //=====================
486: uniform int AdvancedEnabled_node_516e4503_ea09_4104_8e31_2e667c820272_;
487: uniform float Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
488: uniform int AmountEnabled_node_516e4503_ea09_4104_8e31_2e667c820272_;
489: uniform int BlendIfBelow_node_516e4503_ea09_4104_8e31_2e667c820272_;
490: uniform int BlendIfThis_node_516e4503_ea09_4104_8e31_2e667c820272_;
491: uniform int BlendMode_node_516e4503_ea09_4104_8e31_2e667c820272_;
492: uniform int Component_node_516e4503_ea09_4104_8e31_2e667c820272_;
493: uniform int SwizzleA_node_516e4503_ea09_4104_8e31_2e667c820272_;
494: uniform int SwizzleB_node_516e4503_ea09_4104_8e31_2e667c820272_;
495: uniform int SwizzleG_node_516e4503_ea09_4104_8e31_2e667c820272_;
496: uniform int SwizzleR_node_516e4503_ea09_4104_8e31_2e667c820272_;
497: vec4 node_516e4503_ea09_4104_8e31_2e667c820272_Output; // Output 'Output' 
498: void node_516e4503_ea09_4104_8e31_2e667c820272_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
499: {
500:     vec4 Output; // Output 'Output' 
501: 
502:     if( 0 != 0)
503:     {
504:         // this is used to control what component we are pulling the key from
505:         vec3 Mult[5];
506: 
507:         Mult[0] = vec3(1.0/3.0,1.0/3.0,1.0/3.0);
508:         Mult[1] = vec3(1,0,0);
509:         Mult[2] = vec3(0,1,0);
510:         Mult[3] = vec3(0,0,1);
511:         Mult[4] = vec3(0.2126,0.7152,0.0722);
512: 
513: 
514:         // Calculate the amount from the component
515:         // a Mult value of (1,0,0) will isolate the red value
516:         // A mult value of (1,1,1) will give a gray scale
517: 
518:         float ThisAmount = dot(node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output.rgb , Mult[0]);
519:         float BelowAmount = dot(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output.rgb , Mult[0]);
520: 
521:         // now that we've pulled the component out of above and below
522:         // we lookup into the lut to find out the amount to scale the alpha values by
523: 
524:         float ThisAlpha  = mriCurveLookup(BlendIfThis_node_516e4503_ea09_4104_8e31_2e667c820272_,ThisAmount);
525:         float BelowAlpha = mriCurveLookup(BlendIfBelow_node_516e4503_ea09_4104_8e31_2e667c820272_,BelowAmount);
526: 
527:         // now we multiply the base alpha value by both values
528: 
529:         float AdvancedBlendAmount = ThisAlpha * BelowAlpha;
530:         if( 0 != 1)
531:         {
532:             AdvancedBlendAmount *= Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
533:         }
534: 
535:         Output = Comp_Default(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output, node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output, vec4(1,1,1,1).r * AdvancedBlendAmount);
536:     }
537:     else
538:     {
539:         float BlendAmount = 1;
540:         if( 0 != 1)
541:         {
542:             BlendAmount *= Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
543:         }
544:         Output = Comp_Default(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output, node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output, BlendAmount * vec4(1,1,1,1).r);
545:     }
546: 
547:     Output = vec4( Output.r, Output.g, Output.b, Output.a);
548: 
549:                 
550:     node_516e4503_ea09_4104_8e31_2e667c820272_Output = Output;
551: }
552: 
553: //=====================
554: //--- Style 2 Node 'Paint 4' ---
555: //=====================
556: uniform Channel Channel_node_5ab26bd0_71fd_473d_ba94_940da940e2a5_;
557: vec4 node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output; // Output 'Output' 
558: void node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
559: {
560:     vec4 Output; // Output 'Output' 
561: 
562:                   
563:         Output = texture_lookup2(Channel_node_5ab26bd0_71fd_473d_ba94_940da940e2a5_,State,_State);
564:                   
565:               
566:     node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output = Output;
567: }
568: 
569: //=====================
570: //--- Style 2 Node 'Layer' ---
571: //=====================
572: uniform int AdvancedEnabled_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
573: uniform float Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
574: uniform int AmountEnabled_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
575: uniform int BlendIfBelow_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
576: uniform int BlendIfThis_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
577: uniform int BlendMode_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
578: uniform int Component_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
579: uniform int SwizzleA_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
580: uniform int SwizzleB_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
581: uniform int SwizzleG_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
582: uniform int SwizzleR_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
583: vec4 node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output; // Output 'Output' 
584: void node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
585: {
586:     vec4 Output; // Output 'Output' 
587: 
588:     if( 0 != 0)
589:     {
590:         // this is used to control what component we are pulling the key from
591:         vec3 Mult[5];
592: 
593:         Mult[0] = vec3(1.0/3.0,1.0/3.0,1.0/3.0);
594:         Mult[1] = vec3(1,0,0);
595:         Mult[2] = vec3(0,1,0);
596:         Mult[3] = vec3(0,0,1);
597:         Mult[4] = vec3(0.2126,0.7152,0.0722);
598: 
599: 
600:         // Calculate the amount from the component
601:         // a Mult value of (1,0,0) will isolate the red value
602:         // A mult value of (1,1,1) will give a gray scale
603: 
604:         float ThisAmount = dot(node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output.rgb , Mult[0]);
605:         float BelowAmount = dot(node_516e4503_ea09_4104_8e31_2e667c820272_Output.rgb , Mult[0]);
606: 
607:         // now that we've pulled the component out of above and below
608:         // we lookup into the lut to find out the amount to scale the alpha values by
609: 
610:         float ThisAlpha  = mriCurveLookup(BlendIfThis_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_,ThisAmount);
611:         float BelowAlpha = mriCurveLookup(BlendIfBelow_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_,BelowAmount);
612: 
613:         // now we multiply the base alpha value by both values
614: 
615:         float AdvancedBlendAmount = ThisAlpha * BelowAlpha;
616:         if( 0 != 1)
617:         {
618:             AdvancedBlendAmount *= Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
619:         }
620: 
621:         Output = Comp_Default(node_516e4503_ea09_4104_8e31_2e667c820272_Output, node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output, vec4(1,1,1,1).r * AdvancedBlendAmount);
622:     }
623:     else
624:     {
625:         float BlendAmount = 1;
626:         if( 0 != 1)
627:         {
628:             BlendAmount *= Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
629:         }
630:         Output = Comp_Default(node_516e4503_ea09_4104_8e31_2e667c820272_Output, node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output, BlendAmount * vec4(1,1,1,1).r);
631:     }
632: 
633:     Output = vec4( Output.r, Output.g, Output.b, Output.a);
634: 
635:                 
636:     node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output = Output;
637: }
638: 
639: //=====================
640: //--- Style 2 Node 'Bump_Head' ---
641: //=====================
642: vec4 node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output; // Output 'Output' 
643: void node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
644: {
645:     vec4 Output; // Output 'Output' 
646: 
647:     Output = node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output;
648:                 
649:     node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output = Output;
650: }
651: 
652: //=====================
653: //--- Style 2 Node 'Current Channel' ---
654: //=====================
655: vec4 node_45b7815b_0361_452e_b5c5_f476cf68940f_Output; // Output 'Output' 
656: void node_45b7815b_0361_452e_b5c5_f476cf68940f_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
657: {
658:     vec4 Output; // Output 'Output' 
659: 
660:     Output = node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output;
661:                 
662:     node_45b7815b_0361_452e_b5c5_f476cf68940f_Output = Output;
663: }
664: 
665: //=====================
666: //--- Style 2 Node 'alSurfaceX/Height As Normal' ---
667: //=====================
668: uniform int BumpMode_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_;
669: uniform float BumpWeight_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_;
670: vec4 node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output; // Output 'Output' 
671: void node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
672: {
673:     vec4 Output; // Output 'Output' 
674: 
675:     // distance in texture space [0,1] between adjacent pixels at this mip level
676:     float Offset = exp2(_State.MipLevel)/u_MriMaxSupportedTextureSize.x;
677: 
678:     float BumpWeight = BumpWeight_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_/Offset;
679: 
680: 
681: #if 0
682:     // fudge factor
683:     BumpWeight *= 1.0/(30.0 * 16.0);
684: 
685:     // Bump mapping version A
686:     //Default Input Used : NO REVAL(Heightfunc,-Offset,0.0);
687:     float l=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
688: 
689:     //Default Input Used : NO REVAL(Heightfunc,Offset,0.0);
690:     float r=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
691: 
692:     //Default Input Used : NO REVAL(Heightfunc,0.0,-Offset);
693:     float b=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
694: 
695:     //Default Input Used : NO REVAL(Heightfunc,0.0,Offset);
696:     float t=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
697: 
698:     vec2 heightDelta = vec2( l - r, b - t);
699: #else
700:     // fudge factor
701:     BumpWeight *= 2.0/(30.0 * 16.0);
702: 
703:     // Bump mapping version A
704:     float c=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
705: 
706:     //Default Input Used : NO REVAL(Heightfunc,Offset,0.0);
707:     float r=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
708: 
709:     //Default Input Used : NO REVAL(Heightfunc,0.0,Offset);
710:     float t=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
711: 
712:     vec2 heightDelta = vec2( c - r, c - t);
713: #endif
714: 
715:     Output.rgb = normalize( vec3(heightDelta,1.0) ) * vec3(0.5,-0.5,0.5) + vec3(0.5); 
716:     Output.a = 1.0; 
717:                 
718:     node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output = Output;
719: }
720: 
721: //=====================
722: //--- Style 2 Node 'alSurfaceX/Normal Modulation' ---
723: //=====================
724: vec4 node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output; // Output 'Output' 
725: void node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
726: {
727:     vec4 Output; // Output 'Output' 
728: 
729:         vec3 norm = vec3(0.0, 0.0, 0.0);
730:         vec3 norm0 = vec4(0.5,0.5,1.0,1.0).rgb * 2.0 -1.0;
731:         vec3 norm1 = node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output.rgb * 2.0 - 1.0;
732: 
733:         norm += dot(norm0.xy,norm0.xy)>0.0 ? norm0  : vec3(0.0);
734:         norm += dot(norm1.xy,norm1.xy)>0.0 ? norm1  : vec3(0.0);
735: 
736:         //When there is no bump/normal, set it to default
737:         norm = dot(norm,norm)>0.0 ? norm  : vec3(0.0,0.0,1.0);
738: 
739:         Output.rgb = normalize(norm);
740:         Output.a = 1.0;
741:                 
742:     node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output = Output;
743: }
744: 
745: //=====================
746: //--- Style 2 Node 'alSurfaceX/Tangent Space To Eye Space' ---
747: //=====================
748: vec4 node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output; // Output 'Output' 
749: void node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
750: {
751:     vec4 Output; // Output 'Output' 
752: 
753:     mat3 tangentSpace2eyeSpace = mat3(
754:         State.TangentInEyeSpaceFromViewCamera,
755:         State.BitangentInEyeSpaceFromViewCamera,
756:         State.NormalInEyeSpaceFromViewCamera
757:     );
758:     Output.rgb = normalize( tangentSpace2eyeSpace * (node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output.rgb * vec3( 1,-1,1)));
759:     Output.a = node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output.a;
760:                 
761:     node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output = Output;
762: }
763: 
764: //=====================
765: //--- Style 2 Node 'alSurfaceX/Color To Vector' ---
766: //=====================
767: vec4 node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output; // Output 'Output' 
768: void node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
769: {
770:     vec4 Output; // Output 'Output' 
771: 
772:         vec3 norm = (vec4(1.0,0.5,0.5,1.0).rgb * 2.0) - 1.0;
773: 
774:         Output.rgb = norm;
775:         Output.a = 1.0;
776:                 
777:     node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output = Output;
778: }
779: 
780: //=====================
781: //--- Style 2 Node 'alSurfaceX/Tangent Space To Eye Space 2' ---
782: //=====================
783: vec4 node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output; // Output 'Output' 
784: void node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
785: {
786:     vec4 Output; // Output 'Output' 
787: 
788:     mat3 tangentSpace2eyeSpace = mat3(
789:         State.TangentInEyeSpaceFromViewCamera,
790:         State.BitangentInEyeSpaceFromViewCamera,
791:         State.NormalInEyeSpaceFromViewCamera
792:     );
793:     Output.rgb = normalize( tangentSpace2eyeSpace * (node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output.rgb * vec3( 1,-1,1)));
794:     Output.a = node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output.a;
795:                 
796:     node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output = Output;
797: }
798: 
799: //=====================
800: //--- Style 2 Node 'alSurfaceX/Set Unlit' ---
801: //=====================
802: vec4 node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output; // Output 'Output' 
803: void node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
804: {
805:     vec4 Output; // Output 'Output' 
806: 
807: 
808:     _State.Unlit = ((_State.Unlit.a==0.0) ? node_45b7815b_0361_452e_b5c5_f476cf68940f_Output : _State.Unlit);
809:     Output = node_45b7815b_0361_452e_b5c5_f476cf68940f_Output;
810:                 
811:     node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output = Output;
812: }
813: 
814: //=====================
815: //--- Style 2 Node 'alSurfaceX/' ---
816: //=====================
817: uniform float AmbientOcclusion_node_83662364_52db_4f7b_b336_baca232fc310_;
818: uniform vec4 BacklightColor_node_83662364_52db_4f7b_b336_baca232fc310_;
819: uniform float BacklightIndirectStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
820: uniform float BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
821: uniform bool ConvertToGlossiness_node_83662364_52db_4f7b_b336_baca232fc310_;
822: uniform float Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_;
823: uniform vec4 DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_;
824: uniform float DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
825: uniform float DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
826: uniform vec4 EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
827: uniform float EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
828: uniform int Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_;
829: uniform vec4 Opacity_node_83662364_52db_4f7b_b336_baca232fc310_;
830: uniform int Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_;
831: uniform vec4 SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_;
832: uniform vec4 SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_;
833: uniform float SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_;
834: uniform bool Solid_node_83662364_52db_4f7b_b336_baca232fc310_;
835: uniform float Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
836: uniform vec4 Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
837: uniform vec4 Specular1EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_;
838: uniform int Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_;
839: uniform float Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_;
840: uniform vec4 Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_;
841: uniform float Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
842: uniform float Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
843: uniform float Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;
844: uniform float Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
845: uniform vec4 Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_;
846: uniform vec4 Specular2EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_;
847: uniform int Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_;
848: uniform float Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_;
849: uniform vec4 Specular2Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_;
850: uniform float Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
851: uniform float Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
852: uniform float Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_;
853: uniform vec4 TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
854: uniform float TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_;
855: uniform bool TransmissionLinkToSpecular1_node_83662364_52db_4f7b_b336_baca232fc310_;
856: uniform float TransmissionRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
857: uniform float TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
858: uniform int shadingNode_node_83662364_52db_4f7b_b336_baca232fc310_;
859: vec4 node_83662364_52db_4f7b_b336_baca232fc310_Output; // Output 'Output' 
860: void node_83662364_52db_4f7b_b336_baca232fc310_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
861: {
862:     vec4 Output; // Output 'Output' 
863: 
864: 	shadingNode_node_83662364_52db_4f7b_b336_baca232fc310_; 
865: 	// Used for continually Mark what shader you are using in case you have renamed the name of the shader inside Mari. This var is also used for the exporter to identify what shader he is picking.
866: 	
867: 	DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_;
868: 	DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
869: 	Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
870: 	Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
871: 	Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
872: 	Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
873: 	Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_;
874: 	Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
875: 	Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
876: 	Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
877: 	Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
878: 	TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
879: 	TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
880: 	TransmissionRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
881: 	Opacity_node_83662364_52db_4f7b_b336_baca232fc310_;
882: 	SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_;
883: 	SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_;
884: 	EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;	
885: 	
886: 	// These control/input pairs are alpha blended together.
887: 	// If the Channel has an input connected the input is used.	
888: 	// Else the attribute slider is used instead.
889: 	// VAR Name   			 'mix' based on existence of an alpha in the channels	
890: 	vec3 difCol	   			= mix( vec3(0),		vec4(DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,		vec4(DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
891: 	vec3 specCol1  			= mix( vec3(0),		vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
892: 	vec3 specCol2  			= mix( vec3(0),		vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
893: 	vec3 reflCol1  			= mix( vec3(0),		vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
894: 	vec3 reflCol2  			= mix( vec3(0),		vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
895: 	vec3 refrCol  			= mix( vec3(0),		vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
896: 	vec3 transCol 			= mix( vec3(0),		vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
897: 	vec3 sssCol	   			= mix( vec3(0),		vec4(SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb, 			vec4(SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a				== 0 ? 0 : 1);
898: 	vec3 sssRadius 			= mix( vec3(0), 	vec4(SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb, 		vec4(SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 			== 0 ? 0 : 1);
899: 	vec3 emisCol   			= mix( vec3(0),		vec4(EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	 	vec4(EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a		== 0 ? 0 : 1);
900: 		
901: 	float difrough 	 		= mix( float(0),	vec4(DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
902: 	float spec1rough 		= mix( float(0),	vec4(Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
903: 	float ani1				= mix( float(0),	vec4(Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
904: 	float rot1 		 		= mix( float(0),	vec4(Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
905: 	float spec2rough 		= mix( float(0),	vec4(Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
906: 	float ani2				= mix( float(0),	vec4(Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
907: 	float rot2 		 		= mix( float(0),	vec4(Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
908: 	float refrarough		= mix( float(0),	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).r,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 	== 0 ? 0 : 1);
909: 	
910: 
911: 	vec3 Current_Channel_Selected = node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output.rgb;
912: 	
913: 	if(ConvertToGlossiness_node_83662364_52db_4f7b_b336_baca232fc310_ == true)
914: 	{
915: 		spec1rough = 1.0 - spec1rough;
916: 		spec2rough = 1.0 - spec2rough;
917: 	}
918: 	
919: 	// Check if there's Color painted at the rgb of the Opacity Channels	
920: 	vec3 opacityCol	 = vec3(0,0,0);
921: 	if (color_toValue(vec4(Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,0).rgb) == 0)
922: 	{
923: 		opacityCol = vec3(1.0) - Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb;
924: 	}
925: 	else
926: 	{
927: 		opacityCol = vec3(1.0) - vec4(Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,0).rgb;	
928: 	}	
929: 	
930: 	// The UV Viewport will display what is the Current Channel Selected, unless you don't have any channel. Then it will display the Mari`s alpha checkerboard pattern.	
931: 	if(u_MriViewType==2 || u_MriLightingMode==0)
932: 	{
933: 		// This is the cheapest way to use this "viewbuffer" feature, skipping most of the shader calculation.
934: 		
935: 		Output = node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output;		
936: 		
937: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 1)
938: 		{
939: 			Output.rgb = difCol.rgb;
940: 		}
941: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 2)
942: 		{
943: 			Output.rgb = specCol1.rgb;
944: 		}
945: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 3)
946: 		{
947: 			Output.rgb = reflCol1.rgb;
948: 		}
949: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 4)
950: 		{
951: 			Output.rgb = refrCol.rgb;
952: 		}
953: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 5)
954: 		{
955: 			Output.rgb = sssCol.rgb;
956: 		}
957: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 6)
958: 		{
959: 			Output.rgb = emisCol.rgb;
960: 		}
961: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7)
962: 		{
963: 			Output = vec4(0.5,0.5,0.5,0.0);
964: 		}
965: 		
966: 		//Display the Thickness imported image in the UV Viewport
967: 		if(u_MriViewType==2 && Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7) 
968: 		{
969: 			Output = vec4(0.5,0.5,0.5,0.0);			
970: 		}		
971: 	}
972: 	else
973: 	{
974: 		// ------------  All the shader math ------------
975: 		
976: 		const float PI = 3.14159265358979323846264;
977: 		const float TwoPI = 2.0 * PI;
978: 			
979: 		// View Direction
980: 		vec3 V = normalize(-State.ViewVectorInEyeSpaceFromViewCamera);
981: 		// Normal Direction
982: 		vec3 N = normalize(node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output.xyz);
983: 			
984: 		float NdotV = dot(N,V);
985: 		// On the wrong side of the face
986: 		if( NdotV <= 0.0)
987: 		{
988: 			N = -N;
989: 			NdotV = 1.0 - NdotV;
990: 		}
991: 				
992: 		//Enum Light direction
993: 		vec3 L = N;
994: 		// Half Vector
995: 		vec3 H = normalize(L+V);					
996: 		float cos_theta = dot(H,V);
997: 		vec3 RelectionTintColor1 = FresnelConductor(Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,Specular1EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,cos_theta);
998: 		//vec3 RelectionTintColor1 = Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb;
999: 		vec3 RelectionTintColor2 = FresnelConductor(Specular2Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,Specular2EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,cos_theta);
1000: 
1001: 				
1002: 		// Calculates the Space diagonal of the volume inside a cube
1003: 		vec3 viewPos = vec3(1.0);
1004: 		viewPos.x = mix(1, 2*abs(State.Position.x), abs(State.NormalInEyeSpaceFromViewCamera.x) );
1005: 		viewPos.y = mix(1, 2*abs(State.Position.y), abs(State.NormalInEyeSpaceFromViewCamera.y) );
1006: 		viewPos.z = mix(1, 2*abs(State.Position.z), abs(State.NormalInEyeSpaceFromViewCamera.z) );
1007: 		float base_diagonal = sqrt(viewPos.x*viewPos.x+viewPos.z*viewPos.z);
1008: 		float space_diagonal = sqrt(base_diagonal*base_diagonal + viewPos.y*viewPos.y);
1009: 			
1010: 		// Check if there is a texture assigned to the vec4(0.5,0.5,0.5,0.0) attribute, if does, then use it instead of the 1.5 value. 
1011: 		float Thickness = 1.5;	
1012: 		if(vec4(0.5,0.5,0.5,0.0).a > 0)	
1013: 		{
1014: 			Thickness = 1.0 + vec4(0.5,0.5,0.5,0.0).r;		
1015: 		}
1016: 		
1017: 		//Use the Baked texture to mix with the multiplication factors of the "Voxelized calculation method" based on depth of the scene
1018: 		if(u_MriViewType == 0) //gl buffer does not work well in perspective mode
1019: 		{
1020: 			//thickness based on position calculation mixed with obj radius
1021: 			vec3 P = State.Position*u_MriObjectRadius;
1022: 			float d = -dot(State.Position,P);
1023: 			float D = abs(d)/length(P);
1024: 			D /=u_MriObjectRadius;             
1025: 			
1026: 			Thickness *= mix( mix(2, 1, 1-NdotV)*u_MriObjectRadius, space_diagonal, (1-NdotV)*length(D));	
1027: 		}
1028: 		else
1029: 		{
1030: 			//thickness based on depth and obj radius
1031: 			float mult_factor = mix(2*u_MriObjectRadius, u_MriObjectRadius/2, gl_FragDepth);
1032: 			//thickness adjusment for the depth based on the Space diagonal of a cube created for each pixel on face.
1033: 			float mult_factor2 = mix( mix(space_diagonal, 1, (gl_FragDepth*(1-NdotV))), mix(u_MriObjectRadius, 1, (2*abs(gl_FragDepth - 0.5))*(1-NdotV)), 2*abs(gl_FragDepth - 0.5) )*PI; // this PI is just a adjusment to the color values between the two viewports
1034: 			
1035: 			Thickness *= mix(mult_factor, mult_factor2, gl_FragDepth);
1036: 		}	
1037: 		
1038: 				
1039: 		// Roughness attributes squared
1040: 		float difrough2 = difrough*difrough;		
1041: 		float spec1rough2 = spec1rough*spec1rough*spec1rough*spec1rough; // Arnold use a quadratic specrough for cook-torrance only(their wish was to use cubic, but that's expensive they say).	
1042: 		float spec2rough2 = spec2rough*spec2rough*spec2rough*spec2rough;
1043: 		float refrarough2 = refrarough*refrarough*refrarough*refrarough;
1044: 		
1045: 		float _glossiness = 1.0;
1046: 		float _Refra_glossiness = 1.0;
1047: 		float _ani1 = 2*(0.5-ani1); // internal variable to be used as anisotropy for the maths, this changes the anisotropy value to the range -1 and 1 that is used by V-ray and is correct for obtain the correct result from the BRDF Formula.
1048: 		float _ani2 = 2*(0.5-ani2);
1049: 		
1050: 		// IBL Glossiness adaptation to match the BRDF blur or 'spec lobe' for Environment Lighting
1051: 		_glossiness = mix(pow( 1-sqrt(spec1rough2), 2), pow( 1-(spec1rough), 3), 1-spec1rough);
1052: 		_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1053: 		
1054: 		if(_ani1 == 0.0 || spec1rough2 == 0.0) // There is no Anisotropy if the Specular Roughness = 0
1055: 		{
1056: 			_glossiness = pow( mix( 1-spec1rough2, 1-sqrt(spec1rough2), 1-spec1rough), mix(2, 3, 1-spec1rough) );
1057: 			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1058: 		}
1059: 		else
1060: 		{				  
1061: 			_glossiness = pow( mix( (abs(_ani1)/PI+1-sqrt(spec1rough2))/2, (abs(_ani1)+1-sqrt(spec1rough2))/2, 1-spec1rough), mix(1, (abs(_ani1)+1-sqrt(spec1rough2))*1.5, 1-spec1rough) );
1062: 			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1063: 		}
1064: 		
1065: 		// Fresnel var initialization	
1066: 		float F = 1.0;
1067: 		if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1068: 		{
1069: 			F = 0.0;
1070: 		}	
1071: 		
1072: 		// Anisotropic coords
1073: 		vec3 epsilon1 = vec3(0, 1, 0.15);
1074: 		vec3 X1 = vec3(1,0,0);
1075: 		vec3 Y1 = vec3(0,1,0);
1076: 		if(node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.a != 1.0)
1077: 		{
1078: 			X1.x = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.r;
1079: 			Y1.y = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.g;
1080: 		}
1081: 		if(ani1 != 0.5)
1082: 		{		
1083: 			epsilon1 = rot1 < 0.5 ? mix(Y1, X1, 2*rot1) : mix(X1, -Y1, 2*(rot1-0.5) );		
1084: 		}
1085: 				
1086: 		Y1 = normalize(cross(N, epsilon1));
1087: 		X1 = normalize(cross(N, Y1));
1088: 		
1089: 		vec3 epsilon2 = vec3(0, 1, 0.15);
1090: 		vec3 X2 = vec3(1,0,0);
1091: 		vec3 Y2 = vec3(0,1,0);
1092: 		if(node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.a != 1.0)
1093: 		{
1094: 			X2.x = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.r;
1095: 			Y2.y = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.g;
1096: 		}
1097: 		if(ani2 != 0.5)
1098: 		{		
1099: 			epsilon2 = rot2 < 0.5 ? mix(Y2, X2, 2*rot2) : mix(X2, -Y2, 2*(rot2-0.5) );		
1100: 		}
1101: 				
1102: 		Y2 = normalize(cross(N, epsilon2));
1103: 		X2 = normalize(cross(N, Y2));
1104: 
1105: 		// Energy variables initialization for each phase of the light calculation
1106: 		vec3 EnergyDiffuse = vec3(0.0);
1107: 		vec3 EnergyDiffuse_env = vec3(0.0); //avoid diffuse light bounces from lights to the obj
1108: 		vec3 EnergyBacklight = vec3(0.0);
1109: 		vec3 EnergyBacklight_env = vec3(0.0);
1110: 		vec3 EnergySpecular1 = vec3(0.0); //also separete the energy from highlights and reflection(point lights and environment light) also avoids lights bouncees from shader to the direct light sourcers the point lights.
1111: 		vec3 EnergySpecular_env1 = vec3(0.0);
1112: 		vec3 EnergyReflection_env1 = vec3(0.0);
1113: 		vec3 EnergySpecular2 = vec3(0.0); 
1114: 		vec3 EnergySpecular_env2 = vec3(0.0); 
1115: 		vec3 EnergyReflection_env2 = vec3(0.0);
1116: 		vec3 EnergyRefraction_env = vec3(0.0);
1117: 		vec3 EnergyTransmittance = vec3(1.0);
1118: 		vec3 EnergySSS = vec3(0.0);
1119: 		vec3 EnergySSS_env = vec3(0.0); //avoid SSS light bounces from lights to the obj
1120: 		vec3 EnergyOpacity_env = vec3(0.0);
1121: 		
1122: 		vec3 LightColour = vec3(0.0);
1123: 		float diffterm = 0.0;
1124: 		float specterm = 0.0;
1125: 		float specterm2 = 0.0;
1126: 		float refraterm = 0.0;
1127: 		vec3 _Absorbance = vec3 (1.0);
1128: 		
1129: 		
1130: 		
1131: 		for(int i=0;i<4;i++)
1132: 		{
1133: 			if( vec3( 0) == u_MriLightSources[i].DiffuseColor.rgb && vec3( 0) == u_MriLightSources[i].SpecularColor.rgb)
1134: 			{
1135: 				continue;
1136: 			}
1137: 
1138: 			float lightVisibility = mriLightVisibility( i, State.Position);		
1139: 			
1140: 			// Light Direction			
1141: 			vec3 L = normalize(u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera);
1142: 			vec3 LdistP = u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera;	
1143: 			
1144: 			// Half Vector
1145: 			vec3 H = normalize(L+V);		
1146: 			
1147: 			float LdotN = dot(L,N);		
1148: 			{			
1149: 				// ----------DIFFUSE TERM-----------
1150: 				// Oren-Nayar Diffuse Result from the Light Sources
1151: 				diffterm = 1.25*mriBRDF_Oren_Nayar(N, V, L, difrough2);
1152: 				EnergyDiffuse  += (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * (diffterm) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);
1153: 				
1154: 				// Check-box Calculate Fresnel to Diffuse
1155: 				//if($DiffuseFresnel == true)
1156: 				// Calculate fresnel attenuation for the Diffuse, using the specReflectance at normal or the $IOR attributes.		
1157: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1158: 				{
1159: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);
1160: 					// *FIX Light Occlusion/Shadow Issue*
1161: 					float F0 = (1 - TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)/(1 + TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1162: 					F0 = F0*F0;
1163: 					F = mix(F*(1-NdotV), F, F0);
1164: 					// Energy Conservation from Specular (Lights Sources)	
1165: 					EnergyDiffuse *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;						
1166: 				}
1167: 				
1168: 				// ----------Sub-Surface Scattering TERM-----------            
1169: 				float LdotN = dot(L,N);
1170: 				float LdotH = dot(L,H);
1171: 				
1172: 				float FL = mriBRDF_SchlickFresnel(LdotN);
1173: 				float FV = mriBRDF_SchlickFresnel(NdotV);			
1174: 							
1175: 				LightColour = (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);
1176: 					
1177: 				// creates a bit of a fake impression of difusion
1178: 				vec3 mixSSSdifusion = vec3(0.0);
1179: 				for (int j=0;j<3;j++)
1180: 				{			
1181: 					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), 1-sssRadius.rgb[j] );
1182: 				}
1183: 				vec3 Back_Scat_Color = 1.25*mixSSSdifusion*mixSSSdifusion;
1184: 				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
1185: 				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
1186: 				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;
1187: 				
1188: 				EnergySSS += Back_Scat_Color;
1189: 							
1190: 				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1191: 				//if($DiffuseFresnel == true)
1192: 				// The same fresnel attenuation that affects the diffuse above.
1193: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1194: 				{
1195: 					// Energy Conservation from Specular (Lights Sources)
1196: 					EnergySSS *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;														
1197: 				}
1198: 				
1199: 				// ----------BACKLIGHT TERM-----------
1200: 				if( LdotN <= 0.0)
1201: 				{
1202: 					if(BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_ > 0.0)
1203: 					{					
1204: 						diffterm = mriBRDF_Oren_Nayar(N, V, -L, difrough2);
1205: 						EnergyBacklight += ( u_MriLightSources[i].DiffuseColor.rgb) * diffterm * BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * BacklightColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb *att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_)/PI;
1206: 						
1207: 						// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1208: 						//if($DiffuseFresnel == true)
1209: 						if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1210: 						{
1211: 							F = mriBRDF_Fresnel(-L, -H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1212: 							// *FIX Light Occlusion/Shadow Issue*
1213: 							float F0 = (1 - TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)/(1 + TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1214: 							F0 = F0*F0;
1215: 							F = mix(F*(1-NdotV), F, F0);						
1216: 							// Energy Conservation from Specular (Lights Sources)
1217: 							// ----------BACKLIGHT TERM-----------
1218: 							EnergyBacklight *= 1.0 - min(PI * F * max(0.0, dot(-L,N)) * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_, 1.0);						
1219: 						}
1220: 					}
1221: 					else
1222: 					{
1223: 						continue;
1224: 					}	
1225: 				}			
1226: 				
1227: 				// ----------SPECULAR1 TERM-----------
1228: 				// Moved to here so would Avoid shadow issues in the Diffuse and SSS Calculation and will prevent future issues in the Specular Calculation.
1229: 				if( LdotN > 0.0)
1230: 				{				
1231: 					// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR
1232: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1233: 					{
1234: 						F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1235: 					}	
1236: 					else
1237: 					{
1238: 						F = 1.0;
1239: 					}					
1240: 					//BRDF Model Cook-Torrance
1241: 					// Cook-Torrance Specular Result
1242: 					specterm = mriBRDF_Beckman(N, H, max(spec1rough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(spec1rough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
1243: 					
1244: 					
1245: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1246: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1247: 					if(abs(_ani1) != 0.0) 
1248: 					{							
1249: 						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
1250: 						if(spec1rough2 == 0.0)
1251: 						{
1252: 							specterm = mriBRDF_Ward(N, V, L, H, X1, Y1, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
1253: 						}
1254: 						else
1255: 						{						
1256: 							// Isotropy specular assumes that ani = 0
1257: 							specterm = mriBRDF_Ward(N, V, L, H, X1, Y1, _ani1, 0.99-spec1rough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
1258: 						}					
1259: 					}						
1260: 					EnergySpecular1 += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);			
1261: 				}
1262: 				
1263: 				// ----------SPECULAR2 TERM-----------
1264: 				if( LdotN > 0.0)
1265: 				{				
1266: 					if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1267: 					{
1268: 						F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1269: 					}	
1270: 					else
1271: 					{
1272: 						F = 1.0;
1273: 					}					
1274: 										
1275: 					//BRDF Model Cook-Torrance
1276: 					// Cook-Torrance Specular Result
1277: 					specterm2 = mriBRDF_Beckman(N, H, max(spec2rough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(spec2rough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
1278: 					
1279: 					
1280: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1281: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1282: 					if(abs(_ani2) != 0.0) 
1283: 					{							
1284: 						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
1285: 						if(spec2rough2 == 0.0)
1286: 						{
1287: 							specterm2 = mriBRDF_Ward(N, V, L, H, X2, Y2, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
1288: 						}
1289: 						else
1290: 						{						
1291: 							// Isotropy specular assumes that ani = 0
1292: 							specterm2 = mriBRDF_Ward(N, V, L, H, X2, Y2, _ani2, 0.99-spec2rough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
1293: 						}					
1294: 					}						
1295: 					EnergySpecular2 += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm2) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);			
1296: 				}
1297: 
1298: 			}		
1299: 		}
1300: 		
1301: 		
1302: 		if( mriEnvironmentLightOn() == true)
1303: 		{
1304: 			{
1305: 				// ----------DIFFUSE TERM-----------
1306: 				// Env Light, Light Direction
1307: 				vec3 L = N;
1308: 				LightColour = mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 0.0);
1309: 				// This mix(PI, 2.5, difrough2) would preserve albedo.	
1310: 				EnergyDiffuse_env = mix(PI, 2.5, difrough2)*mriBRDF_Oren_Nayar(N, V, L, difrough2) * LightColour;            		
1311: 				
1312: 				// Check-box Calculate Fresnel to Diffuse 
1313: 				//if($DiffuseFresnel == true)
1314: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1315: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1316: 				{
1317: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1318: 					L = normalize( -reflect( V, N));
1319: 					// Half Vector
1320: 					vec3 H = normalize(L+V);					
1321: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1322: 					// Energy Conservation from Specular (Environment)					
1323: 					EnergyDiffuse_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1324: 					
1325: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1326: 					{
1327: 						F = 0.0; 
1328: 					}
1329: 					// Energy Conservation from Reflection (Environment)	
1330: 					EnergyDiffuse_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1331: 				}
1332: 			}
1333: 			
1334: 			{
1335: 				// ----------BACKLIGHT TERM-----------
1336: 				// Env Light, Light Direction
1337: 				// Backlight	
1338: 				vec3 L = normalize( -refract(V, -N*State.FragmentPositionInEyeSpaceFromViewCamera, 1.0) );				
1339: 				
1340: 				float lightVisibility = 1.0;			
1341: 				
1342: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);	
1343: 				
1344: 				EnergyBacklight_env += mix(vec3(0), LightColour, BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_)*mriBRDF_Oren_Nayar(N, V, N, difrough2);
1345: 				EnergyBacklight_env /= 1+difrough2/PI;
1346: 				
1347: 				//if($DiffuseFresnel == true)
1348: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1349: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1350: 				{
1351: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1352: 					L = normalize( -reflect( V, N));
1353: 					// Half Vector
1354: 					vec3 H = normalize(L+V);					
1355: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1356: 					// Energy Conservation from Specular (Environment)					
1357: 					EnergyBacklight_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1358: 						
1359: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1360: 					{
1361: 						F = 0.0; 
1362: 					}
1363: 					// Energy Conservation from Reflection (Environment)	
1364: 					EnergyBacklight_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1365: 				}
1366: 			}	
1367: 
1368: 			{
1369: 				// ----------SPECULAR TERM1-----------
1370: 				// Env Specular Reflection, Light Direction			
1371: 				vec3 L = normalize( -reflect( V, N));
1372: 				// Half Vector
1373: 				vec3 H = normalize(L+V);          			
1374: 				
1375: 				// How to calculate fresnel to specular equation, using specReflectance at normal or Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_
1376: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1377: 				{
1378: 					F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1379: 				}
1380: 				else
1381: 				{
1382: 					F = 1.0;
1383: 				}
1384: 				float LdotN = dot(L,N);
1385: 				if( 0.0 < LdotN)
1386: 				{
1387: 					float lightVisibility = 1.0;
1388: 					LightColour = vec3(0.0);				
1389: 
1390: 					//BRDF Model Cook-Torrance
1391: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
1392: 					// Cook-Torrance Specular Result from Environment
1393: 					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-spec1rough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
1394: 					
1395: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1396: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1397: 					if(abs(_ani1) != 0) 
1398: 					{									
1399: 						// Isotropy reflection
1400: 						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
1401: 							
1402: 						// Anisotropy reflection	
1403: 						if(_ani1 != 0.0 && spec1rough2 != 0)
1404: 						{
1405: 							// Caculate how much isotropy is the material based on roughness and anisotropy values.
1406: 							float _isotropy = abs(_ani1)*(1.1-spec1rough2);	
1407: 							
1408: 							LightColour = vec3(0.0);
1409: 							float i = 0;
1410: 							for (;i < _isotropy;)
1411: 							{
1412: 							
1413: 							// Define the direction of the anisotropy
1414: 							vec3 L1 = normalize( reflect( V, _ani1 < 0? X1:Y1 ));
1415: 								
1416: 							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
1417: 							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L1, L, 1-i), clamp(_glossiness + abs(_ani1*_ani1)*(1.0-spec1rough2)/9, .1, .9) );							
1418: 							i += 0.1;
1419: 							}
1420: 							LightColour /= i*10;												
1421: 						}		
1422: 						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-spec1rough), 0.0, 1.0 );					
1423: 					}
1424: 					EnergySpecular_env1 += specterm * (LightColour);		
1425: 				
1426: 			
1427: 					// ----------REFLECTION TERM-----------
1428: 					// Reset the fresnel value, and keep the L direction from the specular above.
1429: 					
1430: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1431: 					{
1432: 						F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1433: 					}
1434: 					else
1435: 					{
1436: 						F = 1.0;
1437: 					}
1438: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
1439: 					EnergyReflection_env1 += F * (LightColour);
1440: 				}	
1441: 			}		
1442: 
1443: 			{
1444: 				// ----------SPECULAR TERM2-----------
1445: 				// Env Specular Reflection, Light Direction			
1446: 				vec3 L = normalize( -reflect( V, N));
1447: 				// Half Vector
1448: 				vec3 H = normalize(L+V);          			
1449: 				
1450: 				// How to calculate fresnel to specular equation, using specReflectance at normal or Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_
1451: 				if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1452: 				{
1453: 					F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1454: 				}
1455: 				else
1456: 				{
1457: 					F = 1.0;
1458: 				}
1459: 				float LdotN = dot(L,N);
1460: 				if( 0.0 < LdotN)
1461: 				{
1462: 					float lightVisibility = 1.0;
1463: 					LightColour = vec3(0.0);				
1464: 
1465: 					//BRDF Model Cook-Torrance
1466: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
1467: 					// Cook-Torrance Specular Result from Environment
1468: 					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-spec2rough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
1469: 					
1470: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1471: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1472: 					if(abs(_ani2) != 0) 
1473: 					{									
1474: 						// Isotropy reflection
1475: 						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
1476: 							
1477: 						// Anisotropy reflection	
1478: 						if(_ani2 != 0.0 && spec2rough2 != 0)
1479: 						{
1480: 							// Caculate how much isotropy is the material based on roughness and anisotropy values.
1481: 							float _isotropy = abs(_ani2)*(1.1-spec2rough2);	
1482: 							
1483: 							LightColour = vec3(0.0);
1484: 							float i = 0;
1485: 							for (;i < _isotropy;)
1486: 							{
1487: 							
1488: 							// Define the direction of the anisotropy
1489: 							vec3 L2 = normalize( reflect( V, _ani2 < 0? X2:Y2 ));
1490: 								
1491: 							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
1492: 							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L2, L, 1-i), clamp(_glossiness + abs(_ani2*_ani2)*(1.0-spec2rough2)/9, .1, .9) );							
1493: 							i += 0.1;
1494: 							}
1495: 							LightColour /= i*10;												
1496: 						}		
1497: 						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-spec2rough), 0.0, 1.0 );					
1498: 					}
1499: 					EnergySpecular_env2 += specterm * (LightColour);		
1500: 				
1501: 			
1502: 					// ----------REFLECTION TERM-----------
1503: 					// Reset the fresnel value, and keep the L direction from the specular above.
1504: 					
1505: 					if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1506: 					{
1507: 						F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1508: 					}
1509: 					else
1510: 					{
1511: 						F = 1.0;
1512: 					}
1513: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
1514: 					EnergyReflection_env2 += F * (LightColour);
1515: 				}	
1516: 			}		
1517: 
1518: 			
1519: 			{
1520: 				// ----------REFRACTION TERM-----------
1521: 				// Env Refraction, Light Direction			
1522: 				// Refraction incoming direction
1523: 				vec3 Li = vec3(0.0);
1524: 				if(Solid_node_83662364_52db_4f7b_b336_baca232fc310_)
1525: 				{
1526: 					Li = normalize( -refract(V, -N, (1.0/TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)) );
1527: 				}
1528: 				else
1529: 				{
1530: 					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
1531: 					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, (1.0/TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)) );
1532: 				}
1533: 				
1534: 				float lightVisibility = 1.0;
1535: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, _Refra_glossiness);		
1536: 				
1537: 				EnergyRefraction_env += (LightColour);		
1538: 							
1539: 				_Absorbance = transCol.rgb;
1540: 				if (_Absorbance != vec3(1.0) )
1541: 				{			
1542: 					_Absorbance = pow_RGB(transCol.rgb, Thickness/10);
1543: 					EnergyTransmittance = _Absorbance;
1544: 				}
1545: 				
1546: 				// *TWEAK* This will preserve some energy from the reflection that is actually passing through the surface and not been reflected by the fresnel.
1547: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1548: 				{
1549: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1550: 					vec3 L = normalize( -reflect( V, N));
1551: 					float LdotN = dot(L,N);
1552: 					// Half Vector
1553: 					vec3 H = normalize(L+V);					
1554: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);					
1555: 					EnergyRefraction_env *=  1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;			
1556: 					
1557: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1558: 					{
1559: 						F = 0.0; 
1560: 					}
1561: 					EnergyRefraction_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;				
1562: 				}		
1563: 			}	
1564: 
1565: 			{
1566: 				// ----------Sub-Surface Scattering TERM-----------
1567: 				// Env Light, Light Direction
1568: 				// Sub-Surface Scattering	
1569: 				vec3 L = N;				
1570: 				// Half Vector
1571: 				vec3 H = normalize(L+V);			
1572: 				
1573: 				float LdotN = dot(L,N);
1574: 				float LdotH = dot(L,H);
1575: 				
1576: 				float FL = mriBRDF_SchlickFresnel(LdotN);
1577: 				float FV = mriBRDF_SchlickFresnel(NdotV);			
1578: 					
1579: 				float lightVisibility = 1.0;
1580: 				
1581: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);
1582: 				
1583: 				// creates a bit of a fake impression of difusion
1584: 				vec3 mixSSSdifusion = vec3(0.0);
1585: 				for (int j=0;j<3;j++)
1586: 				{			
1587: 					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), sssRadius.rgb[j] );
1588: 				}
1589: 				vec3 Back_Scat_Color = 1.25*mixSSSdifusion;
1590: 				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
1591: 				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
1592: 				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;						
1593: 				
1594: 				EnergySSS_env += Back_Scat_Color;
1595: 				
1596: 				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1597: 				//if($DiffuseFresnel == true)
1598: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1599: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1600: 				{
1601: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1602: 					L = normalize( -reflect( V, N));
1603: 					// Half Vector
1604: 					vec3 H = normalize(L+V);					
1605: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1606: 					EnergySSS_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1607: 					
1608: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1609: 					{
1610: 						F = 0.0; // picks from the math above, since this would be a value that comes from a global attribute for the entire fresnels math.
1611: 					}
1612: 					EnergySSS_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1613: 				}
1614: 			}
1615: 			
1616: 			{
1617: 				// ----------OPACITY TERM-----------
1618: 				// Env Opacity, Light Direction			
1619: 				// Opacity incoming direction
1620: 				// It should look like a Ghost with inverted colors!
1621: 				vec3 Li = vec3(0.0);
1622: 				if(Solid_node_83662364_52db_4f7b_b336_baca232fc310_)
1623: 				{
1624: 					Li = normalize( -refract(V, -N, 1.0) );
1625: 				}
1626: 				else
1627: 				{
1628: 					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
1629: 					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, 1.0) );
1630: 				}
1631: 				float lightVisibility = 1.0;
1632: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, 1.0);		
1633: 				EnergyOpacity_env += LightColour;				
1634: 			}
1635: 		}	
1636: 		
1637: 		// AO option
1638: 		float _AO = 1.0 - AmbientOcclusion_node_83662364_52db_4f7b_b336_baca232fc310_ * State.AmbientOcclusion;
1639: 		
1640: 		// Keep in mind that Arnold does not restrict the artists with a builtin Energy Conservation! So you have some artists freedom to break the rules as you wish.
1641: 		vec3 Kd = (EnergyDiffuse+EnergyBacklight + EnergyDiffuse_env+EnergyBacklight_env) * difCol.rgb * DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * _AO;
1642: 		vec3 Ks1 = (EnergySpecular1 + EnergySpecular_env1) * specCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor1* _AO;	
1643: 		vec3 Ks2 = (EnergySpecular2 + EnergySpecular_env2) * specCol2.rgb * Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor2* _AO;	
1644: 		//vec3 Kr1 = EnergyReflection_env1 * reflCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor1 * _AO;
1645: 		//vec3 Kr2 = EnergyReflection_env2 * reflCol2.rgb * Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor2 * _AO;
1646: 		vec3 Kt = EnergyRefraction_env * EnergyTransmittance * refrCol.rgb * TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * _AO;
1647: 		vec3 Ksss = (EnergySSS + EnergySSS_env) * SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_ * sssCol.rgb * _AO;	
1648: 		vec3 Opa = EnergyOpacity_env * opacityCol.rgb;
1649: 		
1650: 		// New Mari Lighting Mode workflow.
1651: 		// Lighting Mode => 0 - "Flat" - only display the Current Channel that is selected.
1652: 		// Lighting Mode =>	1 - Basic - Display Diffuse + Sub-surface Scattering
1653: 		// Lighting Mode => 2 - Full - Adds the specular/reflection + refraction + self-illumination on top of what the Basic mode displays
1654: 		Output.rgb = u_MriLightingMode==0 ? Current_Channel_Selected.rgb : Kd+Ksss;
1655: 		Output.rgb += u_MriLightingMode!=2 ? vec3(0.0) : Ks1+Ks2+Kt;
1656: 			
1657: 		// Emission
1658: 		Output.rgb += u_MriLightingMode==2 ? EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * emisCol.rgb : vec3(0.0);
1659: 
1660: 		// Opacity
1661: 		Output.rgb = u_MriLightingMode==2 ? mix(Opa.rgb, Output.rgb, 1.0-color_toValue(opacityCol.rgb)) : Output.rgb;
1662: 				
1663: 		// If displaying "flat" lighting mode 0 use the Current Channel alpha.
1664: 		Output.a = u_MriLightingMode==0 ? node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output.a : 1.0;		
1665: 		
1666: 		
1667: 		// Render Passes Mode, the beauty pass = 0 doesn't need an if statement, it has coded above and displayed by default
1668: 		// Lighting Mode == 1 ? #Channel * $Weight : #Channel * $ChannelWeight * Lighting Contribution
1669: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 1)
1670: 		{
1671: 			Output.rgb = (u_MriLightingMode==1 ? difCol.rgb * DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kd);
1672: 		}
1673: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 2)
1674: 		{
1675: 			Output.rgb = (u_MriLightingMode==1 ? specCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ : Ks1+Ks2);
1676: 		}
1677: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 3)
1678: 		{
1679: 			Output.rgb = (u_MriLightingMode==1 ? reflCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kr1+Kr2);
1680: 		}
1681: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 4)
1682: 		{
1683: 			Output.rgb = (u_MriLightingMode==1 ? refrCol.rgb * TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kt);
1684: 		}
1685: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 5)
1686: 		{
1687: 			Output.rgb = (u_MriLightingMode==1 ? sssCol.rgb * SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_ : Ksss);
1688: 		}
1689: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 6)
1690: 		{
1691: 			Output.rgb = emisCol.rgb * EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
1692: 		}
1693: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7)
1694: 		{
1695: 			Output.rgb = vec3(1.0/Thickness);			
1696: 		}	
1697: 	}
1698: 		
1699: 	            
1700:     node_83662364_52db_4f7b_b336_baca232fc310_Output = Output;
1701: }
1702: 
1703: //=====================
1704: //--- Style 2 Node 'Viewer' ---
1705: //=====================
1706: 
1707: 
1708: uniform bool projection_through_enabled;
1709: uniform float projectionDepthTexture_Offset;
1710: uniform sampler2D projectionDepthTexture;
1711: uniform bool ao_enabled;
1712: uniform float ao_value;
1713: uniform float ao_contrast;
1714: uniform float ao_invert;
1715: uniform int ao_curve;
1716: uniform float depth_start;
1717: uniform float depth_end;
1718: uniform float depth_falloff;
1719: uniform float depth_range;
1720: uniform sampler2D marqueeSelMask;
1721: uniform float marqueeSelMaskAmount;
1722: uniform mat3x2 marqueeSelMaskMatrix;
1723: float MarqueeSelMaskFunc( vec2 uv)
1724: {
1725:     return ( 1.0 - marqueeSelMaskAmount*(1.0-texture( marqueeSelMask, ( (marqueeSelMaskMatrix * vec3( uv, 1.0)) * vec2( 0.5, -0.5)) + vec2( 0.5, 0.5)).a));
1726: }
1727: uniform bool fn_enabled;
1728: uniform float fn_maskAmount;
1729: uniform float fn_size;
1730: uniform float fn_seed;
1731: uniform float fn_roughness;
1732: uniform float fn_contrast;
1733: uniform float fn_invert;
1734: uniform int fractal_curve;
1735: 
1736: 
1737: void apply_projection_masks(inout MriFragmentState State, inout MriSystemFragmentState _State)
1738: {
1739:     float projection_exposure_multipler = projection_through_enabled ? float(_State.ProjectionCoord.z <= 1.0) : float((_State.ProjectionCoord.z-projectionDepthTexture_Offset) <= texture(projectionDepthTexture,_State.ProjectionCoord.st).r);
1740: _State.NonPreviewableProjectionExposure *= projection_exposure_multipler;
1741: float Midpoint = (depth_end+depth_start)/2.0;float Distance = (abs(Midpoint+State.FragmentPositionInEyeSpaceFromProjectionCamera.z)-abs(Midpoint-depth_start))/(Midpoint-depth_start);_State.ProjectionExposure *= clamp(Distance/depth_falloff+1.0, 0.0, 1.0);_State.NonPreviewableProjectionExposure *= MarqueeSelMaskFunc( State.FragmentPositionInNdcSpaceFromProjectionCamera.st);
1742: 
1743: }
1744: 
1745: void evaluate_shader_network(inout MriFragmentState State, inout MriSystemFragmentState _State)
1746: {
1747:         {
1748:         node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(State,_State); // Evaluating Node 'Bottom Transparency'
1749:         node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(State,_State); // Evaluating Node 'Paint 3'
1750:         node_516e4503_ea09_4104_8e31_2e667c820272_func(State,_State); // Evaluating Node 'Merge_Bump_Head'
1751:         node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(State,_State); // Evaluating Node 'Paint 4'
1752:         node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(State,_State); // Evaluating Node 'Layer'
1753:         node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(State,_State); // Evaluating Node 'Bump_Head'
1754:         node_45b7815b_0361_452e_b5c5_f476cf68940f_func(State,_State); // Evaluating Node 'Current Channel'
1755:         node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(State,_State); // Evaluating Node 'alSurfaceX/Height As Normal'
1756:         node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(State,_State); // Evaluating Node 'alSurfaceX/Normal Modulation'
1757:         node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(State,_State); // Evaluating Node 'alSurfaceX/Tangent Space To Eye Space'
1758:         node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(State,_State); // Evaluating Node 'alSurfaceX/Color To Vector'
1759:         node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(State,_State); // Evaluating Node 'alSurfaceX/Tangent Space To Eye Space 2'
1760:         node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(State,_State); // Evaluating Node 'alSurfaceX/Set Unlit'
1761:         node_83662364_52db_4f7b_b336_baca232fc310_func(State,_State); // Evaluating Node 'alSurfaceX/'
1762:         {
1763: 
1764:     _State.Diffuse = node_83662364_52db_4f7b_b336_baca232fc310_Output;
1765:                 
1766:         }
1767:     }
1768: 
1769: }
1770: 
1771: 
0(1679) : error C1008: undefined variable "Kr1"
0(1679) : error C1008: undefined variable "Kr2"

---CompilerLog---
0(1679) : error C1008: undefined variable "Kr1"
0(1679) : error C1008: undefined variable "Kr2"


Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 57 ms 55 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 61 ms 56 uu
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 49 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 74 uu
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 119 ms
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:711 ] : [ !! ] Shader 'Shader Network1' Compilation Failure. Not linking.
---SourceCode---
Shader Type: Fragment
1: #version 150
2: #define MRI_SHADER_FRAGMENT 1
3: #define MRI_NUM_PATCH_ATTRIBUTES 4096
4: #define MRI_SVT_GATHER_USE_QUINT 1
5: #define MRI_USE_CUBE_MAP_ARRAY 1
6: #define USE_DEFERRED_TEXTURE_2D_ARRAY 1
7: 
8: //! Description |  Shader Network evaluation fragment shader
9: //! Name |  Func_ShaderNetwork.frag
10: //! Author |  Jack Greasley, Kiyoyuki Nakagaki, Duncan Hopkins
11: //! Copyright |  Copyright (c) 2013 The Foundry 
12: 
13: #define MRI_LIGHT_ARRAY_SIZE 4
14: 
15: struct MriSystemFragmentState
16: {
17:     vec4 Diffuse;
18:     vec4 Unlit;
19:     vec4 VectorData;
20: 
21:     vec2 dUV;
22: 
23:     vec3 ProjectionCoord;
24:     vec2 TangentInProjectionSpace;
25:     vec2 BitangentInProjectionSpace;
26: 
27:     bool Hidden;
28:     bool Locked;
29:     bool Selected;
30: 
31:     float ProjectionExposure;
32:     float NonPreviewableProjectionExposure;
33: 
34:     bool PatchSelected;
35:     bool FaceSelected;
36:     bool ObjectSelected;
37: 
38:     float TriangleId;
39:     float TileId; 
40:     float MipLevel;
41: 
42:     bool GeoExists;
43: };
44: 
45: struct MriFragmentState
46: {
47:     float AmbientOcclusion;
48: 
49:     vec3 Position;
50:     vec2 UV;
51:     vec3 Normal;
52:     vec3 Tangent;
53:     vec3 Bitangent;
54: 
55:     vec3 NormalInEyeSpaceFromViewCamera;
56:     vec3 TangentInEyeSpaceFromViewCamera;
57:     vec3 BitangentInEyeSpaceFromViewCamera;
58:     vec3 ViewVectorInEyeSpaceFromViewCamera;
59:     vec3 FragmentPositionInEyeSpaceFromViewCamera;
60: 
61:     vec3 NormalInEyeSpaceFromProjectionCamera;
62:     vec3 TangentInEyeSpaceFromProjectionCamera;
63:     vec3 BitangentInEyeSpaceFromProjectionCamera;
64:     vec3 ViewVectorInEyeSpaceFromProjectionCamera;
65: 
66:     vec3 FragmentPositionInEyeSpaceFromProjectionCamera;
67:     vec3 FragmentPositionInNdcSpaceFromProjectionCamera;
68: 
69:     float PatchId;
70:     int   FaceId;
71:     int   FaceIndex;
72: };
73: 
74: struct Channel
75: {
76:     // r - int index; 
77:     // g - bool active;
78:     // b - bool invert;
79:     ivec3 ChannelValues;
80:     // a - reserved
81: };
82: 
83: #if defined( USE_DEPTH_PROJECTIONS)
84: struct MriLight
85: {
86:     int depthProjectorIndex;
87:     int depthProjectorCount;
88: };
89: 
90: struct MriDepthProjection
91: {
92:     mat4 transform;
93: };
94: #endif
95: 
96: 
97: //Gives the true texture coordinates for the base texture
98: vec2 svt_coords(vec2 coords);
99: 
100: //This function gives the raw color value from the texture in Base channel without any filters or projection applied 
101: vec4 svt_texture(Channel Base, vec2 coords);
102: vec4 svt_texture(Channel Base, in MriFragmentState State, in MriSystemFragmentState _State);
103: 
104: //Collect height values from bump map
105: vec4 get_heights(Channel Base, vec2 coords);
106: 
107: //This function gives the color value from the texture in Base channel with some filters and projection applied if applicable
108: vec4 texture_lookup(Channel Base, vec2 coords);
109: 
110: //texture look up function for version 2.0
111: vec4 texture_lookup2(Channel Base, in MriFragmentState State, in MriSystemFragmentState _State);
112: 
113: float tex_mip_level(vec2 coord);
114: 
115: //Default shadow casting function
116: float mriLightVisibility( in int LightIndex, vec3 FragmentPosition);
117: 
118: //Functions for evaluating values with a bit of UV offset.
119: float dFdu(float F);
120: float dFdv(float F);
121: vec2 dFdu(vec2 F);
122: vec2 dFdv(vec2 F);
123: mat2 dFd(vec2 F);
124: vec3 dFdu(vec3 F);
125: vec3 dFdv(vec3 F);
126: mat2x3 dFd(vec3 F);
127: 
128: float F(float f0, vec2 dUV);
129: vec2 F(vec2 f0, vec2 dUV);
130: vec3 F(vec3 f0, vec2 dUV);
131: 
132: void apply_projection_masks(inout MriFragmentState State, inout MriSystemFragmentState _State);
133: 
134: void evaluate_shader_network(inout MriFragmentState State, inout MriSystemFragmentState _State);
135: 
136: 
137: #define MRI_LIGHT_ARRAY_SIZE 4
138: 
139: // DO NOT CHANGE this structure with out adjusting the uniform upload C++ code.
140: struct MriLightSource
141: {
142:     vec4 Position;
143: 
144:     vec4 AmbientColor;
145:     vec4 DiffuseColor;
146:     vec4 SpecularColor;
147: 
148:     float SpotCutoff;
149:     float SpotExponent;
150: 
151:     float ConstantAttenuation;
152:     float LinearAttenuation;
153:     float QuadraticAttenuation;
154: };
155: 
156: // Returns the lighting value to use from the external environment map
157: //  shapness - how clear or blurred the light source is
158: //   0.0 - Totally blurred light sources. same as using dot( normal, light) calculation
159: //   1.0 - Totally sharp
160: vec3 mriEnvironmentLight( in vec3 normal, in float sharpness);
161: bool mriEnvironmentLightOn();
162: 
163: 
164: float mriBRDF_sqr(float x);
165: 
166: float mriBRDF_SchlickFresnel(float u);
167: float mriBRDF_GTR1(float NdotH, float a);
168: float mriBRDF_GTR2(float NdotH, float a);
169: float mriBRDF_GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay);
170: float mriBRDF_smithG_GGX(float Ndotv, float alphaG);
171: vec3 mriBRDF_mon2lin(vec3 x);
172: 
173: 
174: ////////////////////////////////////////////////////////////////////////////////
175: // Custom BRDF Function Library Extension Registration
176: // Copyright (c) 2014 Antonio Lisboa M. Neto. All Rights Reserved.
177: //////////////////////////////////////////////////////////////////////////////// 
178: // File: BRDF_FunctionLib_ext.glslc	
179: // Description: Function Library Extension for be used in the new Custom BRDF Shaders
180: ////////////////////////////////////////////////////////////////////////////////               	
181: // Author: Antonio Neto       	
182: // Web: www.netocg.blogspot.com			
183: // Email: netocg.fx@gmail.com
184: ////////////////////////////////////////////////////////////////////////////////			                                   	
185: // Date: Jan 25, 2014	         		
186: ////////////////////////////////////////////////////////////////////////////////
187: 
188: float att(vec3 L, int Light_Falloff, float Decay_Rate);
189: float color_toValue(vec3 Color);
190: vec3 pow_RGB(vec3 Color, float Value);
191: vec3 convert_Colorspace(vec3 color, int Colorspace_Profile);
192: float mriBRDF_Fresnel(vec3 L, vec3 H, float eta);
193: float mriBRDF_Fresnel_Schlicks(vec3 L, vec3 H, float Reflectance);
194: float mriBRDF_Fresnel_Dielectric(vec3 L, vec3 H, float ior);
195: float mriBRDF_Fresnel_Conductor(vec3 L, vec3 H, float eta, float k);
196: float nfresnel(float cos_theta_r, float eta);
197: float mriBRDF_Oren_Nayar(vec3 N, vec3 V, vec3 L, float difrough2);
198: float mriBRDF_Beckman(vec3 N, vec3 H, float specrough2);
199: float mriBRDF_Geo_att_Cook_Torrance(vec3 N, vec3 H, vec3 V, vec3 L);
200: float mriBRDF_Ward(vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specrough2);
201: float mriBRDF_Geo_att_Ward_Duer( vec3 L, vec3 V, vec3 N, vec3 H);
202: float mriBRDF_Ashikhmin_Shirley( vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specrough2);
203: float mriBRDF_Geo_Att_Ash_Sh00( vec3 N, vec3 V, vec3 L);
204: float mriBRDF_Blinn(vec3 N, vec3 H, float specrough2);
205: float mriBRDF_Geo_att_Schlick_Smith(vec3 N, vec3 L, vec3 V, float specrough2);
206: float mriBRDF_Phong(vec3 N, vec3 V, vec3 H, float specrough2);
207: float mriBRDF_Geo_att_Beckmann(vec3 N, vec3 V, float specrough2);
208: float mriBRDF_GTR(vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specGloss, float ggxTailFalloff);
209: float mriBRDF_Geo_att_smithG_GGX(float NdotV, float specGloss);
210: 
211: /****************************************************************************
212: * Camera information
213: *****************************************************************************/
214: // camera type of the current view
215: // 0 - Perspective
216: // 1 - Ortho
217: // 2 - UV
218: uniform int u_MriViewType;
219: 
220: // x:left, y:top, z:right, w:bottom
221: uniform vec4 u_MriViewport;
222: 
223: /****************************************************************************
224: * Matrices
225: *****************************************************************************/
226: uniform mat4 u_MriViewMatrix;
227: uniform mat4 u_MriModelViewMatrix;
228: uniform mat4 u_MriProjectionMatrix;
229: uniform mat4 u_MriNormalMatrix;
230: 
231: /****************************************************************************
232: * Object information
233: *****************************************************************************/
234: uniform int u_MriObjectId;
235: uniform vec3 u_MriObjectCenter;
236: uniform float u_MriObjectRadius;
237: 
238: /****************************************************************************
239: * Light information
240: *****************************************************************************/
241: //Lighting mode
242: // 0 - Flat
243: // 1 - Basic (Diffuse only)
244: // 2 - Full
245: uniform int u_MriLightingMode;
246: 
247: uniform MriLightSource u_MriLightSources[MRI_LIGHT_ARRAY_SIZE];
248: 
249: /****************************************************************************
250: * Misc
251: *****************************************************************************/
252: // The current animation frame
253: uniform int u_MriCurrentFrame;
254: 
255: // The system time in milliseconds. Will wrap every ~70 minutes.
256: uniform int u_MriSystemTime;
257: 
258: uniform vec2 u_MriMaxSupportedTextureSize;
259: 
260: 
261: 
262: float mriColorBlend(float pixel, float fPixel, float bPixel, float fAlpha, float bAlpha, int normal);
263: vec3 mriColorBlendv(vec3 modifiedColor, vec3 layerColor, vec3 baseColor, float layerAlpha, float baseAlpha, int normal);
264: float mriAlphaBlend( float fAlpha, float bAlpha);
265: float mriRgb2Lightness(vec4 RGBA);
266: vec4 mriRgb2Hsl(vec4 colorIn);
267: vec4 mriHsl2Rgb(vec4 colorIn);
268: vec4 mriRgb2Hsv(vec4 colorIn);
269: vec4 mriHsv2Rgb(vec4 colorIn);
270: 
271: vec4 Comp_Add(vec4 base,vec4 blend,float Opacity);
272: vec4 Comp_BurnHighlights(vec4 base,vec4 blend,float Opacity);
273: vec4 Comp_BurnMidrange(vec4 base,vec4 blend,float Opacity);
274: vec4 Comp_BurnShadows(vec4 base,vec4 blend,float Opacity);
275: vec4 Comp_Clear(vec4 base,vec4 blend,float Opacity);
276: vec4 Comp_Color(vec4 base,vec4 blend,float Opacity);
277: vec4 Comp_ColorBurn(vec4 base,vec4 blend,float Opacity);
278: vec4 Comp_ColorDodge(vec4 base,vec4 blend,float Opacity);
279: vec4 Comp_Copy(vec4 base,vec4 blend,float Opacity);
280: vec4 Comp_CopyRGB(vec4 base,vec4 blend,float Opacity);
281: vec4 Comp_Darken(vec4 base,vec4 blend,float Opacity);
282: vec4 Comp_Default(vec4 base,vec4 blend,float Opacity);
283: vec4 Comp_Difference(vec4 base,vec4 blend,float Opacity);
284: vec4 Comp_DodgeHighlights(vec4 base,vec4 blend,float Opacity);
285: vec4 Comp_DodgeMidrange(vec4 base,vec4 blend,float Opacity);
286: vec4 Comp_DodgeShadows(vec4 base,vec4 blend,float Opacity);
287: vec4 Comp_Exclusion(vec4 base,vec4 blend,float Opacity);
288: vec4 Comp_HardLight(vec4 base,vec4 blend,float Opacity);
289: vec4 Comp_HardMix(vec4 base,vec4 blend,float Opacity);
290: vec4 Comp_Hue(vec4 base,vec4 blend,float Opacity);
291: vec4 Comp_InverseDifference(vec4 base,vec4 blend,float Opacity);
292: vec4 Comp_Invert(vec4 base,vec4 blend,float Opacity);
293: vec4 Comp_Lighten(vec4 base,vec4 blend,float Opacity);
294: vec4 Comp_Luminance(vec4 base,vec4 blend,float Opacity);
295: vec4 Comp_Multiply(vec4 base,vec4 blend,float Opacity);
296: vec4 Comp_Overlay(vec4 base,vec4 blend,float Opacity);
297: vec4 Comp_PinLight(vec4 base,vec4 blend,float Opacity);
298: vec4 Comp_Saturation(vec4 base,vec4 blend,float Opacity);
299: vec4 Comp_Screen(vec4 base,vec4 blend,float Opacity);
300: vec4 Comp_SoftLight(vec4 base,vec4 blend,float Opacity);
301: vec4 Comp_SpongeDesaturate(vec4 base,vec4 blend,float Opacity);
302: vec4 Comp_VividLight(vec4 base,vec4 blend,float Opacity);
303: vec4 Comp_Contrast(vec4 base,vec4 blend,float Opacity);
304: vec4 Comp_Decontrast(vec4 base,vec4 blend,float Opacity);
305: vec4 Comp_MixRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
306: vec4 Comp_AddRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
307: vec4 Comp_ReorientedNormalMappingRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
308: 
309: // Blending functions the operate on the color channels only. Used by things such as color adjustments where the alpha channel needs to be ignored.
310: vec4 Comp_Default(vec4 Base, vec3 Blend, float Amount);
311: vec4 Comp_Add(vec4 Base, vec3 Blend, float Amount);
312: vec4 Comp_Color(vec4 Base, vec3 Blend, float Amount);
313: vec4 Comp_Copy(vec4 Base, vec3 Blend, float Amount);
314: vec4 Comp_CopyRGB(vec4 Base, vec3 Blend, float Amount);
315: vec4 Comp_Darken(vec4 Base, vec3 Blend, float Amount);
316: vec4 Comp_Difference(vec4 Base, vec3 Blend, float Amount);
317: vec4 Comp_Hue(vec4 Base, vec3 Blend, float Amount);
318: vec4 Comp_InverseDifference(vec4 Base, vec3 Blend, float Amount);
319: vec4 Comp_Lighten(vec4 Base, vec3 Blend, float Amount);
320: vec4 Comp_Luminance(vec4 Base, vec3 Blend, float Amount);
321: vec4 Comp_Multiply(vec4 Base, vec3 Blend, float Amount);
322: vec4 Comp_Saturation(vec4 Base, vec3 Blend, float Amount);
323: 
324: vec4 Comp_VecDefault2d(vec4 base,vec4 blend,float Opacity);
325: vec4 Comp_VecDefault3d(vec4 base,vec4 blend,float Opacity);
326: 
327: vec4 Comp_VecAdd3d(vec4 base,vec4 blend,float Opacity);
328: vec4 Comp_VecAdd2d(vec4 base,vec4 blend,float Opacity);
329: 
330: vec4 Comp_VecScale3d(vec4 base,vec4 blend,float Opacity);
331: 
332: //! macro | custom_blend_mode_declarations | // No custom blend modes
333: 
334: 
335: 
336: 
337: //Curve lookup functions
338: 
339: float mriCurveLookup( in int Line, in float InValue);
340: 
341: 
342: 
343: 
344: /****************************************************************************
345: * Noise functions
346: *****************************************************************************/
347: 
348: //These functions generate Perlin and Simplex noise from 2D,3D,4D inputs
349: float mriPerlinNoise(vec2 P);
350: float mriPerlinNoise(vec3 P);
351: float mriPerlinNoise(vec4 P);
352: float mriSimplexNoise(vec2 P);
353: float mriSimplexNoise(vec3 P);
354: float mriSimplexNoise(vec4 P);
355: 
356: // DEPRECATED in favor of more explicit function names above
357: float mriNoise(vec3 P); 
358: 
359: 
360: //Cellular (Worley) noise generation function based on 3D input and different types of norm(distance) calculation. This returns vec3 in which F1, F2 and F1-F2 are returned in r, g and b of the resulting vec3 respectively. Cellular noise is a noise obtained by calculating distance to randomly generated points. The definition of the distance is the norm. F1 is the distance to the closest point while F2 is the distance to the 2nd closest point.  
361: // norm - The norm(distance calculation) definition to use. 
362: //  0 : Manhattan norm
363: //  1 : Euclidian norm
364: //  2 : Chebyshev(Infinity) norm
365: //  3 : P-norm where P=0.5
366: vec3 mriCellular(vec3 P, int norm);
367: 
368: // DEPRECATED
369: // These functions are provided for backward compatibility since the older version of Mari had these.
370: // These are deprecated and to be removed in favor of more explicitly named functions above.
371: float noise(vec3 P);
372: vec3 cellular(vec3 P, int norm);
373: 
374: 
375: 
376: 
377: //Given the face index at the evaluation point (usually the fragment), this returns hiddenness, lockedness and selectedness of the face in r,g and b respectively.
378: //the a component is currently not used, but reserved for the future usage
379: vec4 mriFaceSystemAttribute(int FaceIndex);
380: 
381: //Given the primitiveID, returns the face index of the original mesh
382: int mriFaceIndex(int PrimitiveID);
383: 
384: 
385: 
386: /****************************************************************************
387: * Misc
388: *****************************************************************************/
389: //This is an untility function to do the implementation of how to interpret a given color value as a mask. Whoever needs to regard some color value as mask should call this function for consistent mechanism
390: float interpretAsExposure(in vec4 Color,int Mode);
391: 
392: 
393: 
394: 
395: // Function for handling standard Vector Painting Maths
396: 
397: vec3 vector_bias( vec3 vector);
398: vec3 vector_unbias( vec3 colour);
399: 
400: vec3 vector_paintToTangent3D( vec3 screen);
401: vec3 vector_paintToTangent2D( vec3 screen);
402: 
403: vec3 vector_worldToTangent( vec3 tangent);
404: vec3 vector_tangentToWorld( vec3 tangent);
405: vec3 vector_tangentToScreen( vec3 tangent);
406: 
407: 
408: 
409: //! macro | module_inputs | // No Module Inputs
410: //! macro | module_calls  | // No Module Calls
411: //! macro | module_declarations  | // No Module Declarations
412: 
413: //! macro | surface_mask_declarations | // No mask applied
414: //! macro | surface_mask_body         | // No mask applied
415: 
416: uniform int udim_size;
417: 
418: void store_state(inout MriFragmentState State, inout MriSystemFragmentState _State);
419: void derive_state(inout MriFragmentState State, inout MriSystemFragmentState _State, float du, float dv);
420: void restore_state(inout MriFragmentState State, inout MriSystemFragmentState _State);
421: 
422: #define REVAL(func,du,dv) store_state(State, _State);derive_state(State, _State, du, dv);func(State,_State);restore_state(State, _State);
423: 
424: 
425: 
426: float olefresnel(float r, float g, float c);
427: float get_n(float r,float g);
428: float get_k2(float r, float n);
429: float n_min(float r);
430: float n_max(float r);
431: vec3 FresnelConductor(vec3 Refelctivity, vec3 EdgeTint,float cos_theta);//=====================
432: // Forward Declaration of functions
433: //=====================
434: 
435: void node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
436: void node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
437: void node_516e4503_ea09_4104_8e31_2e667c820272_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
438: void node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
439: void node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
440: void node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
441: void node_45b7815b_0361_452e_b5c5_f476cf68940f_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
442: void node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
443: void node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
444: void node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
445: void node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
446: void node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
447: void node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
448: void node_83662364_52db_4f7b_b336_baca232fc310_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
449: 
450: //=====================
451: // Declaration of functions
452: //=====================
453: 
454: //=====================
455: //--- Style 2 Node 'Bottom Transparency' ---
456: //=====================
457: vec4 node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output; // Output 'Output' 
458: void node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
459: {
460:     vec4 Output; // Output 'Output' 
461: 
462:     Output = vec4( 0, 0, 0, 0);
463:         
464:     node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output = Output;
465: }
466: 
467: //=====================
468: //--- Style 2 Node 'Paint 3' ---
469: //=====================
470: uniform Channel Channel_node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_;
471: vec4 node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output; // Output 'Output' 
472: void node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
473: {
474:     vec4 Output; // Output 'Output' 
475: 
476:                   
477:         Output = texture_lookup2(Channel_node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_,State,_State);
478:                   
479:               
480:     node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output = Output;
481: }
482: 
483: //=====================
484: //--- Style 2 Node 'Merge_Bump_Head' ---
485: //=====================
486: uniform int AdvancedEnabled_node_516e4503_ea09_4104_8e31_2e667c820272_;
487: uniform float Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
488: uniform int AmountEnabled_node_516e4503_ea09_4104_8e31_2e667c820272_;
489: uniform int BlendIfBelow_node_516e4503_ea09_4104_8e31_2e667c820272_;
490: uniform int BlendIfThis_node_516e4503_ea09_4104_8e31_2e667c820272_;
491: uniform int BlendMode_node_516e4503_ea09_4104_8e31_2e667c820272_;
492: uniform int Component_node_516e4503_ea09_4104_8e31_2e667c820272_;
493: uniform int SwizzleA_node_516e4503_ea09_4104_8e31_2e667c820272_;
494: uniform int SwizzleB_node_516e4503_ea09_4104_8e31_2e667c820272_;
495: uniform int SwizzleG_node_516e4503_ea09_4104_8e31_2e667c820272_;
496: uniform int SwizzleR_node_516e4503_ea09_4104_8e31_2e667c820272_;
497: vec4 node_516e4503_ea09_4104_8e31_2e667c820272_Output; // Output 'Output' 
498: void node_516e4503_ea09_4104_8e31_2e667c820272_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
499: {
500:     vec4 Output; // Output 'Output' 
501: 
502:     if( 0 != 0)
503:     {
504:         // this is used to control what component we are pulling the key from
505:         vec3 Mult[5];
506: 
507:         Mult[0] = vec3(1.0/3.0,1.0/3.0,1.0/3.0);
508:         Mult[1] = vec3(1,0,0);
509:         Mult[2] = vec3(0,1,0);
510:         Mult[3] = vec3(0,0,1);
511:         Mult[4] = vec3(0.2126,0.7152,0.0722);
512: 
513: 
514:         // Calculate the amount from the component
515:         // a Mult value of (1,0,0) will isolate the red value
516:         // A mult value of (1,1,1) will give a gray scale
517: 
518:         float ThisAmount = dot(node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output.rgb , Mult[0]);
519:         float BelowAmount = dot(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output.rgb , Mult[0]);
520: 
521:         // now that we've pulled the component out of above and below
522:         // we lookup into the lut to find out the amount to scale the alpha values by
523: 
524:         float ThisAlpha  = mriCurveLookup(BlendIfThis_node_516e4503_ea09_4104_8e31_2e667c820272_,ThisAmount);
525:         float BelowAlpha = mriCurveLookup(BlendIfBelow_node_516e4503_ea09_4104_8e31_2e667c820272_,BelowAmount);
526: 
527:         // now we multiply the base alpha value by both values
528: 
529:         float AdvancedBlendAmount = ThisAlpha * BelowAlpha;
530:         if( 0 != 1)
531:         {
532:             AdvancedBlendAmount *= Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
533:         }
534: 
535:         Output = Comp_Default(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output, node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output, vec4(1,1,1,1).r * AdvancedBlendAmount);
536:     }
537:     else
538:     {
539:         float BlendAmount = 1;
540:         if( 0 != 1)
541:         {
542:             BlendAmount *= Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
543:         }
544:         Output = Comp_Default(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output, node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output, BlendAmount * vec4(1,1,1,1).r);
545:     }
546: 
547:     Output = vec4( Output.r, Output.g, Output.b, Output.a);
548: 
549:                 
550:     node_516e4503_ea09_4104_8e31_2e667c820272_Output = Output;
551: }
552: 
553: //=====================
554: //--- Style 2 Node 'Paint 4' ---
555: //=====================
556: uniform Channel Channel_node_5ab26bd0_71fd_473d_ba94_940da940e2a5_;
557: vec4 node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output; // Output 'Output' 
558: void node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
559: {
560:     vec4 Output; // Output 'Output' 
561: 
562:                   
563:         Output = texture_lookup2(Channel_node_5ab26bd0_71fd_473d_ba94_940da940e2a5_,State,_State);
564:                   
565:               
566:     node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output = Output;
567: }
568: 
569: //=====================
570: //--- Style 2 Node 'Layer' ---
571: //=====================
572: uniform int AdvancedEnabled_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
573: uniform float Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
574: uniform int AmountEnabled_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
575: uniform int BlendIfBelow_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
576: uniform int BlendIfThis_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
577: uniform int BlendMode_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
578: uniform int Component_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
579: uniform int SwizzleA_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
580: uniform int SwizzleB_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
581: uniform int SwizzleG_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
582: uniform int SwizzleR_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
583: vec4 node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output; // Output 'Output' 
584: void node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
585: {
586:     vec4 Output; // Output 'Output' 
587: 
588:     if( 0 != 0)
589:     {
590:         // this is used to control what component we are pulling the key from
591:         vec3 Mult[5];
592: 
593:         Mult[0] = vec3(1.0/3.0,1.0/3.0,1.0/3.0);
594:         Mult[1] = vec3(1,0,0);
595:         Mult[2] = vec3(0,1,0);
596:         Mult[3] = vec3(0,0,1);
597:         Mult[4] = vec3(0.2126,0.7152,0.0722);
598: 
599: 
600:         // Calculate the amount from the component
601:         // a Mult value of (1,0,0) will isolate the red value
602:         // A mult value of (1,1,1) will give a gray scale
603: 
604:         float ThisAmount = dot(node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output.rgb , Mult[0]);
605:         float BelowAmount = dot(node_516e4503_ea09_4104_8e31_2e667c820272_Output.rgb , Mult[0]);
606: 
607:         // now that we've pulled the component out of above and below
608:         // we lookup into the lut to find out the amount to scale the alpha values by
609: 
610:         float ThisAlpha  = mriCurveLookup(BlendIfThis_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_,ThisAmount);
611:         float BelowAlpha = mriCurveLookup(BlendIfBelow_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_,BelowAmount);
612: 
613:         // now we multiply the base alpha value by both values
614: 
615:         float AdvancedBlendAmount = ThisAlpha * BelowAlpha;
616:         if( 0 != 1)
617:         {
618:             AdvancedBlendAmount *= Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
619:         }
620: 
621:         Output = Comp_Default(node_516e4503_ea09_4104_8e31_2e667c820272_Output, node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output, vec4(1,1,1,1).r * AdvancedBlendAmount);
622:     }
623:     else
624:     {
625:         float BlendAmount = 1;
626:         if( 0 != 1)
627:         {
628:             BlendAmount *= Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
629:         }
630:         Output = Comp_Default(node_516e4503_ea09_4104_8e31_2e667c820272_Output, node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output, BlendAmount * vec4(1,1,1,1).r);
631:     }
632: 
633:     Output = vec4( Output.r, Output.g, Output.b, Output.a);
634: 
635:                 
636:     node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output = Output;
637: }
638: 
639: //=====================
640: //--- Style 2 Node 'Bump_Head' ---
641: //=====================
642: vec4 node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output; // Output 'Output' 
643: void node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
644: {
645:     vec4 Output; // Output 'Output' 
646: 
647:     Output = node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output;
648:                 
649:     node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output = Output;
650: }
651: 
652: //=====================
653: //--- Style 2 Node 'Current Channel' ---
654: //=====================
655: vec4 node_45b7815b_0361_452e_b5c5_f476cf68940f_Output; // Output 'Output' 
656: void node_45b7815b_0361_452e_b5c5_f476cf68940f_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
657: {
658:     vec4 Output; // Output 'Output' 
659: 
660:     Output = node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output;
661:                 
662:     node_45b7815b_0361_452e_b5c5_f476cf68940f_Output = Output;
663: }
664: 
665: //=====================
666: //--- Style 2 Node 'alSurfaceX/Height As Normal' ---
667: //=====================
668: uniform int BumpMode_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_;
669: uniform float BumpWeight_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_;
670: vec4 node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output; // Output 'Output' 
671: void node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
672: {
673:     vec4 Output; // Output 'Output' 
674: 
675:     // distance in texture space [0,1] between adjacent pixels at this mip level
676:     float Offset = exp2(_State.MipLevel)/u_MriMaxSupportedTextureSize.x;
677: 
678:     float BumpWeight = BumpWeight_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_/Offset;
679: 
680: 
681: #if 0
682:     // fudge factor
683:     BumpWeight *= 1.0/(30.0 * 16.0);
684: 
685:     // Bump mapping version A
686:     //Default Input Used : NO REVAL(Heightfunc,-Offset,0.0);
687:     float l=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
688: 
689:     //Default Input Used : NO REVAL(Heightfunc,Offset,0.0);
690:     float r=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
691: 
692:     //Default Input Used : NO REVAL(Heightfunc,0.0,-Offset);
693:     float b=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
694: 
695:     //Default Input Used : NO REVAL(Heightfunc,0.0,Offset);
696:     float t=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
697: 
698:     vec2 heightDelta = vec2( l - r, b - t);
699: #else
700:     // fudge factor
701:     BumpWeight *= 2.0/(30.0 * 16.0);
702: 
703:     // Bump mapping version A
704:     float c=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
705: 
706:     //Default Input Used : NO REVAL(Heightfunc,Offset,0.0);
707:     float r=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
708: 
709:     //Default Input Used : NO REVAL(Heightfunc,0.0,Offset);
710:     float t=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
711: 
712:     vec2 heightDelta = vec2( c - r, c - t);
713: #endif
714: 
715:     Output.rgb = normalize( vec3(heightDelta,1.0) ) * vec3(0.5,-0.5,0.5) + vec3(0.5); 
716:     Output.a = 1.0; 
717:                 
718:     node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output = Output;
719: }
720: 
721: //=====================
722: //--- Style 2 Node 'alSurfaceX/Normal Modulation' ---
723: //=====================
724: vec4 node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output; // Output 'Output' 
725: void node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
726: {
727:     vec4 Output; // Output 'Output' 
728: 
729:         vec3 norm = vec3(0.0, 0.0, 0.0);
730:         vec3 norm0 = vec4(0.5,0.5,1.0,1.0).rgb * 2.0 -1.0;
731:         vec3 norm1 = node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output.rgb * 2.0 - 1.0;
732: 
733:         norm += dot(norm0.xy,norm0.xy)>0.0 ? norm0  : vec3(0.0);
734:         norm += dot(norm1.xy,norm1.xy)>0.0 ? norm1  : vec3(0.0);
735: 
736:         //When there is no bump/normal, set it to default
737:         norm = dot(norm,norm)>0.0 ? norm  : vec3(0.0,0.0,1.0);
738: 
739:         Output.rgb = normalize(norm);
740:         Output.a = 1.0;
741:                 
742:     node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output = Output;
743: }
744: 
745: //=====================
746: //--- Style 2 Node 'alSurfaceX/Tangent Space To Eye Space' ---
747: //=====================
748: vec4 node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output; // Output 'Output' 
749: void node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
750: {
751:     vec4 Output; // Output 'Output' 
752: 
753:     mat3 tangentSpace2eyeSpace = mat3(
754:         State.TangentInEyeSpaceFromViewCamera,
755:         State.BitangentInEyeSpaceFromViewCamera,
756:         State.NormalInEyeSpaceFromViewCamera
757:     );
758:     Output.rgb = normalize( tangentSpace2eyeSpace * (node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output.rgb * vec3( 1,-1,1)));
759:     Output.a = node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output.a;
760:                 
761:     node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output = Output;
762: }
763: 
764: //=====================
765: //--- Style 2 Node 'alSurfaceX/Color To Vector' ---
766: //=====================
767: vec4 node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output; // Output 'Output' 
768: void node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
769: {
770:     vec4 Output; // Output 'Output' 
771: 
772:         vec3 norm = (vec4(1.0,0.5,0.5,1.0).rgb * 2.0) - 1.0;
773: 
774:         Output.rgb = norm;
775:         Output.a = 1.0;
776:                 
777:     node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output = Output;
778: }
779: 
780: //=====================
781: //--- Style 2 Node 'alSurfaceX/Tangent Space To Eye Space 2' ---
782: //=====================
783: vec4 node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output; // Output 'Output' 
784: void node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
785: {
786:     vec4 Output; // Output 'Output' 
787: 
788:     mat3 tangentSpace2eyeSpace = mat3(
789:         State.TangentInEyeSpaceFromViewCamera,
790:         State.BitangentInEyeSpaceFromViewCamera,
791:         State.NormalInEyeSpaceFromViewCamera
792:     );
793:     Output.rgb = normalize( tangentSpace2eyeSpace * (node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output.rgb * vec3( 1,-1,1)));
794:     Output.a = node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output.a;
795:                 
796:     node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output = Output;
797: }
798: 
799: //=====================
800: //--- Style 2 Node 'alSurfaceX/Set Unlit' ---
801: //=====================
802: vec4 node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output; // Output 'Output' 
803: void node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
804: {
805:     vec4 Output; // Output 'Output' 
806: 
807: 
808:     _State.Unlit = ((_State.Unlit.a==0.0) ? node_45b7815b_0361_452e_b5c5_f476cf68940f_Output : _State.Unlit);
809:     Output = node_45b7815b_0361_452e_b5c5_f476cf68940f_Output;
810:                 
811:     node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output = Output;
812: }
813: 
814: //=====================
815: //--- Style 2 Node 'alSurfaceX/' ---
816: //=====================
817: uniform float AmbientOcclusion_node_83662364_52db_4f7b_b336_baca232fc310_;
818: uniform vec4 BacklightColor_node_83662364_52db_4f7b_b336_baca232fc310_;
819: uniform float BacklightIndirectStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
820: uniform float BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
821: uniform bool ConvertToGlossiness_node_83662364_52db_4f7b_b336_baca232fc310_;
822: uniform float Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_;
823: uniform vec4 DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_;
824: uniform float DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
825: uniform float DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
826: uniform vec4 EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
827: uniform float EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
828: uniform int Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_;
829: uniform vec4 Opacity_node_83662364_52db_4f7b_b336_baca232fc310_;
830: uniform int Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_;
831: uniform vec4 SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_;
832: uniform vec4 SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_;
833: uniform float SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_;
834: uniform bool Solid_node_83662364_52db_4f7b_b336_baca232fc310_;
835: uniform float Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
836: uniform vec4 Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
837: uniform vec4 Specular1EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_;
838: uniform int Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_;
839: uniform float Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_;
840: uniform vec4 Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_;
841: uniform float Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
842: uniform float Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
843: uniform float Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;
844: uniform float Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
845: uniform vec4 Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_;
846: uniform vec4 Specular2EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_;
847: uniform int Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_;
848: uniform float Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_;
849: uniform vec4 Specular2Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_;
850: uniform float Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
851: uniform float Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
852: uniform float Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_;
853: uniform vec4 TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
854: uniform float TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_;
855: uniform bool TransmissionLinkToSpecular1_node_83662364_52db_4f7b_b336_baca232fc310_;
856: uniform float TransmissionRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
857: uniform float TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
858: uniform int shadingNode_node_83662364_52db_4f7b_b336_baca232fc310_;
859: vec4 node_83662364_52db_4f7b_b336_baca232fc310_Output; // Output 'Output' 
860: void node_83662364_52db_4f7b_b336_baca232fc310_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
861: {
862:     vec4 Output; // Output 'Output' 
863: 
864: 	shadingNode_node_83662364_52db_4f7b_b336_baca232fc310_; 
865: 	// Used for continually Mark what shader you are using in case you have renamed the name of the shader inside Mari. This var is also used for the exporter to identify what shader he is picking.
866: 	
867: 	DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_;
868: 	DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
869: 	Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
870: 	Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
871: 	Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
872: 	Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
873: 	Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_;
874: 	Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
875: 	Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
876: 	Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
877: 	Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
878: 	TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
879: 	TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
880: 	TransmissionRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
881: 	Opacity_node_83662364_52db_4f7b_b336_baca232fc310_;
882: 	SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_;
883: 	SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_;
884: 	EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;	
885: 	
886: 	// These control/input pairs are alpha blended together.
887: 	// If the Channel has an input connected the input is used.	
888: 	// Else the attribute slider is used instead.
889: 	// VAR Name   			 'mix' based on existence of an alpha in the channels	
890: 	vec3 difCol	   			= mix( vec3(0),		vec4(DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,		vec4(DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
891: 	vec3 specCol1  			= mix( vec3(0),		vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
892: 	vec3 specCol2  			= mix( vec3(0),		vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
893: 	vec3 reflCol1  			= mix( vec3(0),		vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
894: 	vec3 reflCol2  			= mix( vec3(0),		vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
895: 	vec3 refrCol  			= mix( vec3(0),		vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
896: 	vec3 transCol 			= mix( vec3(0),		vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
897: 	vec3 sssCol	   			= mix( vec3(0),		vec4(SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb, 			vec4(SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a				== 0 ? 0 : 1);
898: 	vec3 sssRadius 			= mix( vec3(0), 	vec4(SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb, 		vec4(SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 			== 0 ? 0 : 1);
899: 	vec3 emisCol   			= mix( vec3(0),		vec4(EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	 	vec4(EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a		== 0 ? 0 : 1);
900: 		
901: 	float difrough 	 		= mix( float(0),	vec4(DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
902: 	float spec1rough 		= mix( float(0),	vec4(Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
903: 	float ani1				= mix( float(0),	vec4(Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
904: 	float rot1 		 		= mix( float(0),	vec4(Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
905: 	float spec2rough 		= mix( float(0),	vec4(Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
906: 	float ani2				= mix( float(0),	vec4(Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
907: 	float rot2 		 		= mix( float(0),	vec4(Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
908: 	float refrarough		= mix( float(0),	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).r,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 	== 0 ? 0 : 1);
909: 	
910: 
911: 	vec3 Current_Channel_Selected = node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output.rgb;
912: 	
913: 	if(ConvertToGlossiness_node_83662364_52db_4f7b_b336_baca232fc310_ == true)
914: 	{
915: 		spec1rough = 1.0 - spec1rough;
916: 		spec2rough = 1.0 - spec2rough;
917: 	}
918: 	
919: 	// Check if there's Color painted at the rgb of the Opacity Channels	
920: 	vec3 opacityCol	 = vec3(0,0,0);
921: 	if (color_toValue(vec4(Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,0).rgb) == 0)
922: 	{
923: 		opacityCol = vec3(1.0) - Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb;
924: 	}
925: 	else
926: 	{
927: 		opacityCol = vec3(1.0) - vec4(Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,0).rgb;	
928: 	}	
929: 	
930: 	// The UV Viewport will display what is the Current Channel Selected, unless you don't have any channel. Then it will display the Mari`s alpha checkerboard pattern.	
931: 	if(u_MriViewType==2 || u_MriLightingMode==0)
932: 	{
933: 		// This is the cheapest way to use this "viewbuffer" feature, skipping most of the shader calculation.
934: 		
935: 		Output = node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output;		
936: 		
937: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 1)
938: 		{
939: 			Output.rgb = difCol.rgb;
940: 		}
941: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 2)
942: 		{
943: 			Output.rgb = specCol1.rgb;
944: 		}
945: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 3)
946: 		{
947: 			Output.rgb = reflCol1.rgb;
948: 		}
949: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 4)
950: 		{
951: 			Output.rgb = refrCol.rgb;
952: 		}
953: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 5)
954: 		{
955: 			Output.rgb = sssCol.rgb;
956: 		}
957: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 6)
958: 		{
959: 			Output.rgb = emisCol.rgb;
960: 		}
961: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7)
962: 		{
963: 			Output = vec4(0.5,0.5,0.5,0.0);
964: 		}
965: 		
966: 		//Display the Thickness imported image in the UV Viewport
967: 		if(u_MriViewType==2 && Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7) 
968: 		{
969: 			Output = vec4(0.5,0.5,0.5,0.0);			
970: 		}		
971: 	}
972: 	else
973: 	{
974: 		// ------------  All the shader math ------------
975: 		
976: 		const float PI = 3.14159265358979323846264;
977: 		const float TwoPI = 2.0 * PI;
978: 			
979: 		// View Direction
980: 		vec3 V = normalize(-State.ViewVectorInEyeSpaceFromViewCamera);
981: 		// Normal Direction
982: 		vec3 N = normalize(node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output.xyz);
983: 			
984: 		float NdotV = dot(N,V);
985: 		// On the wrong side of the face
986: 		if( NdotV <= 0.0)
987: 		{
988: 			N = -N;
989: 			NdotV = 1.0 - NdotV;
990: 		}
991: 				
992: 		//Enum Light direction
993: 		vec3 L = N;
994: 		// Half Vector
995: 		vec3 H = normalize(L+V);					
996: 		float cos_theta = dot(H,V);
997: 		vec3 RelectionTintColor1 = FresnelConductor(Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,Specular1EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,cos_theta);
998: 		//vec3 RelectionTintColor1 = Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb;
999: 		vec3 RelectionTintColor2 = FresnelConductor(Specular2Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,Specular2EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,cos_theta);
1000: 
1001: 				
1002: 		// Calculates the Space diagonal of the volume inside a cube
1003: 		vec3 viewPos = vec3(1.0);
1004: 		viewPos.x = mix(1, 2*abs(State.Position.x), abs(State.NormalInEyeSpaceFromViewCamera.x) );
1005: 		viewPos.y = mix(1, 2*abs(State.Position.y), abs(State.NormalInEyeSpaceFromViewCamera.y) );
1006: 		viewPos.z = mix(1, 2*abs(State.Position.z), abs(State.NormalInEyeSpaceFromViewCamera.z) );
1007: 		float base_diagonal = sqrt(viewPos.x*viewPos.x+viewPos.z*viewPos.z);
1008: 		float space_diagonal = sqrt(base_diagonal*base_diagonal + viewPos.y*viewPos.y);
1009: 			
1010: 		// Check if there is a texture assigned to the vec4(0.5,0.5,0.5,0.0) attribute, if does, then use it instead of the 1.5 value. 
1011: 		float Thickness = 1.5;	
1012: 		if(vec4(0.5,0.5,0.5,0.0).a > 0)	
1013: 		{
1014: 			Thickness = 1.0 + vec4(0.5,0.5,0.5,0.0).r;		
1015: 		}
1016: 		
1017: 		//Use the Baked texture to mix with the multiplication factors of the "Voxelized calculation method" based on depth of the scene
1018: 		if(u_MriViewType == 0) //gl buffer does not work well in perspective mode
1019: 		{
1020: 			//thickness based on position calculation mixed with obj radius
1021: 			vec3 P = State.Position*u_MriObjectRadius;
1022: 			float d = -dot(State.Position,P);
1023: 			float D = abs(d)/length(P);
1024: 			D /=u_MriObjectRadius;             
1025: 			
1026: 			Thickness *= mix( mix(2, 1, 1-NdotV)*u_MriObjectRadius, space_diagonal, (1-NdotV)*length(D));	
1027: 		}
1028: 		else
1029: 		{
1030: 			//thickness based on depth and obj radius
1031: 			float mult_factor = mix(2*u_MriObjectRadius, u_MriObjectRadius/2, gl_FragDepth);
1032: 			//thickness adjusment for the depth based on the Space diagonal of a cube created for each pixel on face.
1033: 			float mult_factor2 = mix( mix(space_diagonal, 1, (gl_FragDepth*(1-NdotV))), mix(u_MriObjectRadius, 1, (2*abs(gl_FragDepth - 0.5))*(1-NdotV)), 2*abs(gl_FragDepth - 0.5) )*PI; // this PI is just a adjusment to the color values between the two viewports
1034: 			
1035: 			Thickness *= mix(mult_factor, mult_factor2, gl_FragDepth);
1036: 		}	
1037: 		
1038: 				
1039: 		// Roughness attributes squared
1040: 		float difrough2 = difrough*difrough;		
1041: 		float spec1rough2 = spec1rough*spec1rough*spec1rough*spec1rough; // Arnold use a quadratic specrough for cook-torrance only(their wish was to use cubic, but that's expensive they say).	
1042: 		float spec2rough2 = spec2rough*spec2rough*spec2rough*spec2rough;
1043: 		float refrarough2 = refrarough*refrarough*refrarough*refrarough;
1044: 		
1045: 		float _glossiness = 1.0;
1046: 		float _Refra_glossiness = 1.0;
1047: 		float _ani1 = 2*(0.5-ani1); // internal variable to be used as anisotropy for the maths, this changes the anisotropy value to the range -1 and 1 that is used by V-ray and is correct for obtain the correct result from the BRDF Formula.
1048: 		float _ani2 = 2*(0.5-ani2);
1049: 		
1050: 		// IBL Glossiness adaptation to match the BRDF blur or 'spec lobe' for Environment Lighting
1051: 		_glossiness = mix(pow( 1-sqrt(spec1rough2), 2), pow( 1-(spec1rough), 3), 1-spec1rough);
1052: 		_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1053: 		
1054: 		if(_ani1 == 0.0 || spec1rough2 == 0.0) // There is no Anisotropy if the Specular Roughness = 0
1055: 		{
1056: 			_glossiness = pow( mix( 1-spec1rough2, 1-sqrt(spec1rough2), 1-spec1rough), mix(2, 3, 1-spec1rough) );
1057: 			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1058: 		}
1059: 		else
1060: 		{				  
1061: 			_glossiness = pow( mix( (abs(_ani1)/PI+1-sqrt(spec1rough2))/2, (abs(_ani1)+1-sqrt(spec1rough2))/2, 1-spec1rough), mix(1, (abs(_ani1)+1-sqrt(spec1rough2))*1.5, 1-spec1rough) );
1062: 			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1063: 		}
1064: 		
1065: 		// Fresnel var initialization	
1066: 		float F = 1.0;
1067: 		if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1068: 		{
1069: 			F = 0.0;
1070: 		}	
1071: 		
1072: 		// Anisotropic coords
1073: 		vec3 epsilon1 = vec3(0, 1, 0.15);
1074: 		vec3 X1 = vec3(1,0,0);
1075: 		vec3 Y1 = vec3(0,1,0);
1076: 		if(node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.a != 1.0)
1077: 		{
1078: 			X1.x = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.r;
1079: 			Y1.y = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.g;
1080: 		}
1081: 		if(ani1 != 0.5)
1082: 		{		
1083: 			epsilon1 = rot1 < 0.5 ? mix(Y1, X1, 2*rot1) : mix(X1, -Y1, 2*(rot1-0.5) );		
1084: 		}
1085: 				
1086: 		Y1 = normalize(cross(N, epsilon1));
1087: 		X1 = normalize(cross(N, Y1));
1088: 		
1089: 		vec3 epsilon2 = vec3(0, 1, 0.15);
1090: 		vec3 X2 = vec3(1,0,0);
1091: 		vec3 Y2 = vec3(0,1,0);
1092: 		if(node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.a != 1.0)
1093: 		{
1094: 			X2.x = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.r;
1095: 			Y2.y = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.g;
1096: 		}
1097: 		if(ani2 != 0.5)
1098: 		{		
1099: 			epsilon2 = rot2 < 0.5 ? mix(Y2, X2, 2*rot2) : mix(X2, -Y2, 2*(rot2-0.5) );		
1100: 		}
1101: 				
1102: 		Y2 = normalize(cross(N, epsilon2));
1103: 		X2 = normalize(cross(N, Y2));
1104: 
1105: 		// Energy variables initialization for each phase of the light calculation
1106: 		vec3 EnergyDiffuse = vec3(0.0);
1107: 		vec3 EnergyDiffuse_env = vec3(0.0); //avoid diffuse light bounces from lights to the obj
1108: 		vec3 EnergyBacklight = vec3(0.0);
1109: 		vec3 EnergyBacklight_env = vec3(0.0);
1110: 		vec3 EnergySpecular1 = vec3(0.0); //also separete the energy from highlights and reflection(point lights and environment light) also avoids lights bouncees from shader to the direct light sourcers the point lights.
1111: 		vec3 EnergySpecular_env1 = vec3(0.0);
1112: 		vec3 EnergyReflection_env1 = vec3(0.0);
1113: 		vec3 EnergySpecular2 = vec3(0.0); 
1114: 		vec3 EnergySpecular_env2 = vec3(0.0); 
1115: 		vec3 EnergyReflection_env2 = vec3(0.0);
1116: 		vec3 EnergyRefraction_env = vec3(0.0);
1117: 		vec3 EnergyTransmittance = vec3(1.0);
1118: 		vec3 EnergySSS = vec3(0.0);
1119: 		vec3 EnergySSS_env = vec3(0.0); //avoid SSS light bounces from lights to the obj
1120: 		vec3 EnergyOpacity_env = vec3(0.0);
1121: 		
1122: 		vec3 LightColour = vec3(0.0);
1123: 		float diffterm = 0.0;
1124: 		float specterm = 0.0;
1125: 		float specterm2 = 0.0;
1126: 		float refraterm = 0.0;
1127: 		vec3 _Absorbance = vec3 (1.0);
1128: 		
1129: 		
1130: 		
1131: 		for(int i=0;i<4;i++)
1132: 		{
1133: 			if( vec3( 0) == u_MriLightSources[i].DiffuseColor.rgb && vec3( 0) == u_MriLightSources[i].SpecularColor.rgb)
1134: 			{
1135: 				continue;
1136: 			}
1137: 
1138: 			float lightVisibility = mriLightVisibility( i, State.Position);		
1139: 			
1140: 			// Light Direction			
1141: 			vec3 L = normalize(u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera);
1142: 			vec3 LdistP = u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera;	
1143: 			
1144: 			// Half Vector
1145: 			vec3 H = normalize(L+V);		
1146: 			
1147: 			float LdotN = dot(L,N);		
1148: 			{			
1149: 				// ----------DIFFUSE TERM-----------
1150: 				// Oren-Nayar Diffuse Result from the Light Sources
1151: 				diffterm = 1.25*mriBRDF_Oren_Nayar(N, V, L, difrough2);
1152: 				EnergyDiffuse  += (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * (diffterm) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);
1153: 				
1154: 				// Check-box Calculate Fresnel to Diffuse
1155: 				//if($DiffuseFresnel == true)
1156: 				// Calculate fresnel attenuation for the Diffuse, using the specReflectance at normal or the $IOR attributes.		
1157: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1158: 				{
1159: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);
1160: 					// *FIX Light Occlusion/Shadow Issue*
1161: 					float F0 = (1 - TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)/(1 + TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1162: 					F0 = F0*F0;
1163: 					F = mix(F*(1-NdotV), F, F0);
1164: 					// Energy Conservation from Specular (Lights Sources)	
1165: 					EnergyDiffuse *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;						
1166: 				}
1167: 				
1168: 				// ----------Sub-Surface Scattering TERM-----------            
1169: 				float LdotN = dot(L,N);
1170: 				float LdotH = dot(L,H);
1171: 				
1172: 				float FL = mriBRDF_SchlickFresnel(LdotN);
1173: 				float FV = mriBRDF_SchlickFresnel(NdotV);			
1174: 							
1175: 				LightColour = (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);
1176: 					
1177: 				// creates a bit of a fake impression of difusion
1178: 				vec3 mixSSSdifusion = vec3(0.0);
1179: 				for (int j=0;j<3;j++)
1180: 				{			
1181: 					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), 1-sssRadius.rgb[j] );
1182: 				}
1183: 				vec3 Back_Scat_Color = 1.25*mixSSSdifusion*mixSSSdifusion;
1184: 				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
1185: 				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
1186: 				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;
1187: 				
1188: 				EnergySSS += Back_Scat_Color;
1189: 							
1190: 				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1191: 				//if($DiffuseFresnel == true)
1192: 				// The same fresnel attenuation that affects the diffuse above.
1193: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1194: 				{
1195: 					// Energy Conservation from Specular (Lights Sources)
1196: 					EnergySSS *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;														
1197: 				}
1198: 				
1199: 				// ----------BACKLIGHT TERM-----------
1200: 				if( LdotN <= 0.0)
1201: 				{
1202: 					if(BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_ > 0.0)
1203: 					{					
1204: 						diffterm = mriBRDF_Oren_Nayar(N, V, -L, difrough2);
1205: 						EnergyBacklight += ( u_MriLightSources[i].DiffuseColor.rgb) * diffterm * BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * BacklightColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb *att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_)/PI;
1206: 						
1207: 						// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1208: 						//if($DiffuseFresnel == true)
1209: 						if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1210: 						{
1211: 							F = mriBRDF_Fresnel(-L, -H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1212: 							// *FIX Light Occlusion/Shadow Issue*
1213: 							float F0 = (1 - TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)/(1 + TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1214: 							F0 = F0*F0;
1215: 							F = mix(F*(1-NdotV), F, F0);						
1216: 							// Energy Conservation from Specular (Lights Sources)
1217: 							// ----------BACKLIGHT TERM-----------
1218: 							EnergyBacklight *= 1.0 - min(PI * F * max(0.0, dot(-L,N)) * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_, 1.0);						
1219: 						}
1220: 					}
1221: 					else
1222: 					{
1223: 						continue;
1224: 					}	
1225: 				}			
1226: 				
1227: 				// ----------SPECULAR1 TERM-----------
1228: 				// Moved to here so would Avoid shadow issues in the Diffuse and SSS Calculation and will prevent future issues in the Specular Calculation.
1229: 				if( LdotN > 0.0)
1230: 				{				
1231: 					// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR
1232: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1233: 					{
1234: 						F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1235: 					}	
1236: 					else
1237: 					{
1238: 						F = 1.0;
1239: 					}					
1240: 					//BRDF Model Cook-Torrance
1241: 					// Cook-Torrance Specular Result
1242: 					specterm = mriBRDF_Beckman(N, H, max(spec1rough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(spec1rough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
1243: 					
1244: 					
1245: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1246: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1247: 					if(abs(_ani1) != 0.0) 
1248: 					{							
1249: 						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
1250: 						if(spec1rough2 == 0.0)
1251: 						{
1252: 							specterm = mriBRDF_Ward(N, V, L, H, X1, Y1, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
1253: 						}
1254: 						else
1255: 						{						
1256: 							// Isotropy specular assumes that ani = 0
1257: 							specterm = mriBRDF_Ward(N, V, L, H, X1, Y1, _ani1, 0.99-spec1rough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
1258: 						}					
1259: 					}						
1260: 					EnergySpecular1 += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);			
1261: 				}
1262: 				
1263: 				// ----------SPECULAR2 TERM-----------
1264: 				if( LdotN > 0.0)
1265: 				{				
1266: 					if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1267: 					{
1268: 						F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1269: 					}	
1270: 					else
1271: 					{
1272: 						F = 1.0;
1273: 					}					
1274: 										
1275: 					//BRDF Model Cook-Torrance
1276: 					// Cook-Torrance Specular Result
1277: 					specterm2 = mriBRDF_Beckman(N, H, max(spec2rough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(spec2rough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
1278: 					
1279: 					
1280: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1281: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1282: 					if(abs(_ani2) != 0.0) 
1283: 					{							
1284: 						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
1285: 						if(spec2rough2 == 0.0)
1286: 						{
1287: 							specterm2 = mriBRDF_Ward(N, V, L, H, X2, Y2, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
1288: 						}
1289: 						else
1290: 						{						
1291: 							// Isotropy specular assumes that ani = 0
1292: 							specterm2 = mriBRDF_Ward(N, V, L, H, X2, Y2, _ani2, 0.99-spec2rough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
1293: 						}					
1294: 					}						
1295: 					EnergySpecular2 += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm2) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);			
1296: 				}
1297: 
1298: 			}		
1299: 		}
1300: 		
1301: 		
1302: 		if( mriEnvironmentLightOn() == true)
1303: 		{
1304: 			{
1305: 				// ----------DIFFUSE TERM-----------
1306: 				// Env Light, Light Direction
1307: 				vec3 L = N;
1308: 				LightColour = mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 0.0);
1309: 				// This mix(PI, 2.5, difrough2) would preserve albedo.	
1310: 				EnergyDiffuse_env = mix(PI, 2.5, difrough2)*mriBRDF_Oren_Nayar(N, V, L, difrough2) * LightColour;            		
1311: 				
1312: 				// Check-box Calculate Fresnel to Diffuse 
1313: 				//if($DiffuseFresnel == true)
1314: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1315: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1316: 				{
1317: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1318: 					L = normalize( -reflect( V, N));
1319: 					// Half Vector
1320: 					vec3 H = normalize(L+V);					
1321: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1322: 					// Energy Conservation from Specular (Environment)					
1323: 					EnergyDiffuse_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1324: 					
1325: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1326: 					{
1327: 						F = 0.0; 
1328: 					}
1329: 					// Energy Conservation from Reflection (Environment)	
1330: 					EnergyDiffuse_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1331: 				}
1332: 			}
1333: 			
1334: 			{
1335: 				// ----------BACKLIGHT TERM-----------
1336: 				// Env Light, Light Direction
1337: 				// Backlight	
1338: 				vec3 L = normalize( -refract(V, -N*State.FragmentPositionInEyeSpaceFromViewCamera, 1.0) );				
1339: 				
1340: 				float lightVisibility = 1.0;			
1341: 				
1342: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);	
1343: 				
1344: 				EnergyBacklight_env += mix(vec3(0), LightColour, BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_)*mriBRDF_Oren_Nayar(N, V, N, difrough2);
1345: 				EnergyBacklight_env /= 1+difrough2/PI;
1346: 				
1347: 				//if($DiffuseFresnel == true)
1348: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1349: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1350: 				{
1351: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1352: 					L = normalize( -reflect( V, N));
1353: 					// Half Vector
1354: 					vec3 H = normalize(L+V);					
1355: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1356: 					// Energy Conservation from Specular (Environment)					
1357: 					EnergyBacklight_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1358: 						
1359: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1360: 					{
1361: 						F = 0.0; 
1362: 					}
1363: 					// Energy Conservation from Reflection (Environment)	
1364: 					EnergyBacklight_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1365: 				}
1366: 			}	
1367: 
1368: 			{
1369: 				// ----------SPECULAR TERM1-----------
1370: 				// Env Specular Reflection, Light Direction			
1371: 				vec3 L = normalize( -reflect( V, N));
1372: 				// Half Vector
1373: 				vec3 H = normalize(L+V);          			
1374: 				
1375: 				// How to calculate fresnel to specular equation, using specReflectance at normal or Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_
1376: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1377: 				{
1378: 					F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1379: 				}
1380: 				else
1381: 				{
1382: 					F = 1.0;
1383: 				}
1384: 				float LdotN = dot(L,N);
1385: 				if( 0.0 < LdotN)
1386: 				{
1387: 					float lightVisibility = 1.0;
1388: 					LightColour = vec3(0.0);				
1389: 
1390: 					//BRDF Model Cook-Torrance
1391: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
1392: 					// Cook-Torrance Specular Result from Environment
1393: 					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-spec1rough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
1394: 					
1395: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1396: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1397: 					if(abs(_ani1) != 0) 
1398: 					{									
1399: 						// Isotropy reflection
1400: 						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
1401: 							
1402: 						// Anisotropy reflection	
1403: 						if(_ani1 != 0.0 && spec1rough2 != 0)
1404: 						{
1405: 							// Caculate how much isotropy is the material based on roughness and anisotropy values.
1406: 							float _isotropy = abs(_ani1)*(1.1-spec1rough2);	
1407: 							
1408: 							LightColour = vec3(0.0);
1409: 							float i = 0;
1410: 							for (;i < _isotropy;)
1411: 							{
1412: 							
1413: 							// Define the direction of the anisotropy
1414: 							vec3 L1 = normalize( reflect( V, _ani1 < 0? X1:Y1 ));
1415: 								
1416: 							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
1417: 							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L1, L, 1-i), clamp(_glossiness + abs(_ani1*_ani1)*(1.0-spec1rough2)/9, .1, .9) );							
1418: 							i += 0.1;
1419: 							}
1420: 							LightColour /= i*10;												
1421: 						}		
1422: 						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-spec1rough), 0.0, 1.0 );					
1423: 					}
1424: 					EnergySpecular_env1 += specterm * (LightColour);		
1425: 				
1426: 			
1427: 					// ----------REFLECTION TERM-----------
1428: 					// Reset the fresnel value, and keep the L direction from the specular above.
1429: 					
1430: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1431: 					{
1432: 						F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1433: 					}
1434: 					else
1435: 					{
1436: 						F = 1.0;
1437: 					}
1438: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
1439: 					EnergyReflection_env1 += F * (LightColour);
1440: 				}	
1441: 			}		
1442: 
1443: 			{
1444: 				// ----------SPECULAR TERM2-----------
1445: 				// Env Specular Reflection, Light Direction			
1446: 				vec3 L = normalize( -reflect( V, N));
1447: 				// Half Vector
1448: 				vec3 H = normalize(L+V);          			
1449: 				
1450: 				// How to calculate fresnel to specular equation, using specReflectance at normal or Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_
1451: 				if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1452: 				{
1453: 					F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1454: 				}
1455: 				else
1456: 				{
1457: 					F = 1.0;
1458: 				}
1459: 				float LdotN = dot(L,N);
1460: 				if( 0.0 < LdotN)
1461: 				{
1462: 					float lightVisibility = 1.0;
1463: 					LightColour = vec3(0.0);				
1464: 
1465: 					//BRDF Model Cook-Torrance
1466: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
1467: 					// Cook-Torrance Specular Result from Environment
1468: 					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-spec2rough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
1469: 					
1470: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1471: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1472: 					if(abs(_ani2) != 0) 
1473: 					{									
1474: 						// Isotropy reflection
1475: 						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
1476: 							
1477: 						// Anisotropy reflection	
1478: 						if(_ani2 != 0.0 && spec2rough2 != 0)
1479: 						{
1480: 							// Caculate how much isotropy is the material based on roughness and anisotropy values.
1481: 							float _isotropy = abs(_ani2)*(1.1-spec2rough2);	
1482: 							
1483: 							LightColour = vec3(0.0);
1484: 							float i = 0;
1485: 							for (;i < _isotropy;)
1486: 							{
1487: 							
1488: 							// Define the direction of the anisotropy
1489: 							vec3 L2 = normalize( reflect( V, _ani2 < 0? X2:Y2 ));
1490: 								
1491: 							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
1492: 							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L2, L, 1-i), clamp(_glossiness + abs(_ani2*_ani2)*(1.0-spec2rough2)/9, .1, .9) );							
1493: 							i += 0.1;
1494: 							}
1495: 							LightColour /= i*10;												
1496: 						}		
1497: 						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-spec2rough), 0.0, 1.0 );					
1498: 					}
1499: 					EnergySpecular_env2 += specterm * (LightColour);		
1500: 				
1501: 			
1502: 					// ----------REFLECTION TERM-----------
1503: 					// Reset the fresnel value, and keep the L direction from the specular above.
1504: 					
1505: 					if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1506: 					{
1507: 						F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1508: 					}
1509: 					else
1510: 					{
1511: 						F = 1.0;
1512: 					}
1513: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
1514: 					EnergyReflection_env2 += F * (LightColour);
1515: 				}	
1516: 			}		
1517: 
1518: 			
1519: 			{
1520: 				// ----------REFRACTION TERM-----------
1521: 				// Env Refraction, Light Direction			
1522: 				// Refraction incoming direction
1523: 				vec3 Li = vec3(0.0);
1524: 				if(Solid_node_83662364_52db_4f7b_b336_baca232fc310_)
1525: 				{
1526: 					Li = normalize( -refract(V, -N, (1.0/TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)) );
1527: 				}
1528: 				else
1529: 				{
1530: 					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
1531: 					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, (1.0/TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)) );
1532: 				}
1533: 				
1534: 				float lightVisibility = 1.0;
1535: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, _Refra_glossiness);		
1536: 				
1537: 				EnergyRefraction_env += (LightColour);		
1538: 							
1539: 				_Absorbance = transCol.rgb;
1540: 				if (_Absorbance != vec3(1.0) )
1541: 				{			
1542: 					_Absorbance = pow_RGB(transCol.rgb, Thickness/10);
1543: 					EnergyTransmittance = _Absorbance;
1544: 				}
1545: 				
1546: 				// *TWEAK* This will preserve some energy from the reflection that is actually passing through the surface and not been reflected by the fresnel.
1547: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1548: 				{
1549: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1550: 					vec3 L = normalize( -reflect( V, N));
1551: 					float LdotN = dot(L,N);
1552: 					// Half Vector
1553: 					vec3 H = normalize(L+V);					
1554: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);					
1555: 					EnergyRefraction_env *=  1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;			
1556: 					
1557: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1558: 					{
1559: 						F = 0.0; 
1560: 					}
1561: 					EnergyRefraction_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;				
1562: 				}		
1563: 			}	
1564: 
1565: 			{
1566: 				// ----------Sub-Surface Scattering TERM-----------
1567: 				// Env Light, Light Direction
1568: 				// Sub-Surface Scattering	
1569: 				vec3 L = N;				
1570: 				// Half Vector
1571: 				vec3 H = normalize(L+V);			
1572: 				
1573: 				float LdotN = dot(L,N);
1574: 				float LdotH = dot(L,H);
1575: 				
1576: 				float FL = mriBRDF_SchlickFresnel(LdotN);
1577: 				float FV = mriBRDF_SchlickFresnel(NdotV);			
1578: 					
1579: 				float lightVisibility = 1.0;
1580: 				
1581: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);
1582: 				
1583: 				// creates a bit of a fake impression of difusion
1584: 				vec3 mixSSSdifusion = vec3(0.0);
1585: 				for (int j=0;j<3;j++)
1586: 				{			
1587: 					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), sssRadius.rgb[j] );
1588: 				}
1589: 				vec3 Back_Scat_Color = 1.25*mixSSSdifusion;
1590: 				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
1591: 				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
1592: 				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;						
1593: 				
1594: 				EnergySSS_env += Back_Scat_Color;
1595: 				
1596: 				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1597: 				//if($DiffuseFresnel == true)
1598: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1599: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1600: 				{
1601: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1602: 					L = normalize( -reflect( V, N));
1603: 					// Half Vector
1604: 					vec3 H = normalize(L+V);					
1605: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1606: 					EnergySSS_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1607: 					
1608: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1609: 					{
1610: 						F = 0.0; // picks from the math above, since this would be a value that comes from a global attribute for the entire fresnels math.
1611: 					}
1612: 					EnergySSS_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1613: 				}
1614: 			}
1615: 			
1616: 			{
1617: 				// ----------OPACITY TERM-----------
1618: 				// Env Opacity, Light Direction			
1619: 				// Opacity incoming direction
1620: 				// It should look like a Ghost with inverted colors!
1621: 				vec3 Li = vec3(0.0);
1622: 				if(Solid_node_83662364_52db_4f7b_b336_baca232fc310_)
1623: 				{
1624: 					Li = normalize( -refract(V, -N, 1.0) );
1625: 				}
1626: 				else
1627: 				{
1628: 					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
1629: 					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, 1.0) );
1630: 				}
1631: 				float lightVisibility = 1.0;
1632: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, 1.0);		
1633: 				EnergyOpacity_env += LightColour;				
1634: 			}
1635: 		}	
1636: 		
1637: 		// AO option
1638: 		float _AO = 1.0 - AmbientOcclusion_node_83662364_52db_4f7b_b336_baca232fc310_ * State.AmbientOcclusion;
1639: 		
1640: 		// Keep in mind that Arnold does not restrict the artists with a builtin Energy Conservation! So you have some artists freedom to break the rules as you wish.
1641: 		vec3 Kd = (EnergyDiffuse+EnergyBacklight + EnergyDiffuse_env+EnergyBacklight_env) * difCol.rgb * DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * _AO;
1642: 		vec3 Ks1 = (EnergySpecular1 + EnergySpecular_env1) * specCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor1* _AO;	
1643: 		vec3 Ks2 = (EnergySpecular2 + EnergySpecular_env2) * specCol2.rgb * Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor2* _AO;	
1644: 		//vec3 Kr1 = EnergyReflection_env1 * reflCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor1 * _AO;
1645: 		//vec3 Kr2 = EnergyReflection_env2 * reflCol2.rgb * Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor2 * _AO;
1646: 		vec3 Kt = EnergyRefraction_env * EnergyTransmittance * refrCol.rgb * TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * _AO;
1647: 		vec3 Ksss = (EnergySSS + EnergySSS_env) * SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_ * sssCol.rgb * _AO;	
1648: 		vec3 Opa = EnergyOpacity_env * opacityCol.rgb;
1649: 		
1650: 		// New Mari Lighting Mode workflow.
1651: 		// Lighting Mode => 0 - "Flat" - only display the Current Channel that is selected.
1652: 		// Lighting Mode =>	1 - Basic - Display Diffuse + Sub-surface Scattering
1653: 		// Lighting Mode => 2 - Full - Adds the specular/reflection + refraction + self-illumination on top of what the Basic mode displays
1654: 		Output.rgb = u_MriLightingMode==0 ? Current_Channel_Selected.rgb : Kd+Ksss;
1655: 		Output.rgb += u_MriLightingMode!=2 ? vec3(0.0) : Ks1+Ks2+Kt;
1656: 			
1657: 		// Emission
1658: 		Output.rgb += u_MriLightingMode==2 ? EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * emisCol.rgb : vec3(0.0);
1659: 
1660: 		// Opacity
1661: 		Output.rgb = u_MriLightingMode==2 ? mix(Opa.rgb, Output.rgb, 1.0-color_toValue(opacityCol.rgb)) : Output.rgb;
1662: 				
1663: 		// If displaying "flat" lighting mode 0 use the Current Channel alpha.
1664: 		Output.a = u_MriLightingMode==0 ? node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output.a : 1.0;		
1665: 		
1666: 		
1667: 		// Render Passes Mode, the beauty pass = 0 doesn't need an if statement, it has coded above and displayed by default
1668: 		// Lighting Mode == 1 ? #Channel * $Weight : #Channel * $ChannelWeight * Lighting Contribution
1669: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 1)
1670: 		{
1671: 			Output.rgb = (u_MriLightingMode==1 ? difCol.rgb * DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kd);
1672: 		}
1673: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 2)
1674: 		{
1675: 			Output.rgb = (u_MriLightingMode==1 ? specCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ : Ks1+Ks2);
1676: 		}
1677: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 3)
1678: 		{
1679: 			Output.rgb = (u_MriLightingMode==1 ? reflCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kr1+Kr2);
1680: 		}
1681: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 4)
1682: 		{
1683: 			Output.rgb = (u_MriLightingMode==1 ? refrCol.rgb * TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kt);
1684: 		}
1685: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 5)
1686: 		{
1687: 			Output.rgb = (u_MriLightingMode==1 ? sssCol.rgb * SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_ : Ksss);
1688: 		}
1689: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 6)
1690: 		{
1691: 			Output.rgb = emisCol.rgb * EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
1692: 		}
1693: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7)
1694: 		{
1695: 			Output.rgb = vec3(1.0/Thickness);			
1696: 		}	
1697: 	}
1698: 		
1699: 	            
1700:     node_83662364_52db_4f7b_b336_baca232fc310_Output = Output;
1701: }
1702: 
1703: //=====================
1704: //--- Style 2 Node 'Viewer' ---
1705: //=====================
1706: 
1707: 
1708: uniform bool projection_through_enabled;
1709: uniform float projectionDepthTexture_Offset;
1710: uniform sampler2D projectionDepthTexture;
1711: uniform bool ao_enabled;
1712: uniform float ao_value;
1713: uniform float ao_contrast;
1714: uniform float ao_invert;
1715: uniform int ao_curve;
1716: uniform float depth_start;
1717: uniform float depth_end;
1718: uniform float depth_falloff;
1719: uniform float depth_range;
1720: uniform sampler2D marqueeSelMask;
1721: uniform float marqueeSelMaskAmount;
1722: uniform mat3x2 marqueeSelMaskMatrix;
1723: float MarqueeSelMaskFunc( vec2 uv)
1724: {
1725:     return ( 1.0 - marqueeSelMaskAmount*(1.0-texture( marqueeSelMask, ( (marqueeSelMaskMatrix * vec3( uv, 1.0)) * vec2( 0.5, -0.5)) + vec2( 0.5, 0.5)).a));
1726: }
1727: uniform bool fn_enabled;
1728: uniform float fn_maskAmount;
1729: uniform float fn_size;
1730: uniform float fn_seed;
1731: uniform float fn_roughness;
1732: uniform float fn_contrast;
1733: uniform float fn_invert;
1734: uniform int fractal_curve;
1735: 
1736: 
1737: void apply_projection_masks(inout MriFragmentState State, inout MriSystemFragmentState _State)
1738: {
1739:     float projection_exposure_multipler = projection_through_enabled ? float(_State.ProjectionCoord.z <= 1.0) : float((_State.ProjectionCoord.z-projectionDepthTexture_Offset) <= texture(projectionDepthTexture,_State.ProjectionCoord.st).r);
1740: _State.NonPreviewableProjectionExposure *= projection_exposure_multipler;
1741: float Midpoint = (depth_end+depth_start)/2.0;float Distance = (abs(Midpoint+State.FragmentPositionInEyeSpaceFromProjectionCamera.z)-abs(Midpoint-depth_start))/(Midpoint-depth_start);_State.ProjectionExposure *= clamp(Distance/depth_falloff+1.0, 0.0, 1.0);_State.NonPreviewableProjectionExposure *= MarqueeSelMaskFunc( State.FragmentPositionInNdcSpaceFromProjectionCamera.st);
1742: 
1743: }
1744: 
1745: void evaluate_shader_network(inout MriFragmentState State, inout MriSystemFragmentState _State)
1746: {
1747:         {
1748:         node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(State,_State); // Evaluating Node 'Bottom Transparency'
1749:         node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(State,_State); // Evaluating Node 'Paint 3'
1750:         node_516e4503_ea09_4104_8e31_2e667c820272_func(State,_State); // Evaluating Node 'Merge_Bump_Head'
1751:         node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(State,_State); // Evaluating Node 'Paint 4'
1752:         node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(State,_State); // Evaluating Node 'Layer'
1753:         node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(State,_State); // Evaluating Node 'Bump_Head'
1754:         node_45b7815b_0361_452e_b5c5_f476cf68940f_func(State,_State); // Evaluating Node 'Current Channel'
1755:         node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(State,_State); // Evaluating Node 'alSurfaceX/Height As Normal'
1756:         node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(State,_State); // Evaluating Node 'alSurfaceX/Normal Modulation'
1757:         node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(State,_State); // Evaluating Node 'alSurfaceX/Tangent Space To Eye Space'
1758:         node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(State,_State); // Evaluating Node 'alSurfaceX/Color To Vector'
1759:         node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(State,_State); // Evaluating Node 'alSurfaceX/Tangent Space To Eye Space 2'
1760:         node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(State,_State); // Evaluating Node 'alSurfaceX/Set Unlit'
1761:         node_83662364_52db_4f7b_b336_baca232fc310_func(State,_State); // Evaluating Node 'alSurfaceX/'
1762:         {
1763: 
1764:     _State.Diffuse = node_83662364_52db_4f7b_b336_baca232fc310_Output;
1765:                 
1766:         }
1767:     }
1768: 
1769: }
1770: 
1771: 
0(1679) : error C1008: undefined variable "Kr1"
0(1679) : error C1008: undefined variable "Kr2"

---CompilerLog---
0(1679) : error C1008: undefined variable "Kr1"
0(1679) : error C1008: undefined variable "Kr2"


Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 74 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Default' reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Default' reloadMacros() took 50 ms 49 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 74
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 74 uu
Debug : [   mrisnglslcontextmanager.cpp:748 ] : Reloading Shader 'Shader Network1'
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 18 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:711 ] : [ !! ] Shader 'Shader Network1' Compilation Failure. Not linking.
---SourceCode---
Shader Type: Fragment
1: #version 150
2: #define MRI_SHADER_FRAGMENT 1
3: #define MRI_NUM_PATCH_ATTRIBUTES 4096
4: #define MRI_SVT_GATHER_USE_QUINT 1
5: #define MRI_USE_CUBE_MAP_ARRAY 1
6: #define USE_DEFERRED_TEXTURE_2D_ARRAY 1
7: 
8: //! Description |  Shader Network evaluation fragment shader
9: //! Name |  Func_ShaderNetwork.frag
10: //! Author |  Jack Greasley, Kiyoyuki Nakagaki, Duncan Hopkins
11: //! Copyright |  Copyright (c) 2013 The Foundry 
12: 
13: #define MRI_LIGHT_ARRAY_SIZE 4
14: 
15: struct MriSystemFragmentState
16: {
17:     vec4 Diffuse;
18:     vec4 Unlit;
19:     vec4 VectorData;
20: 
21:     vec2 dUV;
22: 
23:     vec3 ProjectionCoord;
24:     vec2 TangentInProjectionSpace;
25:     vec2 BitangentInProjectionSpace;
26: 
27:     bool Hidden;
28:     bool Locked;
29:     bool Selected;
30: 
31:     float ProjectionExposure;
32:     float NonPreviewableProjectionExposure;
33: 
34:     bool PatchSelected;
35:     bool FaceSelected;
36:     bool ObjectSelected;
37: 
38:     float TriangleId;
39:     float TileId; 
40:     float MipLevel;
41: 
42:     bool GeoExists;
43: };
44: 
45: struct MriFragmentState
46: {
47:     float AmbientOcclusion;
48: 
49:     vec3 Position;
50:     vec2 UV;
51:     vec3 Normal;
52:     vec3 Tangent;
53:     vec3 Bitangent;
54: 
55:     vec3 NormalInEyeSpaceFromViewCamera;
56:     vec3 TangentInEyeSpaceFromViewCamera;
57:     vec3 BitangentInEyeSpaceFromViewCamera;
58:     vec3 ViewVectorInEyeSpaceFromViewCamera;
59:     vec3 FragmentPositionInEyeSpaceFromViewCamera;
60: 
61:     vec3 NormalInEyeSpaceFromProjectionCamera;
62:     vec3 TangentInEyeSpaceFromProjectionCamera;
63:     vec3 BitangentInEyeSpaceFromProjectionCamera;
64:     vec3 ViewVectorInEyeSpaceFromProjectionCamera;
65: 
66:     vec3 FragmentPositionInEyeSpaceFromProjectionCamera;
67:     vec3 FragmentPositionInNdcSpaceFromProjectionCamera;
68: 
69:     float PatchId;
70:     int   FaceId;
71:     int   FaceIndex;
72: };
73: 
74: struct Channel
75: {
76:     // r - int index; 
77:     // g - bool active;
78:     // b - bool invert;
79:     ivec3 ChannelValues;
80:     // a - reserved
81: };
82: 
83: #if defined( USE_DEPTH_PROJECTIONS)
84: struct MriLight
85: {
86:     int depthProjectorIndex;
87:     int depthProjectorCount;
88: };
89: 
90: struct MriDepthProjection
91: {
92:     mat4 transform;
93: };
94: #endif
95: 
96: 
97: //Gives the true texture coordinates for the base texture
98: vec2 svt_coords(vec2 coords);
99: 
100: //This function gives the raw color value from the texture in Base channel without any filters or projection applied 
101: vec4 svt_texture(Channel Base, vec2 coords);
102: vec4 svt_texture(Channel Base, in MriFragmentState State, in MriSystemFragmentState _State);
103: 
104: //Collect height values from bump map
105: vec4 get_heights(Channel Base, vec2 coords);
106: 
107: //This function gives the color value from the texture in Base channel with some filters and projection applied if applicable
108: vec4 texture_lookup(Channel Base, vec2 coords);
109: 
110: //texture look up function for version 2.0
111: vec4 texture_lookup2(Channel Base, in MriFragmentState State, in MriSystemFragmentState _State);
112: 
113: float tex_mip_level(vec2 coord);
114: 
115: //Default shadow casting function
116: float mriLightVisibility( in int LightIndex, vec3 FragmentPosition);
117: 
118: //Functions for evaluating values with a bit of UV offset.
119: float dFdu(float F);
120: float dFdv(float F);
121: vec2 dFdu(vec2 F);
122: vec2 dFdv(vec2 F);
123: mat2 dFd(vec2 F);
124: vec3 dFdu(vec3 F);
125: vec3 dFdv(vec3 F);
126: mat2x3 dFd(vec3 F);
127: 
128: float F(float f0, vec2 dUV);
129: vec2 F(vec2 f0, vec2 dUV);
130: vec3 F(vec3 f0, vec2 dUV);
131: 
132: void apply_projection_masks(inout MriFragmentState State, inout MriSystemFragmentState _State);
133: 
134: void evaluate_shader_network(inout MriFragmentState State, inout MriSystemFragmentState _State);
135: 
136: 
137: #define MRI_LIGHT_ARRAY_SIZE 4
138: 
139: // DO NOT CHANGE this structure with out adjusting the uniform upload C++ code.
140: struct MriLightSource
141: {
142:     vec4 Position;
143: 
144:     vec4 AmbientColor;
145:     vec4 DiffuseColor;
146:     vec4 SpecularColor;
147: 
148:     float SpotCutoff;
149:     float SpotExponent;
150: 
151:     float ConstantAttenuation;
152:     float LinearAttenuation;
153:     float QuadraticAttenuation;
154: };
155: 
156: // Returns the lighting value to use from the external environment map
157: //  shapness - how clear or blurred the light source is
158: //   0.0 - Totally blurred light sources. same as using dot( normal, light) calculation
159: //   1.0 - Totally sharp
160: vec3 mriEnvironmentLight( in vec3 normal, in float sharpness);
161: bool mriEnvironmentLightOn();
162: 
163: 
164: float mriBRDF_sqr(float x);
165: 
166: float mriBRDF_SchlickFresnel(float u);
167: float mriBRDF_GTR1(float NdotH, float a);
168: float mriBRDF_GTR2(float NdotH, float a);
169: float mriBRDF_GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay);
170: float mriBRDF_smithG_GGX(float Ndotv, float alphaG);
171: vec3 mriBRDF_mon2lin(vec3 x);
172: 
173: 
174: ////////////////////////////////////////////////////////////////////////////////
175: // Custom BRDF Function Library Extension Registration
176: // Copyright (c) 2014 Antonio Lisboa M. Neto. All Rights Reserved.
177: //////////////////////////////////////////////////////////////////////////////// 
178: // File: BRDF_FunctionLib_ext.glslc	
179: // Description: Function Library Extension for be used in the new Custom BRDF Shaders
180: ////////////////////////////////////////////////////////////////////////////////               	
181: // Author: Antonio Neto       	
182: // Web: www.netocg.blogspot.com			
183: // Email: netocg.fx@gmail.com
184: ////////////////////////////////////////////////////////////////////////////////			                                   	
185: // Date: Jan 25, 2014	         		
186: ////////////////////////////////////////////////////////////////////////////////
187: 
188: float att(vec3 L, int Light_Falloff, float Decay_Rate);
189: float color_toValue(vec3 Color);
190: vec3 pow_RGB(vec3 Color, float Value);
191: vec3 convert_Colorspace(vec3 color, int Colorspace_Profile);
192: float mriBRDF_Fresnel(vec3 L, vec3 H, float eta);
193: float mriBRDF_Fresnel_Schlicks(vec3 L, vec3 H, float Reflectance);
194: float mriBRDF_Fresnel_Dielectric(vec3 L, vec3 H, float ior);
195: float mriBRDF_Fresnel_Conductor(vec3 L, vec3 H, float eta, float k);
196: float nfresnel(float cos_theta_r, float eta);
197: float mriBRDF_Oren_Nayar(vec3 N, vec3 V, vec3 L, float difrough2);
198: float mriBRDF_Beckman(vec3 N, vec3 H, float specrough2);
199: float mriBRDF_Geo_att_Cook_Torrance(vec3 N, vec3 H, vec3 V, vec3 L);
200: float mriBRDF_Ward(vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specrough2);
201: float mriBRDF_Geo_att_Ward_Duer( vec3 L, vec3 V, vec3 N, vec3 H);
202: float mriBRDF_Ashikhmin_Shirley( vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specrough2);
203: float mriBRDF_Geo_Att_Ash_Sh00( vec3 N, vec3 V, vec3 L);
204: float mriBRDF_Blinn(vec3 N, vec3 H, float specrough2);
205: float mriBRDF_Geo_att_Schlick_Smith(vec3 N, vec3 L, vec3 V, float specrough2);
206: float mriBRDF_Phong(vec3 N, vec3 V, vec3 H, float specrough2);
207: float mriBRDF_Geo_att_Beckmann(vec3 N, vec3 V, float specrough2);
208: float mriBRDF_GTR(vec3 N, vec3 V, vec3 L, vec3 H, vec3 X, vec3 Y, float ani, float specGloss, float ggxTailFalloff);
209: float mriBRDF_Geo_att_smithG_GGX(float NdotV, float specGloss);
210: 
211: /****************************************************************************
212: * Camera information
213: *****************************************************************************/
214: // camera type of the current view
215: // 0 - Perspective
216: // 1 - Ortho
217: // 2 - UV
218: uniform int u_MriViewType;
219: 
220: // x:left, y:top, z:right, w:bottom
221: uniform vec4 u_MriViewport;
222: 
223: /****************************************************************************
224: * Matrices
225: *****************************************************************************/
226: uniform mat4 u_MriViewMatrix;
227: uniform mat4 u_MriModelViewMatrix;
228: uniform mat4 u_MriProjectionMatrix;
229: uniform mat4 u_MriNormalMatrix;
230: 
231: /****************************************************************************
232: * Object information
233: *****************************************************************************/
234: uniform int u_MriObjectId;
235: uniform vec3 u_MriObjectCenter;
236: uniform float u_MriObjectRadius;
237: 
238: /****************************************************************************
239: * Light information
240: *****************************************************************************/
241: //Lighting mode
242: // 0 - Flat
243: // 1 - Basic (Diffuse only)
244: // 2 - Full
245: uniform int u_MriLightingMode;
246: 
247: uniform MriLightSource u_MriLightSources[MRI_LIGHT_ARRAY_SIZE];
248: 
249: /****************************************************************************
250: * Misc
251: *****************************************************************************/
252: // The current animation frame
253: uniform int u_MriCurrentFrame;
254: 
255: // The system time in milliseconds. Will wrap every ~70 minutes.
256: uniform int u_MriSystemTime;
257: 
258: uniform vec2 u_MriMaxSupportedTextureSize;
259: 
260: 
261: 
262: float mriColorBlend(float pixel, float fPixel, float bPixel, float fAlpha, float bAlpha, int normal);
263: vec3 mriColorBlendv(vec3 modifiedColor, vec3 layerColor, vec3 baseColor, float layerAlpha, float baseAlpha, int normal);
264: float mriAlphaBlend( float fAlpha, float bAlpha);
265: float mriRgb2Lightness(vec4 RGBA);
266: vec4 mriRgb2Hsl(vec4 colorIn);
267: vec4 mriHsl2Rgb(vec4 colorIn);
268: vec4 mriRgb2Hsv(vec4 colorIn);
269: vec4 mriHsv2Rgb(vec4 colorIn);
270: 
271: vec4 Comp_Add(vec4 base,vec4 blend,float Opacity);
272: vec4 Comp_BurnHighlights(vec4 base,vec4 blend,float Opacity);
273: vec4 Comp_BurnMidrange(vec4 base,vec4 blend,float Opacity);
274: vec4 Comp_BurnShadows(vec4 base,vec4 blend,float Opacity);
275: vec4 Comp_Clear(vec4 base,vec4 blend,float Opacity);
276: vec4 Comp_Color(vec4 base,vec4 blend,float Opacity);
277: vec4 Comp_ColorBurn(vec4 base,vec4 blend,float Opacity);
278: vec4 Comp_ColorDodge(vec4 base,vec4 blend,float Opacity);
279: vec4 Comp_Copy(vec4 base,vec4 blend,float Opacity);
280: vec4 Comp_CopyRGB(vec4 base,vec4 blend,float Opacity);
281: vec4 Comp_Darken(vec4 base,vec4 blend,float Opacity);
282: vec4 Comp_Default(vec4 base,vec4 blend,float Opacity);
283: vec4 Comp_Difference(vec4 base,vec4 blend,float Opacity);
284: vec4 Comp_DodgeHighlights(vec4 base,vec4 blend,float Opacity);
285: vec4 Comp_DodgeMidrange(vec4 base,vec4 blend,float Opacity);
286: vec4 Comp_DodgeShadows(vec4 base,vec4 blend,float Opacity);
287: vec4 Comp_Exclusion(vec4 base,vec4 blend,float Opacity);
288: vec4 Comp_HardLight(vec4 base,vec4 blend,float Opacity);
289: vec4 Comp_HardMix(vec4 base,vec4 blend,float Opacity);
290: vec4 Comp_Hue(vec4 base,vec4 blend,float Opacity);
291: vec4 Comp_InverseDifference(vec4 base,vec4 blend,float Opacity);
292: vec4 Comp_Invert(vec4 base,vec4 blend,float Opacity);
293: vec4 Comp_Lighten(vec4 base,vec4 blend,float Opacity);
294: vec4 Comp_Luminance(vec4 base,vec4 blend,float Opacity);
295: vec4 Comp_Multiply(vec4 base,vec4 blend,float Opacity);
296: vec4 Comp_Overlay(vec4 base,vec4 blend,float Opacity);
297: vec4 Comp_PinLight(vec4 base,vec4 blend,float Opacity);
298: vec4 Comp_Saturation(vec4 base,vec4 blend,float Opacity);
299: vec4 Comp_Screen(vec4 base,vec4 blend,float Opacity);
300: vec4 Comp_SoftLight(vec4 base,vec4 blend,float Opacity);
301: vec4 Comp_SpongeDesaturate(vec4 base,vec4 blend,float Opacity);
302: vec4 Comp_VividLight(vec4 base,vec4 blend,float Opacity);
303: vec4 Comp_Contrast(vec4 base,vec4 blend,float Opacity);
304: vec4 Comp_Decontrast(vec4 base,vec4 blend,float Opacity);
305: vec4 Comp_MixRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
306: vec4 Comp_AddRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
307: vec4 Comp_ReorientedNormalMappingRGBEncodedNormals( vec4 base, vec4 blend, float Opacity );
308: 
309: // Blending functions the operate on the color channels only. Used by things such as color adjustments where the alpha channel needs to be ignored.
310: vec4 Comp_Default(vec4 Base, vec3 Blend, float Amount);
311: vec4 Comp_Add(vec4 Base, vec3 Blend, float Amount);
312: vec4 Comp_Color(vec4 Base, vec3 Blend, float Amount);
313: vec4 Comp_Copy(vec4 Base, vec3 Blend, float Amount);
314: vec4 Comp_CopyRGB(vec4 Base, vec3 Blend, float Amount);
315: vec4 Comp_Darken(vec4 Base, vec3 Blend, float Amount);
316: vec4 Comp_Difference(vec4 Base, vec3 Blend, float Amount);
317: vec4 Comp_Hue(vec4 Base, vec3 Blend, float Amount);
318: vec4 Comp_InverseDifference(vec4 Base, vec3 Blend, float Amount);
319: vec4 Comp_Lighten(vec4 Base, vec3 Blend, float Amount);
320: vec4 Comp_Luminance(vec4 Base, vec3 Blend, float Amount);
321: vec4 Comp_Multiply(vec4 Base, vec3 Blend, float Amount);
322: vec4 Comp_Saturation(vec4 Base, vec3 Blend, float Amount);
323: 
324: vec4 Comp_VecDefault2d(vec4 base,vec4 blend,float Opacity);
325: vec4 Comp_VecDefault3d(vec4 base,vec4 blend,float Opacity);
326: 
327: vec4 Comp_VecAdd3d(vec4 base,vec4 blend,float Opacity);
328: vec4 Comp_VecAdd2d(vec4 base,vec4 blend,float Opacity);
329: 
330: vec4 Comp_VecScale3d(vec4 base,vec4 blend,float Opacity);
331: 
332: //! macro | custom_blend_mode_declarations | // No custom blend modes
333: 
334: 
335: 
336: 
337: //Curve lookup functions
338: 
339: float mriCurveLookup( in int Line, in float InValue);
340: 
341: 
342: 
343: 
344: /****************************************************************************
345: * Noise functions
346: *****************************************************************************/
347: 
348: //These functions generate Perlin and Simplex noise from 2D,3D,4D inputs
349: float mriPerlinNoise(vec2 P);
350: float mriPerlinNoise(vec3 P);
351: float mriPerlinNoise(vec4 P);
352: float mriSimplexNoise(vec2 P);
353: float mriSimplexNoise(vec3 P);
354: float mriSimplexNoise(vec4 P);
355: 
356: // DEPRECATED in favor of more explicit function names above
357: float mriNoise(vec3 P); 
358: 
359: 
360: //Cellular (Worley) noise generation function based on 3D input and different types of norm(distance) calculation. This returns vec3 in which F1, F2 and F1-F2 are returned in r, g and b of the resulting vec3 respectively. Cellular noise is a noise obtained by calculating distance to randomly generated points. The definition of the distance is the norm. F1 is the distance to the closest point while F2 is the distance to the 2nd closest point.  
361: // norm - The norm(distance calculation) definition to use. 
362: //  0 : Manhattan norm
363: //  1 : Euclidian norm
364: //  2 : Chebyshev(Infinity) norm
365: //  3 : P-norm where P=0.5
366: vec3 mriCellular(vec3 P, int norm);
367: 
368: // DEPRECATED
369: // These functions are provided for backward compatibility since the older version of Mari had these.
370: // These are deprecated and to be removed in favor of more explicitly named functions above.
371: float noise(vec3 P);
372: vec3 cellular(vec3 P, int norm);
373: 
374: 
375: 
376: 
377: //Given the face index at the evaluation point (usually the fragment), this returns hiddenness, lockedness and selectedness of the face in r,g and b respectively.
378: //the a component is currently not used, but reserved for the future usage
379: vec4 mriFaceSystemAttribute(int FaceIndex);
380: 
381: //Given the primitiveID, returns the face index of the original mesh
382: int mriFaceIndex(int PrimitiveID);
383: 
384: 
385: 
386: /****************************************************************************
387: * Misc
388: *****************************************************************************/
389: //This is an untility function to do the implementation of how to interpret a given color value as a mask. Whoever needs to regard some color value as mask should call this function for consistent mechanism
390: float interpretAsExposure(in vec4 Color,int Mode);
391: 
392: 
393: 
394: 
395: // Function for handling standard Vector Painting Maths
396: 
397: vec3 vector_bias( vec3 vector);
398: vec3 vector_unbias( vec3 colour);
399: 
400: vec3 vector_paintToTangent3D( vec3 screen);
401: vec3 vector_paintToTangent2D( vec3 screen);
402: 
403: vec3 vector_worldToTangent( vec3 tangent);
404: vec3 vector_tangentToWorld( vec3 tangent);
405: vec3 vector_tangentToScreen( vec3 tangent);
406: 
407: 
408: 
409: //! macro | module_inputs | // No Module Inputs
410: //! macro | module_calls  | // No Module Calls
411: //! macro | module_declarations  | // No Module Declarations
412: 
413: //! macro | surface_mask_declarations | // No mask applied
414: //! macro | surface_mask_body         | // No mask applied
415: 
416: uniform int udim_size;
417: 
418: void store_state(inout MriFragmentState State, inout MriSystemFragmentState _State);
419: void derive_state(inout MriFragmentState State, inout MriSystemFragmentState _State, float du, float dv);
420: void restore_state(inout MriFragmentState State, inout MriSystemFragmentState _State);
421: 
422: #define REVAL(func,du,dv) store_state(State, _State);derive_state(State, _State, du, dv);func(State,_State);restore_state(State, _State);
423: 
424: 
425: 
426: float olefresnel(float r, float g, float c);
427: float get_n(float r,float g);
428: float get_k2(float r, float n);
429: float n_min(float r);
430: float n_max(float r);
431: vec3 FresnelConductor(vec3 Refelctivity, vec3 EdgeTint,float cos_theta);//=====================
432: // Forward Declaration of functions
433: //=====================
434: 
435: void node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
436: void node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
437: void node_516e4503_ea09_4104_8e31_2e667c820272_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
438: void node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
439: void node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
440: void node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
441: void node_45b7815b_0361_452e_b5c5_f476cf68940f_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
442: void node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
443: void node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
444: void node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
445: void node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
446: void node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
447: void node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
448: void node_83662364_52db_4f7b_b336_baca232fc310_func(inout MriFragmentState State, inout MriSystemFragmentState _State);
449: 
450: //=====================
451: // Declaration of functions
452: //=====================
453: 
454: //=====================
455: //--- Style 2 Node 'Bottom Transparency' ---
456: //=====================
457: vec4 node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output; // Output 'Output' 
458: void node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
459: {
460:     vec4 Output; // Output 'Output' 
461: 
462:     Output = vec4( 0, 0, 0, 0);
463:         
464:     node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output = Output;
465: }
466: 
467: //=====================
468: //--- Style 2 Node 'Paint 3' ---
469: //=====================
470: uniform Channel Channel_node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_;
471: vec4 node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output; // Output 'Output' 
472: void node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
473: {
474:     vec4 Output; // Output 'Output' 
475: 
476:                   
477:         Output = texture_lookup2(Channel_node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_,State,_State);
478:                   
479:               
480:     node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output = Output;
481: }
482: 
483: //=====================
484: //--- Style 2 Node 'Merge_Bump_Head' ---
485: //=====================
486: uniform int AdvancedEnabled_node_516e4503_ea09_4104_8e31_2e667c820272_;
487: uniform float Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
488: uniform int AmountEnabled_node_516e4503_ea09_4104_8e31_2e667c820272_;
489: uniform int BlendIfBelow_node_516e4503_ea09_4104_8e31_2e667c820272_;
490: uniform int BlendIfThis_node_516e4503_ea09_4104_8e31_2e667c820272_;
491: uniform int BlendMode_node_516e4503_ea09_4104_8e31_2e667c820272_;
492: uniform int Component_node_516e4503_ea09_4104_8e31_2e667c820272_;
493: uniform int SwizzleA_node_516e4503_ea09_4104_8e31_2e667c820272_;
494: uniform int SwizzleB_node_516e4503_ea09_4104_8e31_2e667c820272_;
495: uniform int SwizzleG_node_516e4503_ea09_4104_8e31_2e667c820272_;
496: uniform int SwizzleR_node_516e4503_ea09_4104_8e31_2e667c820272_;
497: vec4 node_516e4503_ea09_4104_8e31_2e667c820272_Output; // Output 'Output' 
498: void node_516e4503_ea09_4104_8e31_2e667c820272_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
499: {
500:     vec4 Output; // Output 'Output' 
501: 
502:     if( 0 != 0)
503:     {
504:         // this is used to control what component we are pulling the key from
505:         vec3 Mult[5];
506: 
507:         Mult[0] = vec3(1.0/3.0,1.0/3.0,1.0/3.0);
508:         Mult[1] = vec3(1,0,0);
509:         Mult[2] = vec3(0,1,0);
510:         Mult[3] = vec3(0,0,1);
511:         Mult[4] = vec3(0.2126,0.7152,0.0722);
512: 
513: 
514:         // Calculate the amount from the component
515:         // a Mult value of (1,0,0) will isolate the red value
516:         // A mult value of (1,1,1) will give a gray scale
517: 
518:         float ThisAmount = dot(node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output.rgb , Mult[0]);
519:         float BelowAmount = dot(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output.rgb , Mult[0]);
520: 
521:         // now that we've pulled the component out of above and below
522:         // we lookup into the lut to find out the amount to scale the alpha values by
523: 
524:         float ThisAlpha  = mriCurveLookup(BlendIfThis_node_516e4503_ea09_4104_8e31_2e667c820272_,ThisAmount);
525:         float BelowAlpha = mriCurveLookup(BlendIfBelow_node_516e4503_ea09_4104_8e31_2e667c820272_,BelowAmount);
526: 
527:         // now we multiply the base alpha value by both values
528: 
529:         float AdvancedBlendAmount = ThisAlpha * BelowAlpha;
530:         if( 0 != 1)
531:         {
532:             AdvancedBlendAmount *= Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
533:         }
534: 
535:         Output = Comp_Default(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output, node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output, vec4(1,1,1,1).r * AdvancedBlendAmount);
536:     }
537:     else
538:     {
539:         float BlendAmount = 1;
540:         if( 0 != 1)
541:         {
542:             BlendAmount *= Amount_node_516e4503_ea09_4104_8e31_2e667c820272_;
543:         }
544:         Output = Comp_Default(node_8acef672_44bb_4f71_8631_2dd6a8d37f14_Output, node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_Output, BlendAmount * vec4(1,1,1,1).r);
545:     }
546: 
547:     Output = vec4( Output.r, Output.g, Output.b, Output.a);
548: 
549:                 
550:     node_516e4503_ea09_4104_8e31_2e667c820272_Output = Output;
551: }
552: 
553: //=====================
554: //--- Style 2 Node 'Paint 4' ---
555: //=====================
556: uniform Channel Channel_node_5ab26bd0_71fd_473d_ba94_940da940e2a5_;
557: vec4 node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output; // Output 'Output' 
558: void node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
559: {
560:     vec4 Output; // Output 'Output' 
561: 
562:                   
563:         Output = texture_lookup2(Channel_node_5ab26bd0_71fd_473d_ba94_940da940e2a5_,State,_State);
564:                   
565:               
566:     node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output = Output;
567: }
568: 
569: //=====================
570: //--- Style 2 Node 'Layer' ---
571: //=====================
572: uniform int AdvancedEnabled_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
573: uniform float Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
574: uniform int AmountEnabled_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
575: uniform int BlendIfBelow_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
576: uniform int BlendIfThis_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
577: uniform int BlendMode_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
578: uniform int Component_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
579: uniform int SwizzleA_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
580: uniform int SwizzleB_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
581: uniform int SwizzleG_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
582: uniform int SwizzleR_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
583: vec4 node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output; // Output 'Output' 
584: void node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
585: {
586:     vec4 Output; // Output 'Output' 
587: 
588:     if( 0 != 0)
589:     {
590:         // this is used to control what component we are pulling the key from
591:         vec3 Mult[5];
592: 
593:         Mult[0] = vec3(1.0/3.0,1.0/3.0,1.0/3.0);
594:         Mult[1] = vec3(1,0,0);
595:         Mult[2] = vec3(0,1,0);
596:         Mult[3] = vec3(0,0,1);
597:         Mult[4] = vec3(0.2126,0.7152,0.0722);
598: 
599: 
600:         // Calculate the amount from the component
601:         // a Mult value of (1,0,0) will isolate the red value
602:         // A mult value of (1,1,1) will give a gray scale
603: 
604:         float ThisAmount = dot(node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output.rgb , Mult[0]);
605:         float BelowAmount = dot(node_516e4503_ea09_4104_8e31_2e667c820272_Output.rgb , Mult[0]);
606: 
607:         // now that we've pulled the component out of above and below
608:         // we lookup into the lut to find out the amount to scale the alpha values by
609: 
610:         float ThisAlpha  = mriCurveLookup(BlendIfThis_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_,ThisAmount);
611:         float BelowAlpha = mriCurveLookup(BlendIfBelow_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_,BelowAmount);
612: 
613:         // now we multiply the base alpha value by both values
614: 
615:         float AdvancedBlendAmount = ThisAlpha * BelowAlpha;
616:         if( 0 != 1)
617:         {
618:             AdvancedBlendAmount *= Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
619:         }
620: 
621:         Output = Comp_Default(node_516e4503_ea09_4104_8e31_2e667c820272_Output, node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output, vec4(1,1,1,1).r * AdvancedBlendAmount);
622:     }
623:     else
624:     {
625:         float BlendAmount = 1;
626:         if( 0 != 1)
627:         {
628:             BlendAmount *= Amount_node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_;
629:         }
630:         Output = Comp_Default(node_516e4503_ea09_4104_8e31_2e667c820272_Output, node_5ab26bd0_71fd_473d_ba94_940da940e2a5_Output, BlendAmount * vec4(1,1,1,1).r);
631:     }
632: 
633:     Output = vec4( Output.r, Output.g, Output.b, Output.a);
634: 
635:                 
636:     node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output = Output;
637: }
638: 
639: //=====================
640: //--- Style 2 Node 'Bump_Head' ---
641: //=====================
642: vec4 node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output; // Output 'Output' 
643: void node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
644: {
645:     vec4 Output; // Output 'Output' 
646: 
647:     Output = node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_Output;
648:                 
649:     node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output = Output;
650: }
651: 
652: //=====================
653: //--- Style 2 Node 'Current Channel' ---
654: //=====================
655: vec4 node_45b7815b_0361_452e_b5c5_f476cf68940f_Output; // Output 'Output' 
656: void node_45b7815b_0361_452e_b5c5_f476cf68940f_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
657: {
658:     vec4 Output; // Output 'Output' 
659: 
660:     Output = node_216efa3f_986b_41d8_b81d_81003a80c2d9_Output;
661:                 
662:     node_45b7815b_0361_452e_b5c5_f476cf68940f_Output = Output;
663: }
664: 
665: //=====================
666: //--- Style 2 Node 'alSurfaceX/Height As Normal' ---
667: //=====================
668: uniform int BumpMode_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_;
669: uniform float BumpWeight_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_;
670: vec4 node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output; // Output 'Output' 
671: void node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
672: {
673:     vec4 Output; // Output 'Output' 
674: 
675:     // distance in texture space [0,1] between adjacent pixels at this mip level
676:     float Offset = exp2(_State.MipLevel)/u_MriMaxSupportedTextureSize.x;
677: 
678:     float BumpWeight = BumpWeight_node_5a712381_e354_4cf9_bf1e_cc1113c306f1_/Offset;
679: 
680: 
681: #if 0
682:     // fudge factor
683:     BumpWeight *= 1.0/(30.0 * 16.0);
684: 
685:     // Bump mapping version A
686:     //Default Input Used : NO REVAL(Heightfunc,-Offset,0.0);
687:     float l=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
688: 
689:     //Default Input Used : NO REVAL(Heightfunc,Offset,0.0);
690:     float r=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
691: 
692:     //Default Input Used : NO REVAL(Heightfunc,0.0,-Offset);
693:     float b=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
694: 
695:     //Default Input Used : NO REVAL(Heightfunc,0.0,Offset);
696:     float t=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
697: 
698:     vec2 heightDelta = vec2( l - r, b - t);
699: #else
700:     // fudge factor
701:     BumpWeight *= 2.0/(30.0 * 16.0);
702: 
703:     // Bump mapping version A
704:     float c=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
705: 
706:     //Default Input Used : NO REVAL(Heightfunc,Offset,0.0);
707:     float r=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
708: 
709:     //Default Input Used : NO REVAL(Heightfunc,0.0,Offset);
710:     float t=(bool( 0) ? (1.0-vec4(1,1,1,1).r) : vec4(1,1,1,1).r)*BumpWeight;
711: 
712:     vec2 heightDelta = vec2( c - r, c - t);
713: #endif
714: 
715:     Output.rgb = normalize( vec3(heightDelta,1.0) ) * vec3(0.5,-0.5,0.5) + vec3(0.5); 
716:     Output.a = 1.0; 
717:                 
718:     node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output = Output;
719: }
720: 
721: //=====================
722: //--- Style 2 Node 'alSurfaceX/Normal Modulation' ---
723: //=====================
724: vec4 node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output; // Output 'Output' 
725: void node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
726: {
727:     vec4 Output; // Output 'Output' 
728: 
729:         vec3 norm = vec3(0.0, 0.0, 0.0);
730:         vec3 norm0 = vec4(0.5,0.5,1.0,1.0).rgb * 2.0 -1.0;
731:         vec3 norm1 = node_5a712381_e354_4cf9_bf1e_cc1113c306f1_Output.rgb * 2.0 - 1.0;
732: 
733:         norm += dot(norm0.xy,norm0.xy)>0.0 ? norm0  : vec3(0.0);
734:         norm += dot(norm1.xy,norm1.xy)>0.0 ? norm1  : vec3(0.0);
735: 
736:         //When there is no bump/normal, set it to default
737:         norm = dot(norm,norm)>0.0 ? norm  : vec3(0.0,0.0,1.0);
738: 
739:         Output.rgb = normalize(norm);
740:         Output.a = 1.0;
741:                 
742:     node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output = Output;
743: }
744: 
745: //=====================
746: //--- Style 2 Node 'alSurfaceX/Tangent Space To Eye Space' ---
747: //=====================
748: vec4 node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output; // Output 'Output' 
749: void node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
750: {
751:     vec4 Output; // Output 'Output' 
752: 
753:     mat3 tangentSpace2eyeSpace = mat3(
754:         State.TangentInEyeSpaceFromViewCamera,
755:         State.BitangentInEyeSpaceFromViewCamera,
756:         State.NormalInEyeSpaceFromViewCamera
757:     );
758:     Output.rgb = normalize( tangentSpace2eyeSpace * (node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output.rgb * vec3( 1,-1,1)));
759:     Output.a = node_2b4c639f_c5ea_4e73_ab99_40d656b44382_Output.a;
760:                 
761:     node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output = Output;
762: }
763: 
764: //=====================
765: //--- Style 2 Node 'alSurfaceX/Color To Vector' ---
766: //=====================
767: vec4 node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output; // Output 'Output' 
768: void node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
769: {
770:     vec4 Output; // Output 'Output' 
771: 
772:         vec3 norm = (vec4(1.0,0.5,0.5,1.0).rgb * 2.0) - 1.0;
773: 
774:         Output.rgb = norm;
775:         Output.a = 1.0;
776:                 
777:     node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output = Output;
778: }
779: 
780: //=====================
781: //--- Style 2 Node 'alSurfaceX/Tangent Space To Eye Space 2' ---
782: //=====================
783: vec4 node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output; // Output 'Output' 
784: void node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
785: {
786:     vec4 Output; // Output 'Output' 
787: 
788:     mat3 tangentSpace2eyeSpace = mat3(
789:         State.TangentInEyeSpaceFromViewCamera,
790:         State.BitangentInEyeSpaceFromViewCamera,
791:         State.NormalInEyeSpaceFromViewCamera
792:     );
793:     Output.rgb = normalize( tangentSpace2eyeSpace * (node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output.rgb * vec3( 1,-1,1)));
794:     Output.a = node_335f31c0_6d5c_489a_bd08_78f37f3331f8_Output.a;
795:                 
796:     node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output = Output;
797: }
798: 
799: //=====================
800: //--- Style 2 Node 'alSurfaceX/Set Unlit' ---
801: //=====================
802: vec4 node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output; // Output 'Output' 
803: void node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
804: {
805:     vec4 Output; // Output 'Output' 
806: 
807: 
808:     _State.Unlit = ((_State.Unlit.a==0.0) ? node_45b7815b_0361_452e_b5c5_f476cf68940f_Output : _State.Unlit);
809:     Output = node_45b7815b_0361_452e_b5c5_f476cf68940f_Output;
810:                 
811:     node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output = Output;
812: }
813: 
814: //=====================
815: //--- Style 2 Node 'alSurfaceX/' ---
816: //=====================
817: uniform float AmbientOcclusion_node_83662364_52db_4f7b_b336_baca232fc310_;
818: uniform vec4 BacklightColor_node_83662364_52db_4f7b_b336_baca232fc310_;
819: uniform float BacklightIndirectStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
820: uniform float BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
821: uniform bool ConvertToGlossiness_node_83662364_52db_4f7b_b336_baca232fc310_;
822: uniform float Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_;
823: uniform vec4 DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_;
824: uniform float DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
825: uniform float DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
826: uniform vec4 EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
827: uniform float EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
828: uniform int Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_;
829: uniform vec4 Opacity_node_83662364_52db_4f7b_b336_baca232fc310_;
830: uniform int Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_;
831: uniform vec4 SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_;
832: uniform vec4 SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_;
833: uniform float SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_;
834: uniform bool Solid_node_83662364_52db_4f7b_b336_baca232fc310_;
835: uniform float Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
836: uniform vec4 Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
837: uniform vec4 Specular1EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_;
838: uniform int Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_;
839: uniform float Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_;
840: uniform vec4 Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_;
841: uniform float Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
842: uniform float Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
843: uniform float Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;
844: uniform float Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
845: uniform vec4 Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_;
846: uniform vec4 Specular2EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_;
847: uniform int Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_;
848: uniform float Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_;
849: uniform vec4 Specular2Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_;
850: uniform float Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
851: uniform float Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
852: uniform float Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_;
853: uniform vec4 TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
854: uniform float TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_;
855: uniform bool TransmissionLinkToSpecular1_node_83662364_52db_4f7b_b336_baca232fc310_;
856: uniform float TransmissionRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
857: uniform float TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
858: uniform int shadingNode_node_83662364_52db_4f7b_b336_baca232fc310_;
859: vec4 node_83662364_52db_4f7b_b336_baca232fc310_Output; // Output 'Output' 
860: void node_83662364_52db_4f7b_b336_baca232fc310_func(inout MriFragmentState State, inout MriSystemFragmentState _State)
861: {
862:     vec4 Output; // Output 'Output' 
863: 
864: 	shadingNode_node_83662364_52db_4f7b_b336_baca232fc310_; 
865: 	// Used for continually Mark what shader you are using in case you have renamed the name of the shader inside Mari. This var is also used for the exporter to identify what shader he is picking.
866: 	
867: 	DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_;
868: 	DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
869: 	Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
870: 	Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
871: 	Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
872: 	Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
873: 	Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_;
874: 	Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_;
875: 	Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_;
876: 	Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_;
877: 	Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_;
878: 	TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;
879: 	TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
880: 	TransmissionRoughness_node_83662364_52db_4f7b_b336_baca232fc310_;
881: 	Opacity_node_83662364_52db_4f7b_b336_baca232fc310_;
882: 	SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_;
883: 	SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_;
884: 	EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_;	
885: 	
886: 	// These control/input pairs are alpha blended together.
887: 	// If the Channel has an input connected the input is used.	
888: 	// Else the attribute slider is used instead.
889: 	// VAR Name   			 'mix' based on existence of an alpha in the channels	
890: 	vec3 difCol	   			= mix( vec3(0),		vec4(DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,		vec4(DiffuseColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
891: 	vec3 specCol1  			= mix( vec3(0),		vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
892: 	vec3 specCol2  			= mix( vec3(0),		vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
893: 	vec3 reflCol1  			= mix( vec3(0),		vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular1Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
894: 	vec3 reflCol2  			= mix( vec3(0),		vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(Specular2Color_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
895: 	vec3 refrCol  			= mix( vec3(0),		vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
896: 	vec3 transCol 			= mix( vec3(0),		vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 		== 0 ? 0 : 1);
897: 	vec3 sssCol	   			= mix( vec3(0),		vec4(SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb, 			vec4(SSSColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a				== 0 ? 0 : 1);
898: 	vec3 sssRadius 			= mix( vec3(0), 	vec4(SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb, 		vec4(SSSRadius_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 			== 0 ? 0 : 1);
899: 	vec3 emisCol   			= mix( vec3(0),		vec4(EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).rgb,	 	vec4(EmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a		== 0 ? 0 : 1);
900: 		
901: 	float difrough 	 		= mix( float(0),	vec4(DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(DiffuseRoughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
902: 	float spec1rough 		= mix( float(0),	vec4(Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
903: 	float ani1				= mix( float(0),	vec4(Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
904: 	float rot1 		 		= mix( float(0),	vec4(Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular1Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
905: 	float spec2rough 		= mix( float(0),	vec4(Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Roughness_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
906: 	float ani2				= mix( float(0),	vec4(Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Anisotropy_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
907: 	float rot2 		 		= mix( float(0),	vec4(Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).r,	vec4(Specular2Rotation_node_83662364_52db_4f7b_b336_baca232fc310_).a 	== 0 ? 0 : 1);
908: 	float refrarough		= mix( float(0),	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).r,	vec4(TransmissionColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,-1).a 	== 0 ? 0 : 1);
909: 	
910: 
911: 	vec3 Current_Channel_Selected = node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output.rgb;
912: 	
913: 	if(ConvertToGlossiness_node_83662364_52db_4f7b_b336_baca232fc310_ == true)
914: 	{
915: 		spec1rough = 1.0 - spec1rough;
916: 		spec2rough = 1.0 - spec2rough;
917: 	}
918: 	
919: 	// Check if there's Color painted at the rgb of the Opacity Channels	
920: 	vec3 opacityCol	 = vec3(0,0,0);
921: 	if (color_toValue(vec4(Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,0).rgb) == 0)
922: 	{
923: 		opacityCol = vec3(1.0) - Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb;
924: 	}
925: 	else
926: 	{
927: 		opacityCol = vec3(1.0) - vec4(Opacity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,0).rgb;	
928: 	}	
929: 	
930: 	// The UV Viewport will display what is the Current Channel Selected, unless you don't have any channel. Then it will display the Mari`s alpha checkerboard pattern.	
931: 	if(u_MriViewType==2 || u_MriLightingMode==0)
932: 	{
933: 		// This is the cheapest way to use this "viewbuffer" feature, skipping most of the shader calculation.
934: 		
935: 		Output = node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output;		
936: 		
937: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 1)
938: 		{
939: 			Output.rgb = difCol.rgb;
940: 		}
941: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 2)
942: 		{
943: 			Output.rgb = specCol1.rgb;
944: 		}
945: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 3)
946: 		{
947: 			Output.rgb = reflCol1.rgb;
948: 		}
949: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 4)
950: 		{
951: 			Output.rgb = refrCol.rgb;
952: 		}
953: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 5)
954: 		{
955: 			Output.rgb = sssCol.rgb;
956: 		}
957: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 6)
958: 		{
959: 			Output.rgb = emisCol.rgb;
960: 		}
961: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7)
962: 		{
963: 			Output = vec4(0.5,0.5,0.5,0.0);
964: 		}
965: 		
966: 		//Display the Thickness imported image in the UV Viewport
967: 		if(u_MriViewType==2 && Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7) 
968: 		{
969: 			Output = vec4(0.5,0.5,0.5,0.0);			
970: 		}		
971: 	}
972: 	else
973: 	{
974: 		// ------------  All the shader math ------------
975: 		
976: 		const float PI = 3.14159265358979323846264;
977: 		const float TwoPI = 2.0 * PI;
978: 			
979: 		// View Direction
980: 		vec3 V = normalize(-State.ViewVectorInEyeSpaceFromViewCamera);
981: 		// Normal Direction
982: 		vec3 N = normalize(node_36f7381d_8c53_4702_90d6_19f6581a1c85_Output.xyz);
983: 			
984: 		float NdotV = dot(N,V);
985: 		// On the wrong side of the face
986: 		if( NdotV <= 0.0)
987: 		{
988: 			N = -N;
989: 			NdotV = 1.0 - NdotV;
990: 		}
991: 				
992: 		//Enum Light direction
993: 		vec3 L = N;
994: 		// Half Vector
995: 		vec3 H = normalize(L+V);					
996: 		float cos_theta = dot(H,V);
997: 		vec3 RelectionTintColor1 = FresnelConductor(Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,Specular1EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,cos_theta);
998: 		//vec3 RelectionTintColor1 = Specular1Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb;
999: 		vec3 RelectionTintColor2 = FresnelConductor(Specular2Reflectivity_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,Specular2EdgeTint_node_83662364_52db_4f7b_b336_baca232fc310_.rgb,cos_theta);
1000: 
1001: 				
1002: 		// Calculates the Space diagonal of the volume inside a cube
1003: 		vec3 viewPos = vec3(1.0);
1004: 		viewPos.x = mix(1, 2*abs(State.Position.x), abs(State.NormalInEyeSpaceFromViewCamera.x) );
1005: 		viewPos.y = mix(1, 2*abs(State.Position.y), abs(State.NormalInEyeSpaceFromViewCamera.y) );
1006: 		viewPos.z = mix(1, 2*abs(State.Position.z), abs(State.NormalInEyeSpaceFromViewCamera.z) );
1007: 		float base_diagonal = sqrt(viewPos.x*viewPos.x+viewPos.z*viewPos.z);
1008: 		float space_diagonal = sqrt(base_diagonal*base_diagonal + viewPos.y*viewPos.y);
1009: 			
1010: 		// Check if there is a texture assigned to the vec4(0.5,0.5,0.5,0.0) attribute, if does, then use it instead of the 1.5 value. 
1011: 		float Thickness = 1.5;	
1012: 		if(vec4(0.5,0.5,0.5,0.0).a > 0)	
1013: 		{
1014: 			Thickness = 1.0 + vec4(0.5,0.5,0.5,0.0).r;		
1015: 		}
1016: 		
1017: 		//Use the Baked texture to mix with the multiplication factors of the "Voxelized calculation method" based on depth of the scene
1018: 		if(u_MriViewType == 0) //gl buffer does not work well in perspective mode
1019: 		{
1020: 			//thickness based on position calculation mixed with obj radius
1021: 			vec3 P = State.Position*u_MriObjectRadius;
1022: 			float d = -dot(State.Position,P);
1023: 			float D = abs(d)/length(P);
1024: 			D /=u_MriObjectRadius;             
1025: 			
1026: 			Thickness *= mix( mix(2, 1, 1-NdotV)*u_MriObjectRadius, space_diagonal, (1-NdotV)*length(D));	
1027: 		}
1028: 		else
1029: 		{
1030: 			//thickness based on depth and obj radius
1031: 			float mult_factor = mix(2*u_MriObjectRadius, u_MriObjectRadius/2, gl_FragDepth);
1032: 			//thickness adjusment for the depth based on the Space diagonal of a cube created for each pixel on face.
1033: 			float mult_factor2 = mix( mix(space_diagonal, 1, (gl_FragDepth*(1-NdotV))), mix(u_MriObjectRadius, 1, (2*abs(gl_FragDepth - 0.5))*(1-NdotV)), 2*abs(gl_FragDepth - 0.5) )*PI; // this PI is just a adjusment to the color values between the two viewports
1034: 			
1035: 			Thickness *= mix(mult_factor, mult_factor2, gl_FragDepth);
1036: 		}	
1037: 		
1038: 				
1039: 		// Roughness attributes squared
1040: 		float difrough2 = difrough*difrough;		
1041: 		float spec1rough2 = spec1rough*spec1rough*spec1rough*spec1rough; // Arnold use a quadratic specrough for cook-torrance only(their wish was to use cubic, but that's expensive they say).	
1042: 		float spec2rough2 = spec2rough*spec2rough*spec2rough*spec2rough;
1043: 		float refrarough2 = refrarough*refrarough*refrarough*refrarough;
1044: 		
1045: 		float _glossiness = 1.0;
1046: 		float _Refra_glossiness = 1.0;
1047: 		float _ani1 = 2*(0.5-ani1); // internal variable to be used as anisotropy for the maths, this changes the anisotropy value to the range -1 and 1 that is used by V-ray and is correct for obtain the correct result from the BRDF Formula.
1048: 		float _ani2 = 2*(0.5-ani2);
1049: 		
1050: 		// IBL Glossiness adaptation to match the BRDF blur or 'spec lobe' for Environment Lighting
1051: 		_glossiness = mix(pow( 1-sqrt(spec1rough2), 2), pow( 1-(spec1rough), 3), 1-spec1rough);
1052: 		_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1053: 		
1054: 		if(_ani1 == 0.0 || spec1rough2 == 0.0) // There is no Anisotropy if the Specular Roughness = 0
1055: 		{
1056: 			_glossiness = pow( mix( 1-spec1rough2, 1-sqrt(spec1rough2), 1-spec1rough), mix(2, 3, 1-spec1rough) );
1057: 			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1058: 		}
1059: 		else
1060: 		{				  
1061: 			_glossiness = pow( mix( (abs(_ani1)/PI+1-sqrt(spec1rough2))/2, (abs(_ani1)+1-sqrt(spec1rough2))/2, 1-spec1rough), mix(1, (abs(_ani1)+1-sqrt(spec1rough2))*1.5, 1-spec1rough) );
1062: 			_Refra_glossiness = mix(pow( 1-sqrt(refrarough2), 2-refrarough), pow( 1-sqrt(refrarough2), mix(4, 16, refrarough2) ), 1-refrarough);
1063: 		}
1064: 		
1065: 		// Fresnel var initialization	
1066: 		float F = 1.0;
1067: 		if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1068: 		{
1069: 			F = 0.0;
1070: 		}	
1071: 		
1072: 		// Anisotropic coords
1073: 		vec3 epsilon1 = vec3(0, 1, 0.15);
1074: 		vec3 X1 = vec3(1,0,0);
1075: 		vec3 Y1 = vec3(0,1,0);
1076: 		if(node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.a != 1.0)
1077: 		{
1078: 			X1.x = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.r;
1079: 			Y1.y = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.g;
1080: 		}
1081: 		if(ani1 != 0.5)
1082: 		{		
1083: 			epsilon1 = rot1 < 0.5 ? mix(Y1, X1, 2*rot1) : mix(X1, -Y1, 2*(rot1-0.5) );		
1084: 		}
1085: 				
1086: 		Y1 = normalize(cross(N, epsilon1));
1087: 		X1 = normalize(cross(N, Y1));
1088: 		
1089: 		vec3 epsilon2 = vec3(0, 1, 0.15);
1090: 		vec3 X2 = vec3(1,0,0);
1091: 		vec3 Y2 = vec3(0,1,0);
1092: 		if(node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.a != 1.0)
1093: 		{
1094: 			X2.x = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.r;
1095: 			Y2.y = node_c9a735e3_c911_47a8_b47d_631aa823e4e0_Output.g;
1096: 		}
1097: 		if(ani2 != 0.5)
1098: 		{		
1099: 			epsilon2 = rot2 < 0.5 ? mix(Y2, X2, 2*rot2) : mix(X2, -Y2, 2*(rot2-0.5) );		
1100: 		}
1101: 				
1102: 		Y2 = normalize(cross(N, epsilon2));
1103: 		X2 = normalize(cross(N, Y2));
1104: 
1105: 		// Energy variables initialization for each phase of the light calculation
1106: 		vec3 EnergyDiffuse = vec3(0.0);
1107: 		vec3 EnergyDiffuse_env = vec3(0.0); //avoid diffuse light bounces from lights to the obj
1108: 		vec3 EnergyBacklight = vec3(0.0);
1109: 		vec3 EnergyBacklight_env = vec3(0.0);
1110: 		vec3 EnergySpecular1 = vec3(0.0); //also separete the energy from highlights and reflection(point lights and environment light) also avoids lights bouncees from shader to the direct light sourcers the point lights.
1111: 		vec3 EnergySpecular_env1 = vec3(0.0);
1112: 		vec3 EnergyReflection_env1 = vec3(0.0);
1113: 		vec3 EnergySpecular2 = vec3(0.0); 
1114: 		vec3 EnergySpecular_env2 = vec3(0.0); 
1115: 		vec3 EnergyReflection_env2 = vec3(0.0);
1116: 		vec3 EnergyRefraction_env = vec3(0.0);
1117: 		vec3 EnergyTransmittance = vec3(1.0);
1118: 		vec3 EnergySSS = vec3(0.0);
1119: 		vec3 EnergySSS_env = vec3(0.0); //avoid SSS light bounces from lights to the obj
1120: 		vec3 EnergyOpacity_env = vec3(0.0);
1121: 		
1122: 		vec3 LightColour = vec3(0.0);
1123: 		float diffterm = 0.0;
1124: 		float specterm = 0.0;
1125: 		float specterm2 = 0.0;
1126: 		float refraterm = 0.0;
1127: 		vec3 _Absorbance = vec3 (1.0);
1128: 		
1129: 		
1130: 		
1131: 		for(int i=0;i<4;i++)
1132: 		{
1133: 			if( vec3( 0) == u_MriLightSources[i].DiffuseColor.rgb && vec3( 0) == u_MriLightSources[i].SpecularColor.rgb)
1134: 			{
1135: 				continue;
1136: 			}
1137: 
1138: 			float lightVisibility = mriLightVisibility( i, State.Position);		
1139: 			
1140: 			// Light Direction			
1141: 			vec3 L = normalize(u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera);
1142: 			vec3 LdistP = u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera;	
1143: 			
1144: 			// Half Vector
1145: 			vec3 H = normalize(L+V);		
1146: 			
1147: 			float LdotN = dot(L,N);		
1148: 			{			
1149: 				// ----------DIFFUSE TERM-----------
1150: 				// Oren-Nayar Diffuse Result from the Light Sources
1151: 				diffterm = 1.25*mriBRDF_Oren_Nayar(N, V, L, difrough2);
1152: 				EnergyDiffuse  += (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * (diffterm) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);
1153: 				
1154: 				// Check-box Calculate Fresnel to Diffuse
1155: 				//if($DiffuseFresnel == true)
1156: 				// Calculate fresnel attenuation for the Diffuse, using the specReflectance at normal or the $IOR attributes.		
1157: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1158: 				{
1159: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);
1160: 					// *FIX Light Occlusion/Shadow Issue*
1161: 					float F0 = (1 - TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)/(1 + TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1162: 					F0 = F0*F0;
1163: 					F = mix(F*(1-NdotV), F, F0);
1164: 					// Energy Conservation from Specular (Lights Sources)	
1165: 					EnergyDiffuse *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;						
1166: 				}
1167: 				
1168: 				// ----------Sub-Surface Scattering TERM-----------            
1169: 				float LdotN = dot(L,N);
1170: 				float LdotH = dot(L,H);
1171: 				
1172: 				float FL = mriBRDF_SchlickFresnel(LdotN);
1173: 				float FV = mriBRDF_SchlickFresnel(NdotV);			
1174: 							
1175: 				LightColour = (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);
1176: 					
1177: 				// creates a bit of a fake impression of difusion
1178: 				vec3 mixSSSdifusion = vec3(0.0);
1179: 				for (int j=0;j<3;j++)
1180: 				{			
1181: 					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), 1-sssRadius.rgb[j] );
1182: 				}
1183: 				vec3 Back_Scat_Color = 1.25*mixSSSdifusion*mixSSSdifusion;
1184: 				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
1185: 				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
1186: 				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;
1187: 				
1188: 				EnergySSS += Back_Scat_Color;
1189: 							
1190: 				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1191: 				//if($DiffuseFresnel == true)
1192: 				// The same fresnel attenuation that affects the diffuse above.
1193: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1194: 				{
1195: 					// Energy Conservation from Specular (Lights Sources)
1196: 					EnergySSS *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;														
1197: 				}
1198: 				
1199: 				// ----------BACKLIGHT TERM-----------
1200: 				if( LdotN <= 0.0)
1201: 				{
1202: 					if(BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_ > 0.0)
1203: 					{					
1204: 						diffterm = mriBRDF_Oren_Nayar(N, V, -L, difrough2);
1205: 						EnergyBacklight += ( u_MriLightSources[i].DiffuseColor.rgb) * diffterm * BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * BacklightColor_node_83662364_52db_4f7b_b336_baca232fc310_.rgb *att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_)/PI;
1206: 						
1207: 						// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1208: 						//if($DiffuseFresnel == true)
1209: 						if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1210: 						{
1211: 							F = mriBRDF_Fresnel(-L, -H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1212: 							// *FIX Light Occlusion/Shadow Issue*
1213: 							float F0 = (1 - TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)/(1 + TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);	
1214: 							F0 = F0*F0;
1215: 							F = mix(F*(1-NdotV), F, F0);						
1216: 							// Energy Conservation from Specular (Lights Sources)
1217: 							// ----------BACKLIGHT TERM-----------
1218: 							EnergyBacklight *= 1.0 - min(PI * F * max(0.0, dot(-L,N)) * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_, 1.0);						
1219: 						}
1220: 					}
1221: 					else
1222: 					{
1223: 						continue;
1224: 					}	
1225: 				}			
1226: 				
1227: 				// ----------SPECULAR1 TERM-----------
1228: 				// Moved to here so would Avoid shadow issues in the Diffuse and SSS Calculation and will prevent future issues in the Specular Calculation.
1229: 				if( LdotN > 0.0)
1230: 				{				
1231: 					// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR
1232: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1233: 					{
1234: 						F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1235: 					}	
1236: 					else
1237: 					{
1238: 						F = 1.0;
1239: 					}					
1240: 					//BRDF Model Cook-Torrance
1241: 					// Cook-Torrance Specular Result
1242: 					specterm = mriBRDF_Beckman(N, H, max(spec1rough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(spec1rough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
1243: 					
1244: 					
1245: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1246: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1247: 					if(abs(_ani1) != 0.0) 
1248: 					{							
1249: 						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
1250: 						if(spec1rough2 == 0.0)
1251: 						{
1252: 							specterm = mriBRDF_Ward(N, V, L, H, X1, Y1, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
1253: 						}
1254: 						else
1255: 						{						
1256: 							// Isotropy specular assumes that ani = 0
1257: 							specterm = mriBRDF_Ward(N, V, L, H, X1, Y1, _ani1, 0.99-spec1rough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
1258: 						}					
1259: 					}						
1260: 					EnergySpecular1 += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);			
1261: 				}
1262: 				
1263: 				// ----------SPECULAR2 TERM-----------
1264: 				if( LdotN > 0.0)
1265: 				{				
1266: 					if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1267: 					{
1268: 						F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1269: 					}	
1270: 					else
1271: 					{
1272: 						F = 1.0;
1273: 					}					
1274: 										
1275: 					//BRDF Model Cook-Torrance
1276: 					// Cook-Torrance Specular Result
1277: 					specterm2 = mriBRDF_Beckman(N, H, max(spec2rough2, 0.0001) ) * F * mriBRDF_Geo_att_Beckmann(N, V, max(spec2rough2, 0.0001) )*LdotN/(1+NdotV*LdotN);				
1278: 					
1279: 					
1280: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1281: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1282: 					if(abs(_ani2) != 0.0) 
1283: 					{							
1284: 						//Anisotropy, if Specular Roughness is 0 means that there is no Anisotropy
1285: 						if(spec2rough2 == 0.0)
1286: 						{
1287: 							specterm2 = mriBRDF_Ward(N, V, L, H, X2, Y2, 0, 0.99) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*LdotN;
1288: 						}
1289: 						else
1290: 						{						
1291: 							// Isotropy specular assumes that ani = 0
1292: 							specterm2 = mriBRDF_Ward(N, V, L, H, X2, Y2, _ani2, 0.99-spec2rough2) * F * mriBRDF_Geo_att_Ward_Duer(L, V, N, H)*TwoPI*LdotN/(1+NdotV*LdotN);
1293: 						}					
1294: 					}						
1295: 					EnergySpecular2 += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm2) * att(LdistP, Light_Falloff_node_83662364_52db_4f7b_b336_baca232fc310_, Decay_Rate_node_83662364_52db_4f7b_b336_baca232fc310_);			
1296: 				}
1297: 
1298: 			}		
1299: 		}
1300: 		
1301: 		
1302: 		if( mriEnvironmentLightOn() == true)
1303: 		{
1304: 			{
1305: 				// ----------DIFFUSE TERM-----------
1306: 				// Env Light, Light Direction
1307: 				vec3 L = N;
1308: 				LightColour = mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 0.0);
1309: 				// This mix(PI, 2.5, difrough2) would preserve albedo.	
1310: 				EnergyDiffuse_env = mix(PI, 2.5, difrough2)*mriBRDF_Oren_Nayar(N, V, L, difrough2) * LightColour;            		
1311: 				
1312: 				// Check-box Calculate Fresnel to Diffuse 
1313: 				//if($DiffuseFresnel == true)
1314: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1315: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1316: 				{
1317: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1318: 					L = normalize( -reflect( V, N));
1319: 					// Half Vector
1320: 					vec3 H = normalize(L+V);					
1321: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1322: 					// Energy Conservation from Specular (Environment)					
1323: 					EnergyDiffuse_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1324: 					
1325: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1326: 					{
1327: 						F = 0.0; 
1328: 					}
1329: 					// Energy Conservation from Reflection (Environment)	
1330: 					EnergyDiffuse_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1331: 				}
1332: 			}
1333: 			
1334: 			{
1335: 				// ----------BACKLIGHT TERM-----------
1336: 				// Env Light, Light Direction
1337: 				// Backlight	
1338: 				vec3 L = normalize( -refract(V, -N*State.FragmentPositionInEyeSpaceFromViewCamera, 1.0) );				
1339: 				
1340: 				float lightVisibility = 1.0;			
1341: 				
1342: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);	
1343: 				
1344: 				EnergyBacklight_env += mix(vec3(0), LightColour, BacklightStrength_node_83662364_52db_4f7b_b336_baca232fc310_)*mriBRDF_Oren_Nayar(N, V, N, difrough2);
1345: 				EnergyBacklight_env /= 1+difrough2/PI;
1346: 				
1347: 				//if($DiffuseFresnel == true)
1348: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1349: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1350: 				{
1351: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1352: 					L = normalize( -reflect( V, N));
1353: 					// Half Vector
1354: 					vec3 H = normalize(L+V);					
1355: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1356: 					// Energy Conservation from Specular (Environment)					
1357: 					EnergyBacklight_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1358: 						
1359: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1360: 					{
1361: 						F = 0.0; 
1362: 					}
1363: 					// Energy Conservation from Reflection (Environment)	
1364: 					EnergyBacklight_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1365: 				}
1366: 			}	
1367: 
1368: 			{
1369: 				// ----------SPECULAR TERM1-----------
1370: 				// Env Specular Reflection, Light Direction			
1371: 				vec3 L = normalize( -reflect( V, N));
1372: 				// Half Vector
1373: 				vec3 H = normalize(L+V);          			
1374: 				
1375: 				// How to calculate fresnel to specular equation, using specReflectance at normal or Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_
1376: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1377: 				{
1378: 					F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1379: 				}
1380: 				else
1381: 				{
1382: 					F = 1.0;
1383: 				}
1384: 				float LdotN = dot(L,N);
1385: 				if( 0.0 < LdotN)
1386: 				{
1387: 					float lightVisibility = 1.0;
1388: 					LightColour = vec3(0.0);				
1389: 
1390: 					//BRDF Model Cook-Torrance
1391: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
1392: 					// Cook-Torrance Specular Result from Environment
1393: 					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-spec1rough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
1394: 					
1395: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1396: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1397: 					if(abs(_ani1) != 0) 
1398: 					{									
1399: 						// Isotropy reflection
1400: 						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
1401: 							
1402: 						// Anisotropy reflection	
1403: 						if(_ani1 != 0.0 && spec1rough2 != 0)
1404: 						{
1405: 							// Caculate how much isotropy is the material based on roughness and anisotropy values.
1406: 							float _isotropy = abs(_ani1)*(1.1-spec1rough2);	
1407: 							
1408: 							LightColour = vec3(0.0);
1409: 							float i = 0;
1410: 							for (;i < _isotropy;)
1411: 							{
1412: 							
1413: 							// Define the direction of the anisotropy
1414: 							vec3 L1 = normalize( reflect( V, _ani1 < 0? X1:Y1 ));
1415: 								
1416: 							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
1417: 							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L1, L, 1-i), clamp(_glossiness + abs(_ani1*_ani1)*(1.0-spec1rough2)/9, .1, .9) );							
1418: 							i += 0.1;
1419: 							}
1420: 							LightColour /= i*10;												
1421: 						}		
1422: 						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-spec1rough), 0.0, 1.0 );					
1423: 					}
1424: 					EnergySpecular_env1 += specterm * (LightColour);		
1425: 				
1426: 			
1427: 					// ----------REFLECTION TERM-----------
1428: 					// Reset the fresnel value, and keep the L direction from the specular above.
1429: 					
1430: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1431: 					{
1432: 						F = mriBRDF_Fresnel(L, H, Specular1Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1433: 					}
1434: 					else
1435: 					{
1436: 						F = 1.0;
1437: 					}
1438: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
1439: 					EnergyReflection_env1 += F * (LightColour);
1440: 				}	
1441: 			}		
1442: 
1443: 			{
1444: 				// ----------SPECULAR TERM2-----------
1445: 				// Env Specular Reflection, Light Direction			
1446: 				vec3 L = normalize( -reflect( V, N));
1447: 				// Half Vector
1448: 				vec3 H = normalize(L+V);          			
1449: 				
1450: 				// How to calculate fresnel to specular equation, using specReflectance at normal or Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_
1451: 				if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1452: 				{
1453: 					F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1454: 				}
1455: 				else
1456: 				{
1457: 					F = 1.0;
1458: 				}
1459: 				float LdotN = dot(L,N);
1460: 				if( 0.0 < LdotN)
1461: 				{
1462: 					float lightVisibility = 1.0;
1463: 					LightColour = vec3(0.0);				
1464: 
1465: 					//BRDF Model Cook-Torrance
1466: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
1467: 					// Cook-Torrance Specular Result from Environment
1468: 					specterm = 1.0 * F * mriBRDF_Geo_att_Cook_Torrance(N, H, V, L) * clamp( mix(1.0-LdotN*NdotV/4, 1, 1-spec2rough), 0.0, 1.0 );	//the mriBRDF_Geo_att_Cook_Torrance fits better here then the Beckmann. 	
1469: 					
1470: 					// In the last versions of Arnold The BRDF models get unified into a single one!
1471: 					//BRDF Model WARD or Cook-Torrance with Anisotropy	
1472: 					if(abs(_ani2) != 0) 
1473: 					{									
1474: 						// Isotropy reflection
1475: 						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);
1476: 							
1477: 						// Anisotropy reflection	
1478: 						if(_ani2 != 0.0 && spec2rough2 != 0)
1479: 						{
1480: 							// Caculate how much isotropy is the material based on roughness and anisotropy values.
1481: 							float _isotropy = abs(_ani2)*(1.1-spec2rough2);	
1482: 							
1483: 							LightColour = vec3(0.0);
1484: 							float i = 0;
1485: 							for (;i < _isotropy;)
1486: 							{
1487: 							
1488: 							// Define the direction of the anisotropy
1489: 							vec3 L2 = normalize( reflect( V, _ani2 < 0? X2:Y2 ));
1490: 								
1491: 							// mix between isotropy and anisotropy look, depending on the amount of roughness and anisotropy amount							
1492: 							LightColour += lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * mix(L2, L, 1-i), clamp(_glossiness + abs(_ani2*_ani2)*(1.0-spec2rough2)/9, .1, .9) );							
1493: 							i += 0.1;
1494: 							}
1495: 							LightColour /= i*10;												
1496: 						}		
1497: 						specterm = 1.0 * F * mriBRDF_Geo_att_Ward_Duer( L, V, N, H) * clamp( mix(0.95-NdotV/6.5, 1, 1-spec2rough), 0.0, 1.0 );					
1498: 					}
1499: 					EnergySpecular_env2 += specterm * (LightColour);		
1500: 				
1501: 			
1502: 					// ----------REFLECTION TERM-----------
1503: 					// Reset the fresnel value, and keep the L direction from the specular above.
1504: 					
1505: 					if(Specular2FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1506: 					{
1507: 						F = mriBRDF_Fresnel(L, H, Specular2Ior_node_83662364_52db_4f7b_b336_baca232fc310_);
1508: 					}
1509: 					else
1510: 					{
1511: 						F = 1.0;
1512: 					}
1513: 					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 1.0);
1514: 					EnergyReflection_env2 += F * (LightColour);
1515: 				}	
1516: 			}		
1517: 
1518: 			
1519: 			{
1520: 				// ----------REFRACTION TERM-----------
1521: 				// Env Refraction, Light Direction			
1522: 				// Refraction incoming direction
1523: 				vec3 Li = vec3(0.0);
1524: 				if(Solid_node_83662364_52db_4f7b_b336_baca232fc310_)
1525: 				{
1526: 					Li = normalize( -refract(V, -N, (1.0/TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)) );
1527: 				}
1528: 				else
1529: 				{
1530: 					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
1531: 					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, (1.0/TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_)) );
1532: 				}
1533: 				
1534: 				float lightVisibility = 1.0;
1535: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, _Refra_glossiness);		
1536: 				
1537: 				EnergyRefraction_env += (LightColour);		
1538: 							
1539: 				_Absorbance = transCol.rgb;
1540: 				if (_Absorbance != vec3(1.0) )
1541: 				{			
1542: 					_Absorbance = pow_RGB(transCol.rgb, Thickness/10);
1543: 					EnergyTransmittance = _Absorbance;
1544: 				}
1545: 				
1546: 				// *TWEAK* This will preserve some energy from the reflection that is actually passing through the surface and not been reflected by the fresnel.
1547: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1548: 				{
1549: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1550: 					vec3 L = normalize( -reflect( V, N));
1551: 					float LdotN = dot(L,N);
1552: 					// Half Vector
1553: 					vec3 H = normalize(L+V);					
1554: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);					
1555: 					EnergyRefraction_env *=  1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;			
1556: 					
1557: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1558: 					{
1559: 						F = 0.0; 
1560: 					}
1561: 					EnergyRefraction_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;				
1562: 				}		
1563: 			}	
1564: 
1565: 			{
1566: 				// ----------Sub-Surface Scattering TERM-----------
1567: 				// Env Light, Light Direction
1568: 				// Sub-Surface Scattering	
1569: 				vec3 L = N;				
1570: 				// Half Vector
1571: 				vec3 H = normalize(L+V);			
1572: 				
1573: 				float LdotN = dot(L,N);
1574: 				float LdotH = dot(L,H);
1575: 				
1576: 				float FL = mriBRDF_SchlickFresnel(LdotN);
1577: 				float FV = mriBRDF_SchlickFresnel(NdotV);			
1578: 					
1579: 				float lightVisibility = 1.0;
1580: 				
1581: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L,  0.0);
1582: 				
1583: 				// creates a bit of a fake impression of difusion
1584: 				vec3 mixSSSdifusion = vec3(0.0);
1585: 				for (int j=0;j<3;j++)
1586: 				{			
1587: 					mixSSSdifusion[j] = LightColour[j] * mix(LdotH, LdotH*LdotN, 1-sssRadius.rgb[j] ) * mix( (1-FL)*(1-FV), (1-FL), sssRadius.rgb[j] );
1588: 				}
1589: 				vec3 Back_Scat_Color = 1.25*mixSSSdifusion;
1590: 				Back_Scat_Color.r *= sssRadius.r > 0 ? 1 : 0;
1591: 				Back_Scat_Color.g *= sssRadius.g > 0 ? 1 : 0;
1592: 				Back_Scat_Color.b *= sssRadius.b > 0 ? 1 : 0;						
1593: 				
1594: 				EnergySSS_env += Back_Scat_Color;
1595: 				
1596: 				// Check-box Calculate Fresnel to Diffuse it is applyed to Sub-Surface Scattering too!
1597: 				//if($DiffuseFresnel == true)
1598: 				// How to calculate fresnel to specular equation, using specReflectance at normal or $IOR	
1599: 				if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_ == 0)
1600: 				{
1601: 					// Reassigning light direction for calculate the fresnel accordingly to specular maths.
1602: 					L = normalize( -reflect( V, N));
1603: 					// Half Vector
1604: 					vec3 H = normalize(L+V);					
1605: 					F = mriBRDF_Fresnel(L, H, TransmissionIor_node_83662364_52db_4f7b_b336_baca232fc310_);						
1606: 					EnergySSS_env *= 1.0 - F * color_toValue(specCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1607: 					
1608: 					if(Specular1FresnelMode_node_83662364_52db_4f7b_b336_baca232fc310_==0)
1609: 					{
1610: 						F = 0.0; // picks from the math above, since this would be a value that comes from a global attribute for the entire fresnels math.
1611: 					}
1612: 					EnergySSS_env *= 1.0 - F * color_toValue(reflCol1.rgb)*Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_;					
1613: 				}
1614: 			}
1615: 			
1616: 			{
1617: 				// ----------OPACITY TERM-----------
1618: 				// Env Opacity, Light Direction			
1619: 				// Opacity incoming direction
1620: 				// It should look like a Ghost with inverted colors!
1621: 				vec3 Li = vec3(0.0);
1622: 				if(Solid_node_83662364_52db_4f7b_b336_baca232fc310_)
1623: 				{
1624: 					Li = normalize( -refract(V, -N, 1.0) );
1625: 				}
1626: 				else
1627: 				{
1628: 					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
1629: 					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, 1.0) );
1630: 				}
1631: 				float lightVisibility = 1.0;
1632: 				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, 1.0);		
1633: 				EnergyOpacity_env += LightColour;				
1634: 			}
1635: 		}	
1636: 		
1637: 		// AO option
1638: 		float _AO = 1.0 - AmbientOcclusion_node_83662364_52db_4f7b_b336_baca232fc310_ * State.AmbientOcclusion;
1639: 		
1640: 		// Keep in mind that Arnold does not restrict the artists with a builtin Energy Conservation! So you have some artists freedom to break the rules as you wish.
1641: 		vec3 Kd = (EnergyDiffuse+EnergyBacklight + EnergyDiffuse_env+EnergyBacklight_env) * difCol.rgb * DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * _AO;
1642: 		vec3 Ks1 = (EnergySpecular1 + EnergySpecular_env1) * specCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor1* _AO;	
1643: 		vec3 Ks2 = (EnergySpecular2 + EnergySpecular_env2) * specCol2.rgb * Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor2* _AO;	
1644: 		//vec3 Kr1 = EnergyReflection_env1 * reflCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor1 * _AO;
1645: 		//vec3 Kr2 = EnergyReflection_env2 * reflCol2.rgb * Specular2Strength_node_83662364_52db_4f7b_b336_baca232fc310_ * RelectionTintColor2 * _AO;
1646: 		vec3 Kt = EnergyRefraction_env * EnergyTransmittance * refrCol.rgb * TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * _AO;
1647: 		vec3 Ksss = (EnergySSS + EnergySSS_env) * SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_ * sssCol.rgb * _AO;	
1648: 		vec3 Opa = EnergyOpacity_env * opacityCol.rgb;
1649: 		
1650: 		// New Mari Lighting Mode workflow.
1651: 		// Lighting Mode => 0 - "Flat" - only display the Current Channel that is selected.
1652: 		// Lighting Mode =>	1 - Basic - Display Diffuse + Sub-surface Scattering
1653: 		// Lighting Mode => 2 - Full - Adds the specular/reflection + refraction + self-illumination on top of what the Basic mode displays
1654: 		Output.rgb = u_MriLightingMode==0 ? Current_Channel_Selected.rgb : Kd+Ksss;
1655: 		Output.rgb += u_MriLightingMode!=2 ? vec3(0.0) : Ks1+Ks2+Kt;
1656: 			
1657: 		// Emission
1658: 		Output.rgb += u_MriLightingMode==2 ? EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ * emisCol.rgb : vec3(0.0);
1659: 
1660: 		// Opacity
1661: 		Output.rgb = u_MriLightingMode==2 ? mix(Opa.rgb, Output.rgb, 1.0-color_toValue(opacityCol.rgb)) : Output.rgb;
1662: 				
1663: 		// If displaying "flat" lighting mode 0 use the Current Channel alpha.
1664: 		Output.a = u_MriLightingMode==0 ? node_487a93bc_b624_4b17_aab4_991a4e7bb4db_Output.a : 1.0;		
1665: 		
1666: 		
1667: 		// Render Passes Mode, the beauty pass = 0 doesn't need an if statement, it has coded above and displayed by default
1668: 		// Lighting Mode == 1 ? #Channel * $Weight : #Channel * $ChannelWeight * Lighting Contribution
1669: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 1)
1670: 		{
1671: 			Output.rgb = (u_MriLightingMode==1 ? difCol.rgb * DiffuseStrength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kd);
1672: 		}
1673: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 2)
1674: 		{
1675: 			Output.rgb = (u_MriLightingMode==1 ? specCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ : Ks1+Ks2);
1676: 		}
1677: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 3)
1678: 		{
1679: 			Output.rgb = (u_MriLightingMode==1 ? reflCol1.rgb * Specular1Strength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kr1+Kr2);
1680: 		}
1681: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 4)
1682: 		{
1683: 			Output.rgb = (u_MriLightingMode==1 ? refrCol.rgb * TransmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_ : Kt);
1684: 		}
1685: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 5)
1686: 		{
1687: 			Output.rgb = (u_MriLightingMode==1 ? sssCol.rgb * SSSWeight_node_83662364_52db_4f7b_b336_baca232fc310_ : Ksss);
1688: 		}
1689: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 6)
1690: 		{
1691: 			Output.rgb = emisCol.rgb * EmissionStrength_node_83662364_52db_4f7b_b336_baca232fc310_;
1692: 		}
1693: 		if(Render_Passes_node_83662364_52db_4f7b_b336_baca232fc310_ == 7)
1694: 		{
1695: 			Output.rgb = vec3(1.0/Thickness);			
1696: 		}	
1697: 	}
1698: 		
1699: 	            
1700:     node_83662364_52db_4f7b_b336_baca232fc310_Output = Output;
1701: }
1702: 
1703: //=====================
1704: //--- Style 2 Node 'Viewer' ---
1705: //=====================
1706: 
1707: 
1708: uniform bool projection_through_enabled;
1709: uniform float projectionDepthTexture_Offset;
1710: uniform sampler2D projectionDepthTexture;
1711: uniform bool ao_enabled;
1712: uniform float ao_value;
1713: uniform float ao_contrast;
1714: uniform float ao_invert;
1715: uniform int ao_curve;
1716: uniform float depth_start;
1717: uniform float depth_end;
1718: uniform float depth_falloff;
1719: uniform float depth_range;
1720: uniform sampler2D marqueeSelMask;
1721: uniform float marqueeSelMaskAmount;
1722: uniform mat3x2 marqueeSelMaskMatrix;
1723: float MarqueeSelMaskFunc( vec2 uv)
1724: {
1725:     return ( 1.0 - marqueeSelMaskAmount*(1.0-texture( marqueeSelMask, ( (marqueeSelMaskMatrix * vec3( uv, 1.0)) * vec2( 0.5, -0.5)) + vec2( 0.5, 0.5)).a));
1726: }
1727: uniform bool fn_enabled;
1728: uniform float fn_maskAmount;
1729: uniform float fn_size;
1730: uniform float fn_seed;
1731: uniform float fn_roughness;
1732: uniform float fn_contrast;
1733: uniform float fn_invert;
1734: uniform int fractal_curve;
1735: 
1736: 
1737: void apply_projection_masks(inout MriFragmentState State, inout MriSystemFragmentState _State)
1738: {
1739:     float projection_exposure_multipler = projection_through_enabled ? float(_State.ProjectionCoord.z <= 1.0) : float((_State.ProjectionCoord.z-projectionDepthTexture_Offset) <= texture(projectionDepthTexture,_State.ProjectionCoord.st).r);
1740: _State.NonPreviewableProjectionExposure *= projection_exposure_multipler;
1741: float Midpoint = (depth_end+depth_start)/2.0;float Distance = (abs(Midpoint+State.FragmentPositionInEyeSpaceFromProjectionCamera.z)-abs(Midpoint-depth_start))/(Midpoint-depth_start);_State.ProjectionExposure *= clamp(Distance/depth_falloff+1.0, 0.0, 1.0);_State.NonPreviewableProjectionExposure *= MarqueeSelMaskFunc( State.FragmentPositionInNdcSpaceFromProjectionCamera.st);
1742: 
1743: }
1744: 
1745: void evaluate_shader_network(inout MriFragmentState State, inout MriSystemFragmentState _State)
1746: {
1747:         {
1748:         node_8acef672_44bb_4f71_8631_2dd6a8d37f14_func(State,_State); // Evaluating Node 'Bottom Transparency'
1749:         node_632bdb9b_c945_4337_b8d4_e83fb0c1c3bc_func(State,_State); // Evaluating Node 'Paint 3'
1750:         node_516e4503_ea09_4104_8e31_2e667c820272_func(State,_State); // Evaluating Node 'Merge_Bump_Head'
1751:         node_5ab26bd0_71fd_473d_ba94_940da940e2a5_func(State,_State); // Evaluating Node 'Paint 4'
1752:         node_98a775d9_490a_4bf1_bbc6_f43e66b74e9c_func(State,_State); // Evaluating Node 'Layer'
1753:         node_216efa3f_986b_41d8_b81d_81003a80c2d9_func(State,_State); // Evaluating Node 'Bump_Head'
1754:         node_45b7815b_0361_452e_b5c5_f476cf68940f_func(State,_State); // Evaluating Node 'Current Channel'
1755:         node_5a712381_e354_4cf9_bf1e_cc1113c306f1_func(State,_State); // Evaluating Node 'alSurfaceX/Height As Normal'
1756:         node_2b4c639f_c5ea_4e73_ab99_40d656b44382_func(State,_State); // Evaluating Node 'alSurfaceX/Normal Modulation'
1757:         node_36f7381d_8c53_4702_90d6_19f6581a1c85_func(State,_State); // Evaluating Node 'alSurfaceX/Tangent Space To Eye Space'
1758:         node_335f31c0_6d5c_489a_bd08_78f37f3331f8_func(State,_State); // Evaluating Node 'alSurfaceX/Color To Vector'
1759:         node_c9a735e3_c911_47a8_b47d_631aa823e4e0_func(State,_State); // Evaluating Node 'alSurfaceX/Tangent Space To Eye Space 2'
1760:         node_487a93bc_b624_4b17_aab4_991a4e7bb4db_func(State,_State); // Evaluating Node 'alSurfaceX/Set Unlit'
1761:         node_83662364_52db_4f7b_b336_baca232fc310_func(State,_State); // Evaluating Node 'alSurfaceX/'
1762:         {
1763: 
1764:     _State.Diffuse = node_83662364_52db_4f7b_b336_baca232fc310_Output;
1765:                 
1766:         }
1767:     }
1768: 
1769: }
1770: 
1771: 
0(1679) : error C1008: undefined variable "Kr1"
0(1679) : error C1008: undefined variable "Kr2"

---CompilerLog---
0(1679) : error C1008: undefined variable "Kr1"
0(1679) : error C1008: undefined variable "Kr2"


Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 355 ms uu 69 FAILED
Debug : [   mrisnglslcontextmanager.cpp:667 ] : Network is NULL
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 27 ms 8 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 44 ms 8 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 43 ms 17 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 27 ms 17 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 45 ms 13 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 8 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 46  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 30 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 14 more times
Debug : [             mrimenurecord.cpp:288 ] : CreatedMenuCount 58
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #1 : Remove Layer Shader alSurfaceX
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #2 : Remove Node : alSurfaceX
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 144 ms
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 27 ms
Debug : [    mrishadermaterialsview.cpp:245 ] : [ -- ] Removed old shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x44ab5ce0, 'alSurfaceX'
Debug : [    mrishadermaterialsview.cpp:251 ] : [ -- ] Added shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a4f0, 'Current Paint Target'
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #2 : Remove Node : alSurfaceX
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #1 : Remove Layer Shader alSurfaceX
Debug : [   mrisnglslcontextmanager.cpp:748 ] : Reloading Shader 'Shader Network1'
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 17 ms
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'Current Paint Target' completed in 19 ms
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 16 more times
Debug : [          mrimodularshader.cpp:541 ] : reloadMacros() called although this shader is never linked
Debug : [          mrimodularshader.cpp:560 ] : Shader 'Shader Network1' reloadMacros() called although this shader is never linked
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 54 ms 69 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 366 ms uu 69
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 25 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 1 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 24 ms 17 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 0 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 28 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #1 : Add Shader
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #2 : Add Shader alSurfaceX
Debug : [       mrilayershaderutils.cpp:304 ] : Add Shader 'alSurfaceX'
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Standalone/alSurfaceX
Debug : [     mriserializableobject.cpp:1017] : Attribute 'ConvertToGlossiness' already exists!
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node '', input count: 21
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Standalone/alSurfaceX
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Input
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Input
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'Shader', input count: 22
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Output
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'Shader', input count: 21
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Output
Debug : [ mrisnnodegraphviewcontext.cpp:1061] : [ -- ] About to position 'Output' underneath 'Output', factor : 3
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [        mrigeoentitybridge.cpp:41  ] : Network is NULL
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'alSurfaceX', input count: 21
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.DiffuseColor'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.DiffuseRoughness'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Specular1Color'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Specular1Roughness'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Specular1Anisotropy'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Specular1Rotation'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Specular2Color'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Specular2Roughness'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Specular2Anisotropy'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Specular2Rotation'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.TransmissionColor'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Opacity'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.SSSColor'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.SSSRadius'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.EmissionColor'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Bump'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Normal'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Displacement'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.Vector'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.ThicknessMap'
Debug : [            mrisngroupnode.cpp:482 ] : 0x22d57730 Input Connection already named '.View_Current_Channel'
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Set Unlit
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Set Unlit
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Misc/Set Vector
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Misc/Set Vector
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Surface/Displacement Simple
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Surface/Displacement Simple
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Utils/Tangent Space To Eye Space
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Utils/Tangent Space To Eye Space
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Utils/Normal Modulation
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Utils/Normal Modulation
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Filter/Height As Normal
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Filter/Height As Normal
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Utils/Tangent Space To Eye Space
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Utils/Tangent Space To Eye Space
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Create Node : Lighting/Utils/Color To Vector
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #4 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Create Node : Lighting/Utils/Color To Vector
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #3 : Refresh Group Inputs
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #3 : Refresh Group Inputs
Debug : [ mrisnnodegraphviewcontext.cpp:421 ] : [ -- ] Need to increase size of node 'alSurfaceX', input count: 21
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #2 : Add Shader alSurfaceX
Debug : [    mrishadermaterialsview.cpp:245 ] : [ -- ] Removed old shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x1f17a4f0, 'Current Paint Target'
Debug : [    mrishadermaterialsview.cpp:251 ] : [ -- ] Added shader connection inputNodeChanged -> onNodeInputChanged, on Shader 0x22d57730, 'alSurfaceX'
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 31 children nodes to this Shader
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #1 : Add Shader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 95 ms
Debug : [            mrilayershader.cpp:578 ] : [ -- ] Connected signals from 0 children nodes to this Shader
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 101 ms
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 46  uu 69
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 1410 ms 108 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 1416 ms uu 108
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 47  uu 108
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 72 ms 108 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 72 ms uu 108
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 18 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 47  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 42 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 47  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 43 ms 17 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 47  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 45 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 152 ms
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Set Input 'alSurfaceX.DiffuseColor' to 'Diffuse_Head.Output'
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 47  uu 108
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 1494 ms 109 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 1499 ms uu 109
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 48  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 42 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 48  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 43 ms 17 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 48  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 45 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [             mrishaderview.cpp:1054] : *refreshShaderProperties for 'alSurfaceX' completed in 152 ms
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Set Input 'alSurfaceX.Specular1Color' to 'Specular_Head.Output'
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 48  uu 109
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 1554 ms 110 uu
Debug : [   mrisnglslcontextmanager.cpp:754 ] : Recompile Shader Network Shader 'Shader Network1' took 1559 ms uu 110
Debug : [           mricanvaswidget.cpp:964 ] : 0x22a2b580 Build Shaders Thread Start
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 49  uu 8 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 44 ms 8 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 49  uu 17 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 43 ms 17 uu
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 49  uu 13 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 46 ms 13 uu
Debug : [           mricanvaswidget.cpp:903 ] : 0x22a2b580 Build Shaders Thread Stop
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Fresnel Mode
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Roughness
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Reflectivity
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Edge tint
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Repeat : Message repeating...
Repeat : Last message was repeated 1 more time
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Reflectivity
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Fresnel Mode
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Repeat : Message repeating...
Repeat : Last message was repeated 1 more time
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Roughness
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Pan
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Zoom
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Roughness
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Rotation
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Displacement Bias
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Light Falloff
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Light Falloff
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Decay Rate
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed AOVs
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed AOVs
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Paint
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #1 : Projection
Debug : [      mriprojectionmanager.cpp:1368] : 0x7fecea8cf30 Occulusion Tile 0 (0.000000,0.000000)-(1.000000,1.000000) (2048,2048) (1.000000,1.000000) (2048,2048)
Debug : [      mriocclusionrenderop.cpp:255 ] : ----Occlusion Render Op Timing Breakdown...
Debug : [      mriocclusionrenderop.cpp:316 ] : [0x22821c0]----        Create offscreen buffer : 3 ms
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 20 ms for Shader 'Shader Network1' Object 'Example_Project_Head' Viewer 'Viewer' sc 50  uu 15 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 514 ms 15 uu
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Debug : [          mrishadermanager.cpp:1132] : Could not include 'alSurfaceX.glslh' from:
    C:/Users/kai.xu/Documents/Mari/Modules\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media/Shaders\include\alSurfaceX.glslh
    C:/Program Files/Mari3.0v1/Bundle/Media\alSurfaceX.glslh
Repeat : Message repeating...
Repeat : Last message was repeated 6 more times
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 3 ms for Shader 'Shader Network1' Object 'Example_Project_Eyes' Viewer 'Viewer' sc 51  uu 15 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader 'Shader Network1' reloadMacros() took 474 ms 15 uu
Debug : [      mriocclusionrenderop.cpp:471 ] : [0x22821c0]----        Rendering               : 1484 ms
Debug : [      mriocclusionrenderop.cpp:487 ] : [0x22821c0]--------        Readback                : 88 ms
Debug : [      mriocclusionrenderop.cpp:490 ] : Loop 0 ReadBackRect 0 0 2048 2048
Debug : [      mriocclusionrenderop.cpp:504 ] : [0x22821c0]--------        MapReduce                  : 10 ms
Debug : [      mriocclusionrenderop.cpp:530 ] : [0x22821c0]----         Reduce                  : 98 ms
Debug : [      mriocclusionrenderop.cpp:538 ] : ----         64 MB 727 MB/s
Debug : [      mriocclusionrenderop.cpp:540 ] : ----         Tiles 931 Compression 4505.160156 p/r
Debug : [      mriocclusionrenderop.cpp:564 ] : [0x22821c0]----        End                   : 0 ms
Debug : [      mriocclusionrenderop.cpp:565 ] : ----         Tiles 931
Debug : [   mrisnglslcontextmanager.cpp:860 ] : Shader Network Full Rebuild took 19 ms for Shader '  Default.vert' Object 'Example_Project_Head' Viewer 'Viewer' sc 52  uu 55 nb 1
Debug : [          mrimodularshader.cpp:738 ] : Shader '  Default.vert' reloadMacros() took 84 ms 54 uu
Debug : [        mrimipmapupdatejob.cpp:310 ] : Generating mipmap level 1 for 3 tiles
Debug : [        mrimipmapupdatejob.cpp:310 ] : Generating mipmap level 2 for 2 tiles
Debug : [     mriprojectionrenderop.cpp:689 ] : TOTAL Tile Count    : 6
Debug : [     mriprojectionrenderop.cpp:690 ] : TOTAL Time          : 463 ms
Debug : [     mriprojectionrenderop.cpp:693 ] : Time Taken Per Tile : 77.166664 ms
Debug : [            mriundomanager.cpp:158 ] : [UndoManager] Begin Macro #2 : Reset Paint Buffer Transform
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #2 : Reset Paint Buffer Transform
Debug : [            mriundomanager.cpp:275 ] : [UndoManager] End Macro #1 : Projection
Debug : [                mripainter.cpp:194 ] : This method is deprecated
Debug : [                mriproject.cpp:1558] : [ -- ] About to autosave project ...
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 7a600f36-a798-4a3f-a1c6-3b6641a58e0e 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 3d9ac0e7-9489-4115-9e46-20a7b889e2c4 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 4b438c38-5e2c-4533-b316-e9318e0b3bfe 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 51da21ab-ed90-4b64-8084-46cd7ce6f743 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of f58743b0-ff3e-421d-82a7-98f796bf976a 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of ecffadb3-f059-48b6-9e2c-0da6c4553212 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 78b723f8-ca72-4857-9965-f69722df0652 4
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 344920b6-ba9b-4aef-b100-39d52b45daa3 4
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 7a600f36-a798-4a3f-a1c6-3b6641a58e0e 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 3d9ac0e7-9489-4115-9e46-20a7b889e2c4 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 4b438c38-5e2c-4533-b316-e9318e0b3bfe 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 51da21ab-ed90-4b64-8084-46cd7ce6f743 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of f58743b0-ff3e-421d-82a7-98f796bf976a 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of ecffadb3-f059-48b6-9e2c-0da6c4553212 16
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 78b723f8-ca72-4857-9965-f69722df0652 4
Debug : [                mrichannel.cpp:1495] : Saving Frame 0 of 344920b6-ba9b-4aef-b100-39d52b45daa3 4
Debug : [                mriproject.cpp:1683] : Copying C:/Users/kai.xu/AppData/Local/Temp/autosave.tmp to D:/Mari/026011bb-437d-4dd3-ae5b-20bb7a1b2095/autosave.mri
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Orbit
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed AOVs
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Thick Glass effect emulation
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed AOVs
Debug : [            mriundomanager.cpp:328 ] : [UndoManager] Add : Changed Decay Rate
